---
科目: "408"
课程名称: 计算机网络
tags: []
一轮复习情况: 进行中
二轮复习情况: 进行中
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 05-传输层

## 05-1 传输层提供的服务
### 1. 传输层的功能
#传输层功能
* **在协议栈中的位置**： #协议栈
    * #传输层 位于 #网络层 和 #应用层 之间，负责 **端到端通信**。
* **主要任务**：
    * 提供**进程间的通信服务**。
    * 实现**端到端的可靠传输**。
    * 支持多种传输模式（如TCP和UDP）。

### 2. 传输层的寻址地址与面向连接服务
#传输层寻址 #面向连接服务
* **传输层的主要协议**：
    * **UDP (User Datagram Protocol)**： #UDP
        * 无连接、不可靠、面向报文的传输协议。
        * 不提供流量控制和拥塞控制。
        * 适用于实时性强、对延迟敏感的应用（如视频直播、语音通话）。
    * **TCP (Transmission Control Protocol)**： #TCP
        * 面向连接、可靠的、面向字节流的传输协议。
        * 提供流量控制和拥塞控制。
        * 适用于对数据完整性和顺序性要求较高的应用（如文件传输、Web浏览）。
* **端口号的作用**： #端口号
    * 传输层通过**端口号**来区分不同进程的数据流。
    * **IP地址 + 端口号** 形成 **#套接字（Socket）**，用于标识网络中一台主机上的一个特定进程。
* **端口号分类**：
    * **熟知端口号（0~1023）**： 常用端口，如HTTP(80), FTP(21), DNS(53)等。
    * **注册端口号（1024~49151）**：注册给特定应用或服务使用。
    * **动态/私有端口号（49152~65535）**： 客户端程序通常会临时从这个范围分配端口号。

## 05-2 UDP
#UDP
### 1. UDP数据报
* **UDP首部结构**：
    * **固定8字节**。
    * 包括：源端口号（2字节）、目的端口号（2字节）、UDP长度（2字节）、校验和（2字节）。
    * **UDP长度字段**：表示整个UDP数据报（首部 + 数据）的长度，单位为字节。理论最大长度为65535字节，但实际受限于下层网络MTU（如以太网MTU通常1500字节）。
* **UDP的特点**： #UDP特点
    * **无连接**：发送数据前无需建立连接。
    * **不可靠**：不保证数据的可靠传输、不保证按序交付、不保证数据不重复。可靠性需由应用层处理。
    * **面向报文**：发送的是一次完整的应用层报文，不会对报文进行拆分或合并。UDP一次发送一个完整的用户数据报，应用程序发送的报文有多长，UDP就多长，不会对其进行拆分，也不会合并。
    * **一对多传输**：支持 #单播 #广播  #多播
    * **传输效率高**：由于没有建立连接、流量控制、拥塞控制等机制，开销小，传输效率高。
* **UDP的应用场景**：#UDP应用场景
    * 实时性要求高的应用（如音频、视频流，因为允许少量数据丢失以保证实时性）。
    * 对数据丢失容忍度较高的应用（如DNS查询、SNMP）。
    * 小文件传输（如TFTP）。
* **UDP首部示例**：

```plaintext
发送方：进程1（端口3666） -> 主机A (IP:103.5.6.7)
接收方：进程2（端口9888） -> 主机B (IP:56.1.1.7)

UDP首部示例：
- 源端口号：3666
- 目的端口号：9888
- UDP长度：104字节（8字节UDP首部 + 96字节数据）
- 校验和：略（此例中未计算）
```

### 2. UDP检验

* **校验和计算范围**：UDP的校验和字段不仅覆盖**UDP首部**，还覆盖**UDP数据部分**以及一个**12字节的伪首部**。#伪首部
    * **伪首部**：#伪首部结构 包含源IP地址、目的IP地址、协议号（UDP为17）、UDP长度。它并不实际传输，仅用于校验和计算。
* **校验和计算步骤**：#校验和计算
    1. **添加伪首部**：在UDP数据报前添加一个12字节的伪首部。如果数据报总长度不是16位的整数倍，则在末尾填充0，但不计入UDP长度。
    2. **按16位二进制反码求和**：将伪首部、UDP首部和UDP数据部分的每个16位字（两个字节）进行二进制反码求和。
    3. **高位回卷**：如果有进位，则将最高位的进位加到最低位（即回卷）。
    4. **逐位取反**：将最终求和结果进行逐位取反，得到UDP校验和。
    5. **填入首部**：将计算出的校验和填入UDP首部中的校验和字段。
    6. **移除伪首部**：在实际传输时，伪首部会被移除。

* **校验和验证**：#校验和验证
    * **接收方过程**：
        1. 接收方收到UDP数据报后，同样加上伪首部，并对伪首部、UDP首部和UDP数据部分重新计算校验和。
        2. 将计算结果与UDP首部中的校验和字段进行**二进制反码求和**。
        3. 如果最终结果为**全1**（即0xFFFF），则说明数据报在传输过程中没有发生错误。
        4. 否则，说明数据报有错，通常会**丢弃**该数据报，并向上层应用报告错误（但不保证报告）。

## 05-3 TCP
### 1. TCP报文段结构
#TCP报文段 #TCP首部
![[考研学习笔记04-计算机网络 05-传输层 2025-10-15 0731.png|500x321]]
* **TCP首部**：**20~60字节**（不含选项字段为20字节，含选项字段最大60字节）。
    * **源端口号**（发送方对应的端口号16位）、**目的端口号**（接收方对应的端口号16位）。
    * **序列号 (Sequence Number)**（32位）： #序列号 指本报文段所发送的数据的**第一个字节的序号**。
    * **确认号 (Acknowledgment Number)**（32位）： #确认号 期望收到对方下一个报文段的**第一个数据字节的序号**。若确认号为N，表示N-1及之前的数据已全部正确收到。
    * **数据偏移（首部长度）**（4位）： #数据偏移 TCP首部长度，以4字节为单位，最大15（即15 * 4 = 60字节）。
    * **保留字段**（6位）。
    * **标志位 (Flags)**（6位）： #TCP标志位
        * **URG** (Urgent)：紧急指针有效。（1时尽快插队发送）
        * **ACK** (Acknowledgement)：确认号有效。（只有第一次握手是0）
        * **PSH** (Push)：尽快向上层交付数据。
        * **RST** (Reset)：重建连接。
        * **SYN** (Synchronize)：同步序号，用于建立连接。（只有握手1、握手2的SYN=1）
        * **FIN** (Finish)：发送方数据已发送完毕，请求释放连接。（只有挥手1、挥手3的FIN=1）

> [!note]
> * 若SYN=1 称为SYN段
> * 若FIN=1 称为FIN段
> * 若ACK=1 称为ACK段

* then
    * **窗口大小 (Window Size)(rvwnd)**（16位）：接收方目前允许发送方发送的最大数据量，以字节为单位。用于 #流量控制。
    * **校验和 (Checksum)**（16位）：校验整个TCP报文段（包括伪首部）的完整性。![[考研学习笔记04-计算机网络 05-传输层 2025-10-15 3607.png]]
    * **紧急指针 (Urgent Pointer)**（16位）：在URG标志有效（1）时，指出紧急数据相对于当前序列号的偏移量。
    * **选项 (Options)**（变长）： #TCP选项  如最大报文段长度 (MSS)、窗口扩大因子、时间戳等。
* **TCP报文段特点**： #TCP特点
    * **面向连接**：数据传输前需通过 #三次握手 建立连接。
    * **可靠传输**：通过 #确认机制、#重传机制、#校验和 等保证数据的正确性。
    * **流量控制**：通过 #滑动窗口 和 #窗口大小 字段，协调发送方和接收方的数据发送速率。
    * **拥塞控制**：通过 #慢开始 、 #拥塞避免 、 #快重传 、 #快恢复 等算法，防止网络拥塞。
    * **有序传输**：通过 #序列号 保证数据按序交付给应用层。
    * **面向字节流**：TCP把应用层数据看作一连串无结构的字节流，将数据进行分段发送，接收方按序接收并组装成字节流交付给应用层。

### 2. TCP的三大阶段
1. **建立连接**：通过 #三次握手 （SYN, SYN-ACK, ACK）建立客户端和服务器之间的连接。
2. **数据传输**：连接建立后，双方可以发送和接收 #TCP报文段 进行数据交互。
3. **释放连接**：数据传输完毕后，通过 #四次挥手 （FIN, ACK, FIN, ACK）释放连接。
![[考研学习笔记04-计算机网络 05-传输层 2025-10-15 4947.png|608x454]]

### 3. TCP连接管理
#TCP连接管理
#### 3.1 三次握手
#三次握手
![[考研学习笔记04-计算机网络 05-传输层 2025-10-15 4833.png]]
* **目的**：确保双方都已准备好发送和接收数据，并交换初始序列号。
1. **第一次握手**：
    * 客户端发起请求，发送 #SYN 报文段，`SYN=1`，`ACK=0`。
    * 序号（sequence）由客户端随机选定，如666。
    * 确认号（ACK sequence）无效，因此不设置。
    * 客户端进入 `SYN-SENT` 状态。
2. **第二次握手**：
    * 服务器收到SYN后，发送 #SYN-ACK 报文段（`SYN=1`, `ACK=1`）。
    * 确认号 客户端的序号+1`ack = client_isn + 1`，序列号 `seq = server_isn`,由服务器随机选定。
    * 服务器进入 `SYN-RECEIVED` 状态。
3. **第三次握手**：
    * 客户端收到SYN-ACK后，发送 #ACK 报文段（`ACK=1`）。`SYN=0`
    * 确认号 服务器的序号+1`ack = server_isn + 1`，序列号 `seq = client_isn + 1`。
    * 序号根据握手一之后的数据发送情况确定，如667或677。
    * 客户端进入 `ESTABLISHED` 状态。
    * 服务器收到ACK后，也进入 `ESTABLISHED` 状态。连接建立完成。

> [!note] **握手过程中的序号与确认号变化**
>  * 握手一和握手二不携带数据，但仍消耗一个序号。
>  * 握手三可携带数据，消耗的序号数量与数据长度有关。
>  * 确认号始终表示期望收到的下一个字节的序号。

> [!note] **TCP状态转换流程**
>  * **客户端状态变化**
>    * close → SYN_SENT（发送握手一） → ESTABLISHED（收到握手二）。
>  * **服务器状态变化**
>    * close → LISTEN（等待连接） → SYN_RCVD（收到握手一） → ESTABLISHED（收到握手三）。

* **连接建立阶段的最短耗时分析**
  * RTT（往返时延）是计算连接耗时的基本单位。
  * **客户端发送数据的最早时间**
    * 收到握手二后即可发送数据，耗时为1 RTT。
  * **服务器发送数据的最早时间**
    * 收到握手三后即可发送数据，耗时为1.5 RTT。
  * **从握手二发出到服务器可发送数据**
    * 耗时为1 RTT。

#### 3.2 四次挥手
#四次挥手
* **目的**：安全地终止TCP连接，确保所有数据都已传输完毕。
1. **第一次挥手**：
    * 客户端发送 #FIN 报文段（`FIN=1`），表示客户端不再发送数据。
    * 客户端进入 `FIN-WAIT-1` 状态。
2. **第二次挥手**：
    * 服务器收到FIN后，发送 #ACK 报文段，确认收到客户端的FIN。
    * 服务器进入 `CLOSE-WAIT` 状态（此时服务器仍可向客户端发送数据）。
    * 客户端收到ACK后，进入 `FIN-WAIT-2` 状态。
3. **第三次挥手**：
    * 服务器处理完所有数据后，发送 #FIN 报文段（`FIN=1`），表示服务器也不再发送数据。
    * 服务器进入 `LAST-ACK` 状态。
4. **第四次挥手**：
    * 客户端收到服务器的FIN后，发送 #ACK 报文段，确认收到服务器的FIN。
    * 客户端进入 `TIME-WAIT` 状态，等待 #2MSL 后彻底关闭连接。
    * 服务器收到ACK后，立即进入 `CLOSED` 状态。
    * `TIME-WAIT` 状态结束后，客户端进入 `CLOSED` 状态。连接释放完成。

#### 3.3 TCP状态转换
#TCP状态

| 状态              | 描述                                                                             |
| :---------------- | :------------------------------------------------------------------------------- |
| `CLOSED`          | 连接关闭，无活动连接。|
| `LISTEN`          | 服务器监听状态，等待客户端连接请求（SYN）。|
| `SYN-SENT`        | 客户端已发送SYN报文段，等待服务器的SYN-ACK响应。|
| `SYN-RECEIVED`    | 服务器已收到SYN，并发送了SYN-ACK，等待客户端的ACK。|
| `ESTABLISHED`     | 连接已建立，可以进行数据传输。|
| `FIN-WAIT-1`      | 客户端已发送FIN，等待服务器的ACK。|
| `FIN-WAIT-2`      | 客户端收到服务器的ACK，等待服务器的FIN。|
| `TIME-WAIT`       | 客户端在收到服务器的FIN和发送ACK后进入此状态，等待2MSL（最长报文段寿命）确保所有报文到达或消失，防止新旧连接混淆。|
| `CLOSE-WAIT`      | 服务器收到客户端的FIN并发送ACK后进入此状态，等待本地应用关闭连接并发送自己的FIN。|
| `LAST-ACK`        | 服务器已发送FIN，等待客户端的最终ACK。|

### 4. TCP可靠传输与流量控制
#TCP可靠传输 #流量控制
* **累积确认 (Cumulative Acknowledgment)**： #累积确认
    * 接收方在发送ACK时，确认号表示它期望收到的下一个字节的序号。这意味着所有序号在该确认号之前的字节都已被成功接收。
    * 例如，确认号为1001，表示1000及之前的字节都已收到。
* **捎带确认 (Piggybacking)**： #捎带确认
    * 接收方在发送自身数据报文段时，可将对发送方数据的ACK信息"捎带"在数据报文段的首部一起发送，减少单独发送ACK的开销。
* **超时重传 (Timeout Retransmission)**： #超时重传
    * 发送方为每个已发送但未被确认的报文段设置一个**超时计时器**。
    * 如果在计时器超时时间内没有收到该报文段的ACK，发送方就认为该报文段或其ACK丢失，并**重传**该报文段。
    * #RTT (往返时间) 动态估算：超时时间 `RTO` (Retransmission Timeout) 会根据网络RTT动态调整。
* **选择重传 (Selective Retransmission)**： #选择重传
    * 在接收方，如果收到的数据不是期望的下一个序号，而是"跳过"了一些序号，它会**选择性地确认**已收到的乱序报文段，并告知发送方哪些序号范围的报文段是缺失的。发送方只需要重传缺失的报文段，而不是所有从第一个缺失报文段开始的后续报文段。这需要TCP选项支持。
* **快重传 (Fast Retransmit)**： #快重传
    * 当发送方连续收到**三个重复的ACK**（即对同一个报文段的确认），发送方就认为该报文段已丢失（而不是等待超时），立即**重传**该丢失的报文段，而无需等待计时器超时。
    * 这能显著提高拥塞情况下的传输效率。
* **流量控制**：#流量控制
    * 通过滑动窗口协议实现。接收方通过TCP首部中的 **#窗口大小** 字段告知发送方自己当前可接收的字节数，以防止发送方发送速度过快导致接收方缓冲区溢出。
    * 发送方的发送窗口大小不能超过接收方 advertised window size。

### 5. TCP拥塞控制
#TCP拥塞控制
* **拥塞窗口 (cwnd, Congestion Window)**： #拥塞窗口 发送方维护的一个状态变量，表示在不引起网络拥塞的情况下可以发送的最大数据量。
* **慢开始门限 (ssthresh, Slow Start Threshold)**： #慢开始门限 一个阈值，用于区分慢开始阶段和拥塞避免阶段。
* **拥塞控制算法**：
    1. **慢开始 (Slow Start)**： #慢开始
        * 连接建立初期，`cwnd` 初始值为1个 #MSS (最大报文段长度)。
        * 每收到一个ACK，`cwnd` 呈指数级增长（`cwnd` = `cwnd` + `MSS`），直到达到 `ssthresh`。
    2. **拥塞避免 (Congestion Avoidance)**：#拥塞避免
        * 当 `cwnd` 达到 `ssthresh` 后，`cwnd` 线性增长。
        * 每经过一个 #RTT (往返时间)，`cwnd` = `cwnd` + `MSS`。
    3. **拥塞发生**：
        * **超时**（定时器到期未收到ACK）：`ssthresh` 设置为当前 `cwnd` 的一半，`cwnd` 重新设置为1，回到慢开始阶段。
        * **快重传**（收到三个重复ACK）：`ssthresh` 设置为当前 `cwnd` 的一半，`cwnd` 设置为 `ssthresh` + 3个MSS，进入 #快恢复 阶段。
    4. **快恢复 (Fast Recovery)**：#快恢复
        * 当发送方执行快重传后，`cwnd` 立即设置为 `ssthresh` + 3个MSS。
        * 发送方每收到一个重复ACK，`cwnd` 增加1个MSS（为了弥补网络中正在传输的报文段）。
        * 当收到**新的ACK**（确认了所有丢失的报文段）时，`cwnd` 设置为 `ssthresh`，进入拥塞避免阶段。
* **拥塞控制示例**：

```plaintext
初始：ssthresh = 16 MSS, cwnd = 1 MSS

1 RTT (慢开始)：cwnd = 2 MSS (发送1个报文，收到1个ACK，cwnd变为2)
2 RTT (慢开始)：cwnd = 4 MSS (发送2个报文，收到2个ACK，cwnd变为4)
3 RTT (慢开始)：cwnd = 8 MSS
4 RTT (慢开始)：cwnd = 16 MSS (达到ssthresh)
5 RTT (拥塞避免)：cwnd = 17 MSS (收到ACK，cwnd+1)
6 RTT (拥塞避免)：cwnd = 18 MSS
…
假设在某个RTT，cwnd = 24 MSS 时，收到3个冗余ACK（假设是对第10个MSS报文的）。
触发快重传：
快恢复：
   ssthresh = cwnd / 2 = 24 / 2 = 12 MSS
   cwnd = ssthresh + 3 MSS = 12 + 3 = 15 MSS
   重传丢失的报文段。
继续在快恢复阶段：
   每收到一个冗余ACK，cwnd再增加1个MSS。
当收到新的ACK（确认了之前的所有丢失和重传的报文段）时：
   cwnd = ssthresh = 12 MSS，进入拥塞避免阶段。
```

---

### TCP序列号与确认号

#### 1. **TCP（传输控制协议）基础**
*   **定义**：TCP（Transmission Control Protocol）是互联网协议族中的一个核心协议，工作在OSI模型的**传输层**。
*   **服务特性**：
    *   **面向连接**：数据传输前需建立（三次握手）、传输中维护、传输后释放连接。
    *   **可靠传输**：确保数据不丢失、不重复、按序到达。这是通过序列号、确认号、重传机制和计时器实现的。
    *   **基于字节流**：TCP将应用程序数据视为一个无结构的字节流，不关心应用程序的数据边界，只负责将字节流可靠传输。
    *   **全双工**：数据可在两个方向上同时传输。
    *   **流量控制**：通过滑动窗口机制避免发送方发送速度过快，导致接收方来不及处理。
    *   **拥塞控制**：避免网络过载。

#### 2. **序列号（Sequence Number - SYN）**

*   **谁使用**：发送方。
*   **含义**：
    *   TCP报文段头部的序列号字段，表示该报文段中**所携带的第一个数据字节的序号**。
    *   在TCP连接建立时，会随机选择一个初始序列号（ISN）。后续的数据传输中，序列号会递增。
*   **作用**：
    *   **唯一标识**：确保每个发送的字节都有一个唯一的序号。
    *   **乱序重排**：接收方可以根据序列号对乱序到达的报文段进行正确排序。
    *   **去除重复**：接收方可以识别并丢弃重复的报文段。
    *   **实现可靠性**：与确认号配合，用于判断哪些数据已成功到达，哪些需要重传。

#### 3. **确认号（Acknowledgement Number - ACK）**

*   **谁使用**：接收方（在接收到数据后发送确认报文）。
*   **含义（核心！）**：
    *   TCP报文段头部的确认号字段，表示发送方**"期望收到的下一个字节的序列号"**。
    *   换句话说，确认号 `N` 意味着**接收方已经成功收到了序列号到 `N-1` 的所有数据字节**。
*   **作用**：
    *   **告知已接收数据**：让发送方知道哪些数据已安全抵达。
    *   **请求下一个数据**：通过期望的下一个序列号，请求发送方继续发送后续数据。
    *   **累计确认（Cumulative Acknowledgment）**：TCP通常采用累计确认。一个确认号 `N` 意味着 `N-1` 及 `N-1` 之前的所有字节都已成功收到，即使中间有报文段跳过，只要最终能够确认到某个点，就代表该点之前的所有数据均已确认。
*   **注意**：只有当TCP报文段头部中的ACK标志位被置为 1 时，确认号字段才有效。

#### 4. **本题考点梳理**

*   **序列号的递增**：发送方的序列号是基于**已发送的有效载荷字节数**递增的。
    *   例：序列号 `200` + `300` 字节载荷 = 字节范围 `200` 到 `499`。下一个报文段的序列号将是 `500`。
*   **确认号的计算**：
    *   接收方发送的确认号 = **已成功接收的最后一个字节的序列号 + 1**。
    *   这是理解此类问题的关键。即使题目涉及多个连续段，只要都正确接收，确认号就是所有已接收数据中最后一个字节的下一个序列号。
    *   例：接收到 `200-499` 和 `500-999` 的字节。最后接收的字节是 `999`。
    *   所以，期望收到的下一个字节是 `999 + 1 = 1000`。确认号即为 `1000`。

#### 5. **易错点**

*   **确认号不是收到的最后一个报文段的序列号！** 它是"期望收到的下一个字节的序列号"。
*   **确认号不是收到的总字节数！** 它是基于序列号的累积确认。

---
