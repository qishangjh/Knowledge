---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 05-6 指令流水线
 #指令流水线 #CPU #性能优化 #流水线冒险 #数据相关 #控制相关 #结构相关 #加速比 #吞吐率

> [!NOTE] 学习目标
> *   理解指令流水线的定义、基本思想和优势。
> *   掌握流水线各个阶段（IF, ID, EX, M, WB）的功能和时序。
> *   了解不同类型指令（运算类、LOAD、STORE、转移指令）在五段式流水线中的执行流程。
> *   深入理解流水线的三大类冒险（结构相关、数据相关、控制相关）及其产生原因。
> *   掌握解决流水线冒险的各种方法（暂停、数据旁路、分支预测等）。
> *   熟练计算流水线的性能指标：吞吐率、加速比、效率。
> *   了解流水线的分类和高级流水线技术（超标量、超流水、VLIW）。

## 05-6 指令流水线：CPU的"高速生产线"

### 1. 指令流水线的定义与基本概念

#### (1) 定义

**指令流水线**是一种**并行处理技术**。它将一条指令的执行过程分解成多个独立的、顺序的阶段（或子过程），并让多条指令在这些阶段中**重叠**执行，从而提高CPU单位时间内执行的指令数量（即**吞吐率**）。

#### (2) 与传统执行方式的对比 (以3阶段为例)

假设一条指令的执行分为3个阶段：**取指 (IF)**、**分析 (ID)**、**执行 (EX)**，每个阶段耗时 `Δt`。

* **1. 顺序执行方式 (串行执行)**：
    * **特点**：传统冯·诺依曼机采用。一条指令完全执行完（`3Δt`）后，下一条指令才能开始。
    * **总耗时**：`T = n × 3Δt = 3nΔt` (n条指令)。
    * **优缺点**：
        * 优点：控制简单，硬件代价小。
        * 缺点：执行速度慢，功能部件利用率低（同一时刻只有一个功能部件在工作）。

    ```
    指令1: [IF | ID | EX]
    指令2:             [IF | ID | EX]
    指令3:                         [IF | ID | EX]
    时间轴 ->
    ```

* **2. 一次重叠执行方式**：
    * **特点**：在指令1的分析阶段，指令2的取指阶段可以开始。
    * **总耗时**：`T = 3Δt + (n-1) × 2Δt = (1+2n)Δt` (n条指令)。
    * **优缺点**：
        * 优点：执行时间缩短，部件利用率提高。
        * 缺点：控制过程比顺序执行复杂，硬件开销增大。

    ```
    指令1: [IF | ID | EX]
    指令2:      [IF | ID | EX]
    指令3:             [IF | ID | EX]
    时间轴 ->
    ```

* **3. 二次重叠执行方式 (理想流水线)**：
    * **特点**：每个阶段都可以在上一个阶段完成后，立即开始处理下一条指令。在正常情况下，处理机中同时有3条指令在不同阶段执行。
    * **总耗时**：`T = kΔt + (n-1) × Δt = (k + n - 1)Δt` (n条指令，k个阶段，此处k=3)。
        * `T = 3Δt + (n-1) × Δt = (2+n)Δt`。
    * **优缺点**：
        * 优点：执行时间大幅缩短（比顺序执行缩短近2/3），是一种理想的指令执行方式。
        * 缺点：控制最复杂，硬件开销大。

    ```
    指令1: [IF | ID | EX]
    指令2:      [IF | ID | EX]
    指令3:           [IF | ID | EX]
    时间轴 ->
    ```

    > [!TIP] 阶段划分  
    > 考研中，指令执行过程常划分为5个阶段，这是比较常见的做法。

#### (3) 流水线的表示方法

* **指令执行过程图**：以指令为行，阶段为列，通过箭头表示指令执行顺序。主要用于分析指令执行过程以及影响流水线的因素（冒险）。
* **时空图 (Space-Time Diagram)**：以时间为横轴，空间（流水线各阶段/硬件资源）为纵轴。主要用于分析流水线的性能（吞吐率、加速比、效率）。

#### (4) 机器周期的设置

* **原则**：为方便流水线设计，将每个阶段的耗时取成一样，以**所有阶段中最长的耗时为准**。
    * 例如：各部件实际耗时 `IF: 100ns, ID: 80ns, EX: 70ns, M: 50ns, WB: 50ns`。
    * 则机器周期（或时钟周期）应设置为 `100ns`。
* **缓冲寄存器/锁存器 (Pipeline Registers/Latches)**：
    * 流水线每一个功能段部件后面都要有一个缓冲寄存器，其作用是**保存本流水段的执行结果**，并提供给下一流水段使用。
    * 它们将流水线的各个阶段隔离开来，确保数据的正确传递。

### 2. 五段式指令流水线：详细阶段与指令执行

五段式指令流水线是一种常见的RISC处理器流水线设计，将指令执行分为以下五个阶段：
1. **IF (Instruction Fetch)**：**取指**。根据程序计数器(PC)的内容，从**指令Cache**中取出一条指令，并将其送至IF段的锁存器。同时PC更新指向下一条指令。
2. **ID (Instruction Decode / Register Fetch)**：**译码&取数**。对IF段锁存器中的指令进行译码，识别操作类型、寻址方式和操作数。同时，从**寄存器堆**中取出指令所需的源操作数（若有），并存入ID段锁存器。
3. **EX (Execute)**：**执行**。根据指令类型，ALU执行算术逻辑运算，或计算内存访问的有效地址。将结果存入EX段锁存器。
4. **M (Memory Access)**：**访存**。如果指令需要访问内存（LOAD/STORE指令），则通过**数据Cache**进行读/写操作。将从内存中取出的数据或要写入的数据存入M段锁存器。
5. **WB (Write Back)**：**写回寄存器**。将EX或M段的运算结果或访存结果写回指定的**寄存器**。

> [!NOTE] RISC处理器特性  
> 通常，RISC处理器只有"取数LOAD"和"存数STORE"指令才能访问主存。运算类指令的操作数都在寄存器之间进行。

#### (1) 运算类指令的执行过程

* **示例**：`ADD Rd, Rs` (将 `Rs` 的内容加到 `Rd`，结果存回 `Rd`) 或 `SHL Rd, #N`。
* **指令功能**：`(Rs) + (Rd) -> Rd`
* **流水线阶段**：
    * **IF**：根据PC从指令Cache取指令。
    * **ID**：取出源操作数 (`Rs`, `Rd`) 的值到ID段锁存器。
    * **EX**：ALU执行加法/左移运算，将结果存入EX段锁存器。
    * **M**：**空段** (运算类指令不需要访存数据)。
    * **WB**：将EX段的运算结果写回指定目的寄存器 (`Rd`)。

#### (2) LOAD指令的执行过程

* **示例**：`LOAD Rd, 996(Rs)` (将 `(996 + (Rs))` 内存地址处的数据加载到 `Rd` 寄存器)。
* **指令功能**：`(996 + (Rs)) -> Rd`
* **流水线阶段**：
    * **IF**：取指令。
    * **ID**：取出基址寄存器 `Rs` 的值放入锁存器A，将偏移量 `996` 放入锁存器Imm。
    * **EX**：ALU计算有效地址 `(Rs) + 996`。
    * **M**：根据EX段计算出的有效地址，从**数据Cache**中取数，并放入M段锁存器。
    * **WB**：将从数据Cache中取出的数写回指定目的寄存器 (`Rd`)。

#### (3) STORE指令的执行过程

* **示例**：`STORE Rs, 996(Rd)` (将 `Rs` 寄存器的内容存入 `(996 + (Rd))` 内存地址)。
* **指令功能**：`Rs -> (996 + (Rd))`
* **流水线阶段**：
    * **IF**：取指令。
    * **ID**：取出基址寄存器 `Rd` 的值放入锁存器A，将偏移量 `996` 放入锁存器Imm。同时，将要存储的源操作数 `Rs` 的值放入锁存器B。
    * **EX**：ALU计算有效地址 `(Rd) + 996`。并将锁存器B的内容（即要存储的数据）放入Store段锁存器。
    * **M**：根据EX段计算出的有效地址，将Store段锁存器中的数据写入**数据Cache**。
    * **WB**：**空段** (STORE指令的结果是写回内存，不是写回寄存器)。

#### (4) 条件转移指令的执行过程

* **示例**：`beq Rs, Rt, #偏移量` (若 `(Rs) == (Rt)`，则PC跳转；否则顺序执行)。
* **指令功能**：`若(Rs)==(Rt),则(PC)+指令字长+(偏移量×指令字长)àPC；否则(PC)+指令字长àPC`
* **流水线阶段**：
    * **IF**：取指令。
    * **ID**：将进行比较的两个数 (`Rs`, `Rt`) 放入锁存器A、B；偏移量放入Imm。
    * **EX**：ALU执行比较运算 (`Rs == Rt`)，并计算出目标PC值。
    * **M**：将EX段计算出的目标PC值写回PC寄存器（或更新PC，实现跳转）。
    * **WB**：**空段** (指令的最终结果是改变PC，不是写回通用寄存器)。
    * **注**：转移类指令常采用相对寻址。很多教材把写回PC的功能段称为"WrPC段"，其耗时比M段更短，可安排在M段时间内完成。PC通常在IF段结束之后就会自动+1，这里是根据条件修改PC的值。

#### (5) 无条件转移指令的执行过程

* **示例**：`jmp #偏移量` (PC跳转到新的地址)。
* **指令功能**：`(PC)+指令字长+(偏移量×指令字长) -> PC`
* **流水线阶段**：
    * **IF**：取指令。
    * **ID**：偏移量放入Imm。
    * **EX**：ALU计算目标PC值，并将目标PC值写回PC寄存器（或更新PC）。
    * **M**：**空段**。
    * **WB**：**空段**。
    * **注**："WrPC段"耗时比EX段更短，可安排在EX段时间内完成。WrPC段越早完成，就越能避免控制冲突。当然，也有的地方会在WB段时间内才修改PC的值。

### 3. 影响流水线的因素 (流水线冒险/冲突)

流水线虽然能提高性能，但并非总能理想运行。当指令的执行发生冲突，需要等待时，就会产生"冒险" (Hazards)，导致流水线停顿，降低效率。

#### (1) 结构相关（资源冲突）

* **原因**：多条指令在**同一时刻争用同一个硬件资源**而形成的冲突。
    * **常见示例**：早期冯·诺依曼结构中，指令和数据都存放在同一个内存中。在某个时钟周期，一条指令可能在进行IF (取指令) 阶段需要访问内存，而另一条指令可能在进行M (访存数据) 阶段也需要访问内存。此时就会发生内存资源的冲突。
* **解决办法**：
    1. **后一相关指令暂停一周期**：让冲突的指令等待一个或多个时钟周期，直到资源可用。这会插入"气泡" (stall)。
    2. **资源重复配置**：例如采用**哈佛结构**，将**指令存储器**和**数据存储器**分开，使得指令取指和数据访存可以同时进行。或者增加ALU等功能部件的数量。

#### (2) 数据相关（数据冲突）

* **原因**：在一个程序中，存在必须等**前一条指令执行完才能执行后一条指令**的情况（因为后一条指令需要前一条指令的执行结果作为操作数）。
* **冲突类型**：
    * **RAW (Read After Write)**：**写后读**。后续指令读之前，前一条指令必须先写。
        * `I1: ADD R1, R2, R3` (R1 = R2 + R3)
        * `I2: SUB R4, R1, R5` (R4 = R1 - R5)
        * `I2` 需要 `I1` 产生的 `R1` 的值。
    * **WAR (Write After Read)**：**读后写**。后续指令写之前，前一条指令必须先读。
        * `I1: ADD R2, R4, R5` (R2 = R4 + R5)
        * `I2: MUL R2, R1, R3` (R2 = R1 * R3)
        * `I2` 写 `R2`，但 `I1` 已经读了 `R2`。
    * **WAW (Write After Write)**：**写后写**。后续指令写之前，前一条指令必须先写。
        * `I1: MUL R1, R2, R3` (R1 = R2 * R3)
        * `I2: SUB R1, R4, R5` (R1 = R4 - R5)
        * 两条指令都写 `R1`。

> [!TIP] 注意！  
    > 在采用"**按序发射，按序完成**"的流水线中，通常**只可能出现RAW相关**。WAR和WAW冲突更多出现在乱序执行的流水线中。

* **解决办法**：
    1. **暂停相关指令 (Stall / 插入NOP)**：
        * **硬件阻塞 (Stall)**：当检测到数据相关时，硬件会自动暂停后续指令的执行，插入**气泡**，直到数据可用。
        * **软件插入"NOP" (No Operation)**：在编译时，编译器检测到相关，手动在相关指令之间插入"空操作"指令，延迟后续指令的执行。
    2. **数据旁路技术 (Data Forwarding / Bypassing)**：
        * 这是最常用的解决RAW冒险的方法。
        * 在指令结果**还没写回寄存器**时，直接将结果从其产生的阶段（如EX阶段或M阶段的输出）**转发**给需要它的后续指令的输入端，避免等待。
    3. **编译优化 (Compiler Scheduling)**：
        * 编译器通过**调整指令顺序**来避免或减少数据相关。例如，将不相关的指令插入到有相关指令之间，以填补潜在的停顿。

#### (3) 控制相关（控制冲突）

* **原因**：当流水线遇到**转移指令**（如条件分支 `Jcc`、无条件跳转 `JMP`、子程序调用 `CALL`、返回 `RET`）和其他改变 `PC` 值的指令时，由于不确定下一条指令的取指地址，会造成流水线断流。
    * CPU需要等待分支条件判断的结果和目标地址计算完成后，才能确定从哪里取下一条指令。
* **解决办法**：
    1. **转移指令分支预测 (Branch Prediction)**：
        * **简单预测**：总是猜测分支成功（跳转）或总是猜测分支失败（不跳转）。
        * **动态预测**：根据历史执行情况动态调整预测。预测正确则流水线不中断，预测错误则需要**冲刷 (Flush)** 流水线，清除错误预测带来的指令，并从正确分支重新取指，会带来较大的惩罚。
    2. **预取转移成功和不成功两个控制流方向上的目标指令**：
        * 同时预取分支的两个可能路径的指令，等到分支结果确定后再选择正确的路径。
    3. **加快和提前形成条件码**：
        * 尽快计算出分支条件，以便更早地决定分支走向。
    4. **提高转移方向的猜准率**：通过更复杂的预测算法和历史信息。
    5. **延迟分支 (Delayed Branch)**：
        * 在分支指令后面插入一些**与分支结果无关**的指令（**延迟槽指令**），这些指令无论分支是否成功都会执行。这样可以填充分支指令带来的延迟。

#### (4) 例题分析 (来自王道考研)

**指令序列**：  
`I1: LOAD R1, [a]` (将内存 `[a]` 的内容加载到 `R1`)  
`I2: LOAD R2, [b]` (将内存 `[b]` 的内容加载到 `R2`)  
`I3: ADD R1, R2` (将 `R1` 与 `R2` 相加，结果存回 `R2`)  
`I4: STORE R2, [x]` (将 `R2` 的内容存入内存 `[x]`)

**流水线执行过程图** (假设无转发，同一寄存器的读写不能在同一个时钟周期内进行)：

| 指令 | C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 | C11 | C12 | C13 | C14 |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| I1   | IF | ID | EX | M  | WB |    |    |    |    |     |     |     |     |     |
| I2   |    | IF | ID | EX | M  | WB |    |    |    |     |     |     |     |     |
| I3   |    |    |    | IF | ID | EX | M  | WB |    |     |     |     |     |     |
| I4   |    |    |    |    |    | IF | ID | EX | M  | WB  |     |     |     |     |

**问**：`I3` 的 `ID` 段和 `I4` 的 `IF` 段被阻塞的原因各是什么？

* **`I3` 的 `ID` 段被阻塞的原因**：
    * `I3: ADD R1, R2` 需要 `R1` 和 `R2` 的值。
    * `R1` 的值来自 `I1: LOAD R1, [a]` 的 `WB` 段（在 `C5` 时刻）。
    * `R2` 的值来自 `I2: LOAD R2, [b]` 的 `WB` 段（在 `C6` 时刻）。
    * 由于是"按序发射，按序完成"且无转发，`I3` 必须等到 `I2` 的 `WB` 段完成（`C6` 时刻）才能获得 `R2` 的最终值，因此 `I3` 的 `ID` 段被阻塞，直到 `C5` (甚至 `C6`) 才能开始。
    * 准确说，`I3` 的 `ID` 段需要 `R1` 和 `R2`，而 `R1` 和 `R2` 是 `I1` 和 `I2` 的目的寄存器。`I1` 在 `C5` 才能写回 `R1`，`I2` 在 `C6` 才能写回 `R2`。`I3` 的 `ID` 段（取寄存器操作数）必须等待所有所需寄存器数据都写回后才能进行。所以 `I3` 的 `ID` 段会被阻塞到 `C6` 完成后，也就是在 `C7` 才能真正开始。
    * **原因**：`I3` 与 `I1` 和 `I2` 存在 **RAW数据相关**。
* **`I4` 的 `IF` 段被阻塞的原因**：
    * `I4: STORE R2, [x]`。虽然看起来 `IF` 段只是取指令，与数据无关。但题目假设"**同一寄存器的读和写操作不能在同一个时钟周期内进行**"。
    * `I3: ADD R1, R2` 在 `C8` 写入 `R2`。
    * `I4: STORE R2, [x]` 在 `C7` 的 `ID` 段需要**读取 `R2`**（作为源操作数）。
    * 这里存在 `I4` 读取 `R2` (在 `C7` 的 `ID` 段) 与 `I3` 写入 `R2` (在 `C8` 的 `WB` 段) 的**数据相关**。由于没有转发，`I4` 必须等待 `I3` 写回 `R2` 才能读取。
    * 但这里题目问的是 `I4` 的 `IF` 段被阻塞的原因。根据王道书的说明，这是一个"按序发射，按序完成"流水线的通用规则：**只有上一条指令进入ID段后，下一条指令才能开始IF段，否则会覆盖IF段锁存器的内容。** 这更像是一个**结构上的限制**或**控制策略**，确保流水线寄存器的数据不会被提前覆盖，保证流水线的按序发射。
    * **原因（王道解释）**：`I4` 的 `IF` 段必须在 `I3` 进入 `ID` 段后才能开始，否则会覆盖 `IF` 段锁存器的内容。这是一个关于**指令发射顺序的规定**，确保流水线正常推进。
    * **更深层次看**：`I4` 与 `I3` 之间也存在 **RAW数据相关** (`I4` 需要 `I3` 写入 `R2` 的结果)。在无转发的情况下，`I4` 需要等待 `I3` 的 `WB` 阶段完成（`C8`）。为了避免冲突，`I4` 的 `IF` 段也会被推迟。

### 4. 流水线的性能指标

流水线的性能通常通过三个指标来衡量：

#### (1) 吞吐率 (Throughput, TP)

* **定义**：单位时间内流水线所完成的任务数量，或是输出结果的数量。
* **计算公式**：`TP = n / Tk` (n为任务数，Tk为完成n个任务所用的总时间)。
* **理想情况 (n条指令，k个阶段，每个阶段耗时Δt)**：
    * `Tk = (k + n - 1)Δt`
    * `TP = n / ((k + n - 1)Δt)`
* **最大吞吐率 (TPmax)**：
    * 当连续输入的任务 `n → ∞` 时，`TPmax = 1 / Δt` (即每个时钟周期完成一条指令)。

#### (2) 加速比 (Speedup, S)

* **定义**：完成同样一批任务，**不使用流水线**所用的时间与**使用流水线**所用的时间之比。
* **计算公式**：`S = T0 / Tk` (T0为顺序执行时间，Tk为流水线执行时间)。
* **理想情况 (n条指令，k个阶段，每个阶段耗时Δt)**：
    * `T0 = n × kΔt`
    * `Tk = (k + n - 1)Δt`
    * `S = (n × kΔt) / ((k + n - 1)Δt) = (n × k) / (k + n - 1)`
* **最大加速比 (Smax)**：
    * 当连续输入的任务 `n → ∞` 时，`Smax = k` (加速比接近流水线段数)。

#### (3) 效率 (Efficiency, E)

* **定义**：流水线的设备利用率，反映流水线中各功能段被有效利用的程度。
* **在时空图上**：效率定义为完成 `n` 个任务占用的时空区有效面积与 `n` 个任务所用的时间与 `k` 个流水段所围成的时空区总面积之比。
* **计算公式**：`E = (n × kΔt) / (k × (k + n - 1)Δt) = n / (k + n - 1)`
    * (有效面积 = `n` 条指令 × `k` 个阶段 × 每个阶段时间`Δt`，即 `n` 个任务在理想串行执行下占用的时空方格数)
    * (总面积 = `k` 个阶段 × 流水线总时间`Tk`，即 `k × (k + n - 1)Δt`)
* **最高效率 (Emax)**：
    * 当连续输入的任务 `n → ∞` 时，`Emax = 1` (或100%)。

### 5. 流水线的分类

流水线可以从多个维度进行分类：

1. **按使用级别**：
    * **部件功能级流水线**：将ALU中的复杂算术逻辑运算（如浮点加法）分解成多个子过程。
    * **处理机级流水线**：将一条指令解释过程分解成多个子过程（如取指、译码、执行）。这就是我们前面讨论的五段式流水线。
    * **处理机间级流水线 (宏流水)**：多个处理机共同完成一个大任务，每个处理机完成其中专门的一部分。

2. **按功能**：
    * **单功能流水线**：只能实现一种固定的专门功能。
    * **多功能流水线**：通过各段间的不同连接方式，可以同时或不同时地实现多种功能的流水线。

3. **按连接方式 (同一时间内各段之间的连接)**：
    * **静态流水线**：在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
    * **动态流水线**：在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这能提高流水线效率，但控制复杂。

4. **按是否有反馈信号**：
    * **线性流水线**：从输入到输出，每个功能段只允许经过一次，不存在反馈回路。
    * **非线性流水线**：存在反馈回路，某些功能段可能数次通过流水线，适合进行线性递归运算。

### 6. 流水线的多发技术 (高级流水线技术)

为了进一步提高性能，现代CPU采用了多种更高级的流水线技术，也称为**指令级并行 (Instruction-Level Parallelism, ILP)** 技术。

#### (1) 超标量技术 (Superscalar)

* **核心思想**：在一个时钟周期内，通过配置**多个功能部件**（如多个ALU、多个浮点单元），并发**发射多条独立的指令**。
* **特点**：
    * 多个指令流出段可以同时发射多条指令。
    * CPU内部有调度器动态判断指令之间的独立性。
    * 不能调整指令的执行顺序（在"按序发射，按序完成"模型下）。
* **优点**：显著提高指令吞吐量。
* **挑战**：需要复杂的硬件来检测指令相关性和调度指令。

#### (2) 超流水技术 (Superpipelining)

* **核心思想**：在**一个时钟周期内再分段**。将流水线的每个阶段进一步细分，从而提高时钟频率。

#### (3) 超长指令字 (Very Long Instruction Word, VLIW)

* **核心思想**：采用**多个处理部件**。编译器在编译时挖掘指令间的**潜在并行性**，将**多条能并行操作的指令组合成一条超长指令字**（可达几百位）。
* **特点**：
    * 指令字很长，包含多个操作码字段。
    * 硬件设计相对简单（因为并行性由编译器负责发现）。
    * 高度依赖**编译程序**的优化能力。
* **优点**：可以充分利用硬件资源实现并行。
* **挑战**：编译器设计非常复杂，代码移植性差（与特定VLIW架构绑定）。

---
