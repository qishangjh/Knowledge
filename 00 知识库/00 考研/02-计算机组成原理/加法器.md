---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 加法器
![[考研学习笔记02-计算机组成原理 加法器 今天08_57.png]]  

## 1. 一位全加器（FA, Full Adder）：二进制加法的"细胞"

一位全加器是实现两个二进制位及一个低位进位相加的逻辑电路。它是构建多位加法器的基本单元。

### (1) 输入与输出
![[考研学习笔记02-计算机组成原理 加法器 今天08_58.png]]

| 输入        | 输出                                |
| --------- | --------------------------------- |
| $A_i$     | $𝑆_i$ ：输入中有奇数个1时输出1 <br>$𝑆_i$ = |
| $B_i$     |                                   |
| $C_{i-1}$ | $𝐶_i$：输入中至少2个1时输出1               |
一位全加器有3个输入和2个输出：
* **输入**：
    * `Ai`：被加数的本位（当前位）
    * `Bi`：加数的本位（当前位）
    * `Ci-1`：来自低位的进位
* **输出**：
    * `Si`：本位和
    * `Ci`：向高位的进位

 `Si` 和 `Ci` 的逻辑表达式：
* `Si = Ai ⊕ Bi ⊕ Ci-1` (⊕ 表示异或)
    * 这个表达式说明，本位和 `Si` 为1，当且仅当 `Ai`, `Bi`, `Ci-1` 中有奇数个1。
* `Ci = AiBi + (Ai ⊕ Bi)Ci-1`
    * 这个表达式说明，向高位的进位 `Ci` 为1，当且仅当：
        * `Ai` 和 `Bi` 都为1 (即 `AiBi`)，或者
        * `Ai` 和 `Bi` 不相同 (即 `Ai ⊕ Bi`) 并且来自低位的进位 `Ci-1` 为1。

### (2) 门电路实现
![[考研学习笔记02-计算机组成原理 加法器 今天09_05.png]]

> [!NOTE] 简化图  
> 实际上，一个全加器通常被封装成一个单一的模块，外部只显示 `Ai, Bi, Ci-1` 输入和 `Si, Ci` 输出。

## 2. n位加法器：从一位到多位
### (1) 串行进位的并行加法器 (Ripple-Carry Adder)
将 `n` 个一位全加器（FA）巧妙地连接起来，就可以实现两个 `n` 位二进制数的相加。  
![[考研学习笔记02-计算机组成原理 加法器 今天09_10.png]]

* **封装**：将 `n` 个一位全加器串接起来，就可进行两个 `n` bit 数的相加。
* **连接方式**：前一个FA的进位输出 `Ci` 作为后一个FA的进位输入 `Ci-1`。
* **名称解析**：
    * **并行加法器**：由于两个输入端 (`A` 和 `B` 的 `n` 个位) 允许并行输入，即所有的 `Ai` 和 `Bi` 都是同时输入的。
    * **串行进位** (或称**行波进位**)：进位信息是**串行**产生的。每一级的进位 `Ci` 直接依赖于前一级的进位 `Ci-1`。进位信号就像波浪一样，逐级向前传递。
* **不足之处**：
    * **速度瓶颈**：运算速度取决于进位产生和传递的速度。**进位信息是串行产生的**，从 `C0` 到 `Cn-1` 需要经过 `n` 个进位门的延迟。
    * **延迟**：电信号到达稳态需要一定时间，因此每一级进位产生都会有延迟。
    * **位数越多，运算速度越慢**。对于长位数的加法，这种延迟会非常显著，成为运算速度的瓶颈。

### (2) 并行进位的并行加法器 (Carry-Lookahead Adder)
![[考研学习笔记02-计算机组成原理 加法器 今天09_08.png]]
* **目标**：克服串行进位加法器的速度限制。
* **特点**：
    * 所有进位信息 `C1, C2, …, Cn-1` 都是**同时产生**的，几乎没有逐级传递的延迟。
    * 通过使用更复杂的组合逻辑电路，提前（并行地）计算出各级的进位。
* **优势**：运算速度比"串行进位的并行加法器"快得多。
* **代价**：需要更多的硬件电路来实现进位逻辑，电路复杂度更高。

## 3. 带标志位的加法器：运算结果的"晴雨表"

除了计算和，加法器还会生成一些**标志位**，这些标志位存储在CPU的**标志寄存器 (FLAGS/PSW)** 中，用于反映运算结果的特性，为后续的条件跳转、溢出判断等提供依据。  
![[考研学习笔记02-计算机组成原理 加法器 今天09_19.png]]
* **OF (Overflow Flag)**：**溢出标志**，用于判断**带符号数**加减运算是否溢出。
    * **OF = 1** 表示溢出；**OF = 0** 表示未溢出。
    * **生成逻辑**：`OF = Cn ⊕ Cn-1`
        * 即：**最高位的进位** (`Cn`) **异或** **次高位的进位** (`Cn-1`)。
        * 当 `Cn` 和 `Cn-1` 不相同时，说明发生了有符号数溢出。
        * 例如：正数加正数，结果变成负数；负数加负数，结果变成正数。
* **SF (Sign Flag)**：**符号标志**，用于判断**带符号数**加减运算结果的正负性。
    * **SF = 1** 表示结果为负（结果的最高位是1）；**SF = 0** 表示结果为正（结果的最高位是0）。
    * **生成逻辑**：`SF = Sn`
        * 也就是取运算结果的**最高位（符号位）**。
* **ZF (Zero Flag)**：**零标志**，用于判断加减运算结果是否为 `0`。
    * **ZF = 1** 表示结果为 `0`；**ZF = 0** 表示结果不为 `0`。
    * **生成逻辑**：`ZF = (S_n=0) AND (S_n-1=0) AND … AND (S_0=0)`
        * 仅当运算结果所有 bit 全 `0` 时，`ZF` 才为 `1`。
* **CF (Carry Flag)**：**进位/借位标志**，主要用于判断**无符号数**加减运算是否溢出。
    * **CF = 1** 表示无符号数运算发生溢出（有进位/借位）；**CF = 0** 表示未溢出。
    * **生成逻辑**：`CF = Cn` (通常指最高位产生的进位 `Cn`)
        * 你提供的公式 `CF = Cout ⊕ Cin = Cn ⊕ C0` 描述了进位标志在某些特定场景下或针对某些特定判断的逻辑。在标准的加法运算中，`Cin` (即 `C0`) 通常被设置为 `0`。此时 `CF` 就简化为 `Cn` (从最高位产生的进位)，这反映了无符号数运算是否超出了其表示范围（即溢出）。

---
