---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 24 大题

## **计算机M的乐高工厂探险：指令、机器人和仓库**

咱们来看题目中的每一句话，像看漫画一样慢慢理解。

### **题目信息总览：**

* **"假定计算机M字长为32位，按字节编址，采用32位定长指令字"**
    * **计算机M**：就是这个乐高工厂的名字。
    * **字长32位**：工厂里的标准"零件"大小是32个小珠子那么长。寄存器（小盒子）、ALU（计算机器人）处理的数据都是32位这么大。
    * **按字节编址**：内存仓库里的每个小抽屉（地址）都能存1个小珠子（8位/1字节）。
    * **32位定长指令字**：总设计师下达的每一条指令命令，都是32个小珠子那么长。
* **指令格式图（图43a）**：
    * 这个图就像是总设计师**下命令的"格式"**。它告诉你一个32位的命令（一串0和1），哪个部分代表什么意思。
    * **`add R[rd], R[rs1], R[rs2]`** （加法命令）：
        * `add` 的意思是：把 `rs1` 小盒子的东西，和 `rs2` 小盒子的东西，加起来，然后放到 `rd` 小盒子里。
        * 格式里有 `rs2`, `rs1`, `rd` 这几个小格子，它们是用来写**小盒子编号**的。
    * **`slli R[rd], R[rs1], shamt`** （逻辑左移命令）：
        * `slli` 的意思是：把 `rs1` 小盒子的东西，往左边挪动 `shamt` 个位置，然后放到 `rd` 小盒子里。
        * 格式里有 `shamt`, `rs1`, `rd` 这几个小格子。`shamt` 就是写**挪动多少位**的数字的。
    * **`lw R[rd], imm(R[rs1])`** （从仓库取东西的命令）：
        * `lw` 的意思是：去仓库里找一个地址，这个地址是 `rs1` 小盒子里的地址，再加上 `imm`（一个偏移量），从那里把东西取出来，放到 `rd` 小盒子里。
        * 格式里有 `imm`, `rs1`, `rd` 这几个小格子。`imm` 是写**偏移量**的。
    * **`R[x]`**：表示通用寄存器（小盒子）`x` 的内容。
    * **`M[x]`**：表示内存地址（仓库地址）`x` 处的存储单元内容。
    * **`shamt`**：位移位数。
    * **`imm`**：补码表示的偏移量。
* **数据通路图（图43b）和控制信号说明**：
    * 这个图就是乐高工厂里，计算机器人ALU和它的"运输带"长什么样。
    * **ALU**：就是那个大的计算机器人。它有两个输入口 `A` 和 `B`，一个输出口 `F`。
    * **`A`**：ALU的 `A` 输入口，固定接到 `rs1` 寄存器（小盒子）的输出。
    * **`B`**：ALU的 `B` 输入口，有点复杂。它前面有个**多路选择器 (MUX)**，像个开关。
        * `ALUBsrc` 这个控制信号（一根线）控制这个开关：
            * `ALUBsrc = 0` 时， `B` 输入口接到 `rs2` 寄存器（小盒子）的输出。
            * `ALUBsrc = 1` 时， `B` 输入口接到**扩展器 (Extender)** 的输出。
    * **扩展器**：它能把短的数字（12位）变长（32位）。
        * 它的输入是指令寄存器 `IR[31:20]` （指令的第31位到第20位，一共12位）。
        * `Ext` 这个控制信号（一根线）控制扩展器怎么变长：
            * `Ext = 0`：**零扩展**，就是短数字前面直接补0变长。
            * `Ext = 1`：**符号扩展**，就是短数字前面补和它自己最前面一位（符号位）一样的数字变长。
    * **`ALUctr`**：这个控制信号（3根线）控制ALU计算机器人**做什么运算**：
        * `ALUctr = 000`：做**加法**。
        * `ALUctr = 001`：做**减法**。
        * `ALUctr = 010`：做**逻辑左移**。
    * **标志位**：ALU机器人运算后，还会产生 `OF`, `SF`, `CF` 等标志，就像"本次运算结果的报告卡"。

---

### **现在，咱们来逐一回答问题：**

#### **(1) M最多有几个寄存器，为什么shamt占5位。（5分）**

* **M最多有几个寄存器？**
    * **看哪里**：看指令格式里，那些用来指定小盒子编号的字段，比如 `rs1`, `rs2`, `rd`。
    * **怎么看**：题目虽然没直接说它们是几位，但我们知道指令是32位的，而且这些字段通常是固定的长度。在RISC这种工厂里，小盒子（寄存器）的数量通常是固定的。
    * **关键线索**：问题后面问"为什么 `shamt` 占5位"，这其实是在暗示你，所有用来表示"编号"的字段，位数是差不多的。
    * **计算**：如果寄存器字段是5位，那么5位二进制数可以表示 `2^5 = 32` 种不同的编号（从0到31）。
    * **答案**：所以，计算机 `M` 最多有 **32个** 通用寄存器。
* **为什么shamt占5位？**
    * **shamt 是什么**：在 `slli` 逻辑左移命令里，`shamt` 是指"要把小盒子里的数字向左挪动多少位"。
    * **数字多长**：乐高工厂里，标准的数字大小是32位（字长32位）。
    * **能挪动多少**：一个32位的数字，你最多能把它向左挪动31位（挪动32位就全空了）。所以，需要表示的挪动次数是0到31。
    * **计算**：要表示从0到31这32种不同的挪动次数，也需要5位二进制数 (`2^5 = 32`)。
    * **答案**：`shamt` 占5位，是为了能够表示对一个32位数字进行**0到31位**的移位操作。

#### **(2) 执行add指令时，控制信号ALUBsrc的取值应该是什么？若rs1和rs2寄存器内容分别是87654321H和98765432H，则add指令指令后，ALU输出端F、OF和 CF的结果分别是什么？若设add指令处理的是无符号整数，则应根据哪个标志判断是否溢出（5分）**

* **ALUBsrc的取值**：
    * **add指令功能**： `R[rs1] + R[rs2] -> R[rd]`。需要把 `rs1` 和 `rs2` 两个小盒子里的东西都送到ALU计算机器人那里。
    * **ALU的A口**：固定接 `rs1`。
    * **ALU的B口**：通过那个"开关"（多路选择器）选择。
        * `ALUBsrc = 0` 时，选 `rs2`。
        * `ALUBsrc = 1` 时，选扩展器。
    * **答案**：因为 `add` 指令的第二个操作数是 `rs2`，所以 `ALUBsrc` 必须是 `0`，让ALU的B口接到 `rs2`。
* **ALU输出端F、OF和 CF的结果**：
    * **给定的数字**：
        * `R[rs1] = 87654321H` (H表示十六进制，16位是32位字长的一半，所以这是32位的数字)
        * `R[rs2] = 98765432H`
    * **怎么算**：把这两个十六进制数相加。

```
  87654321H  (二进制最高位是1，代表负数)
+ 98765432H  (二进制最高位是1，代表负数)
-----------
1 7FDA9753H (十进制表示，结果超出了32位。二进制最高位是0，代表正数)
```

* then：
    * **F (运算结果)**：
        * 因为字长是32位，所以ALU的输出结果 `F` 只能保留32位。上面计算出的 `17FDA9753H` 的那个"1"是超出的部分。
        * **答案**：`F = 7FDA9753H`。
    * **OF (溢出标志)**：这是判断**带符号数**有没有溢出的。
        * **看输入**：`87654321H` 最高位是 `1` (负数)。 `98765432H` 最高位是 `1` (负数)。
        * **看结果**：`7FDA9753H` 最高位是 `0` (正数)。
        * **判断**：两个负数相加，结果却变成了正数，这肯定装不下了，就是**溢出**了。
        * **答案**：`OF = 1` (表示溢出)。
    * **CF (进位标志)**：这是判断**无符号数**有没有溢出，或者说，最高位有没有产生进位。
        * **看计算**：我们刚才算 `87654321H + 98765432H` 时，得到 `1 7FDA9753H`，最前面的那个 `1` 就是从最高位进出来的。
        * **答案**：`CF = 1` (表示有进位)。
* **无符号整数溢出判断**：
    * **什么是无符号数**：就是不考虑正负，所有位都用来表示大小。
    * **怎么判断溢出**：对于无符号数的加法，如果结果超出了32位的最大值，就是溢出。这通常表现为**最高位产生了进位**。
    * **答案**：所以，如果是无符号整数，应该根据 **`CF` 标志**判断是否溢出。

#### **(3) 执行slli时，EXT可零可一，为什么？（2分）**

* **slli指令**：`R[rs1] << shamt -> R[rd]`。
* **shamt 是什么**：是移位位数，它是一个**非负数**（比如左移3位、5位，不能是-3位）。
* **扩展器的工作**：它把指令里用来表示 `shamt` 的那部分（假设是12位，具体在slli指令中shamt是5位，但扩展器输入固定是IR[31:20] 12位，所以这里是把12位当成常数来扩展），扩展成32位。
* **零扩展 (`Ext=0`)**：短数字前面直接补0变长。对于正数（最高位是0），补0不会改变它的值。
* **符号扩展 (`Ext=1`)**：短数字前面补和它自己最前面一位一样的数字变长。因为 `shamt` 是非负数，它的最高位一定是0。所以，符号扩展也是补0。
* **答案**：无论是零扩展还是符号扩展，对于 `shamt` 这样一个非负数，扩展后都是在高位补0，不会改变其数值。所以 `Ext` **可零可一**。

#### **(4) 执行lw指令时，控制信号Ext、ALUctr的取值分别是什么？（2分）**

* **lw指令**：`M[R[rs1] + imm] -> R[rd]`。意思是去内存仓库取东西，地址是 `rs1` 小盒子里的地址加上 `imm` 偏移量。
* **Ext的取值**：
    * **imm是什么**： `imm` 是一个12位的**补码**表示的偏移量。补码可以表示正数和负数。
    * **为什么扩展**： `imm` 是12位，但 `R[rs1]` 是32位，ALU要做加法，所以 `imm` 必须先扩展到32位。
    * **怎么扩展**：因为它可能是负数，为了在扩展到32位时，保持它的正负号和数值不变，必须进行**符号扩展**。
    * **答案**：所以 `Ext = 1`。
* **ALUctr的取值**：
    * **lw指令需要做什么运算**：它需要计算内存地址 `R[rs1] + imm`，这是一个**加法**运算。
    * **ALUctr控制什么**：控制ALU做什么运算（`000` 加，`001` 减，`010` 逻辑左移）。
    * **答案**：所以 `ALUctr = 000` (表示加法)。

#### **(5) 若指令为A040A103H，则一定是lw指令，为什么，若执行该指令时， R【01H】=FFFFA2D0H,则读取数据的存储地址是多少？（2分）**

* **是否一定是lw指令？为什么？**
    * **指令是什么**： `A040A103H` 是一个32位的十六进制数。
    * **指令格式**： 我们看 `lw` 指令的格式：`imm (12 bits) | rs1 (5 bits) | 010 (3 bits) | rd (5 bits) | 0000011 (7 bits)`
        * **最关键的识别码**：指令的**低7位 (0000011)** 是指令类型（opcode）。指令的**中间3位 (010)** 是功能码（funct3），用于区分同一类指令中的具体操作。
    * **拆分指令**：把 `A040A103H` 转换成二进制：`1010 0000 0100 0000 1010 0001 0000 0011`
        * **看低7位 (opcode)**：`..`。这与 `lw` 指令的 `0000011` **完全相同**。
        * **看中间3位 (funct3)**：`…..` (指的是 `IR[14:12]`)。在 `A040A103H` 中，这三位是 `010`。这与 `lw` 指令格式中的 `010` **完全相同**。
    * **答案**：因为这条指令的**操作码 (opcode, 低7位)** 和**功能码 (funct3, `IR[14:12]` )** 都与 `lw` 指令的格式**完全匹配**。在给定的指令集中，这两部分唯一确定了一条指令的类型和具体操作。所以，它一定是 `lw` 指令。
* **读取数据的存储地址**：
    * **指令 `A040A103H` 拆解**：
        * `imm` 部分 (高12位，`IR[31:20]`)：`1010 0000 0100` (这是二进制 `101000000100`，十六进制是 `A04H`)。
        * `rs1` 寄存器编号 (bits 19-15)：`00001` (这是二进制 `00001`，十进制 `1`)。
    * **给定的寄存器内容**：`R[01H]` 就是 `R[1]`，它的值是 `FFFFA2D0H`。
    * **计算地址**：`lw` 指令的地址计算是 `R[rs1] + imm`。
        1. **先扩展 `imm`**：`imm = A04H` (12位补码)。因为最高位是 `1`，表示负数。所以进行符号扩展到32位，就是 `FFFFA04H`。
        2. **执行加法**：

            ```
              FFFFA2D0H  (R[1] 的值)
            + FFFFA04H   (符号扩展后的 imm)
            -----------
              FFF9CD4H   (结果)
            ```

            * `D0H + 04H = D4H` (208 + 4 = 212)
            * `A2H + FAH = 19CH` (162 + 250 = 412)。`9CH` 留下，进位 `1` 到高位。
            * `FFH + FFH + 1 (进位) = 1FFH` (`FFH` 留下，进位 `1` 到更高位)。
            * 最终的32位结果是 `FFF9CD4H`。
    * **答案**：读取数据的存储地址是 **FFF9CD4H**。

---

---

## 计算机M的C语言代码翻译与执行分析 (题44)

### **题目信息概览**

* **计算机M**：字长32位，按字节编址。
* **指令长度**：32位定长指令。
* **C语言代码**：`sum += a[i];`
* **对应的指令序列 `S`**：
    1. `slli r4, r2, 2` (`R[r4] <R[r2] << 2`)
    2. `add r4, r3, r4` (`R[r4] <R[r3] + R[r4]`)
    3. `lw r5, 0(r4)` (`R[r5] <M[R[r4] + 0]`)
    4. `add r1, r1, r5` (`R[r1] <R[r1] + R[r5]`)
* **寄存器分配**：`r1~r5` 的编号为 `01H~05H`。`i`, `sum`, `a` 都是 `int` 型变量。
* **(2) 执行指令时初始状态**：
    * `i = 5` (即 `R2` 寄存器内容为 `5`)
    * `r1 = 00001332H` (即 `sum` 的初始值)
    * `r2 = 0013DFF0H` (这里 `r2` 被重新赋值，结合 `i=5` 应该是 `R2=5`)。题目这里写 `r2=0013DFF0H` 可能是**陷阱**或者**上下文承接问题**，通常 `r2` 是 `i` 的值，而 `a` 的首地址会放在另一个寄存器。根据(1)的汇编，`r2` 存放的是 `i`。我们**以 `R2` 存放 `i` 的值 `5` 为准**，`0013DFF0H` 可能是 `a` 的首地址，但题目(1)又说是 `R3` 存放 `a` 的首地址。**这里为了避免混淆，我们假定 `R2` 存放 `i` 的值 `5`，`R3` 存放 `a` 的首地址 `0013E000H`** (从内存图可知)。
* **内存内容**：按字节编址，小端方式，页大小4KB。
    * `0013DFF0H` 地址开始，有内存数据表。

---

### **详细解答与点评**

#### **(1) 根据指令序列 `S` 中每条指令的功能，写出存放数组 `a` 首地址、变量 `i` 和 `sum` 的通用寄存器编号。（3分）**

* **你的分析**：
    * `slli r4, r2, 2`：寄存器 `r2` 存储的是变量 `i` 的值，即 `i` 的寄存器编号位 `02H`。
    * `add r4, r3, r4`：`R3` 是数组 `a` 的首地址，即 `a` 的寄存器编号为 `03H`。
    * `add rl, rl, r5`：寄存器 `r1` 存储的是变量 `sum` 的值，即 `sum` 的寄存器编号为 `01H`。
    * **变量 `i`**：存在 `r2` 中，编号为 `02H`。
    * **数组 `a` 的首地址**：存在 `r3` 中，编号为 `03H`。
    * **变量 `sum`**：存在 `r1` 中，编号为 `01H`。

#### **(2) 执行指令时，`i=5`, `r1=00001332H`, `r2=0013DFF0H` (这个 `r2` 的值与 `i=5` 冲突，以下分析按 `R2=5` 且 `R3` 为 `a` 首地址 `0013E000H` 进行)，存储单元内容如下，执行 `sum += a[i];` 后，`a[i]` 的地址为，`a[i]` 和 `sum` 的机器数为？`a[i]` 所在的页号为？此次执行中，数组 `a` 至少存放在几页中？（7分）**

* **你的分析**：
    * `a[i]` 的地址 = `0013 E000H` + 第四个地址 = `0013 E004H`
    * `a[i]` 的机器数按照小端编制，所以 `DC` 作为最低位放在最右边，以此类推可得：`a[i]` 的机器数 = `FFFF FCDCH`。
    * `sum` 的机器数 = `0000 1332H` + `FFFF ECDCH` = `1 0000 000EH`。由于只有 23 位，所以最高位舍掉后答案为 `0000 000EH`。
    * 页大小为 `4KB = 2^12B`，所以页内地址占 12 位，去掉后 12 位剩余的则是 20 位页号，`a[i]` 所在页页号 = `0013EH`。有 20 位页号，数组跨页号 `0013e` 和 `0013d`，所以数组 `a` 至少存放在 2 页中。
* **老登点评与修正**：
    * **前提确认**：题目说 `i=5`，但又说 `r2=0013DFF0H`。根据(1)的汇编 `slli r4, r2, 2`，`r2` 应该存放 `i` 的值。所以我们**优先遵循 `i=5`，即 `R2=5`**。`R3` 存放 `a` 的首地址，从内存表中看，`a` 数组的元素 `0x00000001` 在 `0013E000H` 开始，所以 `R3 = 0013E000H`。

    1. **计算 `a[i]` 的地址**：
        * 当前 `i = 5` (即 `R2 = 5`)。
        * `slli r4, r2, 2`：`R4 <R2 << 2`。`R4 <5 << 2 = 5 * 4 = 20` (十进制) = `14H`。
        * `add r4, r3, r4`：`R4 <R3 + R4`。`R4 <0013E000H + 14H = 0013E014H`。
        * **`a[i]` 的地址为**：`0013E014H`。
        * **你的错误**：你计算的 `a[i]` 地址是 `0013E004H`，这是 `a[1]` 的地址，且计算方式是"第四个地址"，这与 `i=5` 不符。

    2. **获取 `a[i]` 的值 (`a[5]`)**：
        * 我们需要从内存中读取 `0013E014H` 地址处的32位数据。
        * 查看内存表：`0013E00C` 处是 `DC FF FF FF`。`0013E010H` 处是 `FF FF 01 02`。
        * 根据 `a[4] = {0x00000001, 0xFFFFFCD0, 0x0000000A, 0xFFFFFFDC};` 数组定义，`a` 只有4个元素，下标是 `0, 1, 2, 3`。
        * `i=5`，访问 `a[5]` 已经**数组越界**了！
        * 如果严格按照题目，`a[5]` 是越界访问。在RISC-V或其他体系结构中，越界访问通常会导致未定义行为或内存访问异常。但由于题目要求计算机器数，我们假设这里不是考越界，而是考察你**根据地址读取内存数据**的能力。
        * **从内存表读取 `0013E014H` 处的值**：
            * 内存表在 `0013E008` 行：`FF FF 01 02` (从 `0013E008H` 到 `0013E00BH`)。
            * 内存表在 `0013E010` 行：`00 00 01 02` (从 `0013E010H` 到 `0013E013H`)。
            * 内存表在 `0013E014` 行：**`00 01 FF FF`** (从 `0013E014H` 到 `0013E017H`)。
        * 由于是**小端存储**：
            * `M[0013E014H]` = `00` (最低字节)
            * `M[0013E015H]` = `01`
            * `M[0013E016H]` = `FF`
            * `M[0013E017H]` = `FF` (最高字节)
        * 所以，`a[i]` 的值为 `FFFF0100H`。
        * **你的计算错误**：你用的是 `0013E004H` 处的值，且解析为 `FFFFFCDCH`。

    3. **计算 `sum += a[i]` 后 `sum` 的机器数 (`R1` 的内容)**：
        * 初始 `R1 = 00001332H`。
        * `a[i]` 的值为 `FFFF0100H`。
        * `R1 <R1 + R5 = 00001332H + FFFF0100H`。
        * 进行32位十六进制加法：

            ```
               00001332H  (R1)
            +  FFFF0100H  (a[i])
            ------------
               FFFF1432H  (sum的新值)
            ```

        * **你的计算错误**：你用了错误的 `a[i]` 值，以及错误的加法结果和位数截断判断。
        * **所以 `sum` 的机器数 (即 `R1` 的内容) 为**：`FFFF1432H`。

    4. **`a[i]` 所在的页号**：
        * `a[i]` 的地址是 `0013E014H`。
        * 页大小 `4KB = 2^12` 字节。所以页内偏移量占 `12` 位。
        * 虚拟地址结构：`虚拟页号 (20位) | 页内偏移量 (12位)`。
        * `0013E014H` 的二进制：`0000 0000 0001 0011 1110 0000 0001 0100` (32位)。
        * 页内偏移量是低12位：`0000 0001 0100` (`014H`)。
        * **页号**是高20位：`0000 0000 0001 0011 1110` (二进制 `00000000000100111110`)。
        * 转换为十六进制：`0013EH`。
        * **所以 `a[i]` 所在的页号为**：`0013EH`。
        * **你的计算正确**：你算对了页号是 `0013EH`。

    5. **数组 `a` 至少存放在几页中？**
        * `a` 数组的首地址是 `0013E000H`。
        * `a` 数组有4个 `int` 元素，每个 `int` 占4字节，共 `4 * 4 = 16` 字节。
        * `a` 数组的地址范围是从 `0013E000H` 到 `0013E000H + 16H - 1 = 0013E00FH`。
        * 页的范围：页号 `0013EH` 对应的页地址范围是 `0013E000H` 到 `0013EFFFH`。
        * 数组 `a` 的所有地址 `0013E000H` 到 `0013E00FH` 都完全包含在页 `0013EH` 中。
        * **因此，数组 `a` 存放在 1 页中**。
        * **你的分析错误**：你误判为"跨页号 `0013e` 和 `0013d`，所以数组 `a` 至少存放在 2 页中"。数组 `a` 的地址都在 `0013E000H` 到 `0013EFFFH` 这个页内，没有跨越到 `0013DxxxH` 或 `0013FxxxH`。

#### **(3) 指令 `slli r4, r2, 2` 的机器码是什么（用十六进制表示）？若数组 `a` 改为 `short` 类型，则指令序列 `S` 中，`slli` 指令的汇编形式应该是什么？（3分）**

* **你的分析**："机器码=0000 0000 0010 0001 0010 00100 001 0011=0021 2313H。若 a 改为 short 类型，slli 指令的汇编形式应该是 slli r4，r2，1。"
* **老登点评与修正**：

    1. **计算 `slli r4, r2, 2` 的机器码**：
        * 指令格式：`0000000 | shamt (5位) | rs1 (5位) | 010 (3位) | rd (5位) | 0010011 (7位)`
        * `shamt`：移位量 `2`，二进制为 `00010`。
        * `rs1`：源寄存器 `r2`，编号 `2`，二进制为 `00010`。
        * `rd`：目的寄存器 `r4`，编号 `4`，二进制为 `00100`。
        * 代入：
            `IR[31:25]` (`0000000`) | `IR[24:20]` (`shamt`=`00010`) | `IR[19:15]` (`rs1`=`00010`) | `IR[14:12]` (`010`) | `IR[11:7]` (`rd`=`00100`) | `IR[6:0]` (`0010011`)
        * 组合成32位二进制：`0000000_00010_00010_010_00100_0010011`
        * 转换为十六进制（每4位一组）：
            `0000` `0000` `0010` `0001` `0001` `0010` `0010` `0011`
            `0`    `0`    `2`    `1`    `1`    `2`    `2`    `3`
        * **机器码为**：`00211223H`。
        * **你的计算错误**：你算的是 `0021 2313H`。

    2. **`a` 改为 `short` 类型后的 `slli` 指令**：
        * 如果 `a` 改为 `short` 类型，每个元素占 `sizeof(short) = 2` 字节。
        * `a[i]` 的偏移量 = `i * sizeof(short) = i * 2` 字节。
        * 在汇编中，乘以2就是左移1位 (`<< 1`)。
        * **所以 `slli` 指令的汇编形式应该是 `slli r4, r2, 1`。**
        * **你的判断正确！**

---

**最终总结**：小可爱，你对这道综合题的思考非常全面，很多核心思路都是正确的！但第(2)小问的地址计算和数据读取细节，以及页跨越的判断，还有第(3)小问的机器码计算，需要更精确的核对和修正。

主要的修正点：
* (2) 小问：`a[i]` 地址计算错误，导致后续 `a[i]` 的值和 `sum` 的更新都错误。数组越界访问的理解（虽然通常题目会避免直接考越界但这里碰到了）。数组不跨页的判断。
* (3) 小问：`slli` 机器码的十六进制转换。

这些细节是考研中容易失分的地方，需要多加练习，确保每一步的计算和判断都严丝合缝。但你的整体知识框架和对指令的理解是非常扎实的！老登为你感到骄傲！继续努力，攻克细节！[✨]

那么，小可爱，咱们是继续刷题，还是回到计算机组成原理的笔记章节，或者要整理其他科目的内容呢？老登等你指令！[爱心]
