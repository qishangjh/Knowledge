---
科目: "408"
课程名称: 计算机组成原理
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

## 02-数据表示和运算

> [!abstract]
> - (一)数制与编码
>    1. 进位计数制及其数据之间的相互转换
> - (二)整数的表示与运算 #近年修改 #必考
>        1. [[#1. 定点数的编码表示|定点数的编码表示]] (原码、反码、补码) #2015年 #2021年 #2022年 #2023年
>        2. [[#2. C语言中的整数类型及其类型转换|C语言中的整数类型及其类型转换]] #2012年 #2016年 #2019年 #2024年 #2025年
>        3. [[#3. 定点数的位移运算|定点数的位移运算]] #2013年 #2018年
>        4. [[#4. 定点数的加减运算|定点数的加减运算]] #2009年 #2014年 #2018年 #2023年 #2025年
>        5. [[#5. 定点数的乘除运算|定点数的乘除运算]] #2010年 #2024年
>        6. [[#6. 基本运算部件与标志位（ALU）|基本运算部件与标志位（ALU）]] #2018年 #2023年 #2025年
> - (三)浮点数的表示与运算 #必考
>        7. [[#1. 浮点数的表示 (IEEE 754 标准)|浮点数的表示 (IEEE 754 标准)]] #2011年 #2012年 #2013年 #2014年 #2018年 #2020年 #2021年 #2022年 #2023年 #2024年 #2025年
>        8. [[#2. 浮点数的加减运算|浮点数的加减运算]] #2009年 #2015年
>        9. [[#3. C语言中的浮点数类型|C语言中的浮点数类型]] #2010年 #2024年
> - (四)数据的大小端和对齐存储 #必考
>        10. [[#1. 数据的大小端和对齐存储|数据的大小端和对齐存储]] #2012年 #2016年 #2018年 #2020年 #2025年

---
### 02-1 数制与编码
#### 1. 进位计数制及其相互转换
-   **十进制 (Decimal, D)**：逢 `10` 进 `1`，基数是 `10` (数字 `0-9`)。
-   **二进制 (Binary, B)**：逢 `2` 进 `1`，基数是 `2` (数字只有 `0` 和 `1`)。
    -   通常会写成 `0b` 开头。
-   **八进制 (Octal, O)**：逢 `8` 进 `1`，基数是 `8` (数字 `0-7`)。
    -   通常会写成 `0` 开头。
-   **十六进制 (Hexadecimal, H)**：逢 `16` 进 `1`，基数是 `16` (数字 `0-9` 和字母 `A-F`，其中 `A-F` 分别代表十进制的 `10-15`)。
    -   通常会写成 `0x` 开头，或后面加个 `H`。

> [!tip] **各种进制之间的转换技巧**
> -   **任意进制转十进制：按权展开法** (每个数字乘以其位权再加起来)。
> -   **十进制转任意进制：**
>     -   **整数部分：除基取余法** (除到商为0，余数反向排列)。
>     -   **小数部分：乘基取整法** (乘到小数部分为0或达到精度要求，整数正向排列)。
> -   **二进制与八/十六进制互转：分组法**
>     -   **二进制 <=> 八进制**：从小数点（或右侧）开始，每 **3 位**二进制对应 **1 位**八进制数。不够3位的前面补0。
>     -   **二进制 <=> 十六进制**：从小数点（或右侧）开始，每 **4 位**二进制对应 **1 位**十六进制数。不够4位的前面补0。
>     -   **机器数表示**：数据在计算机内存中的二进制存储形式，无符号数的机器数即为其二进制表示。
>     -   **十六进制转换技巧**：利用 `2ⁿ` 边界值快速计算十六进制。
>     -   **格式表示**：按字节边界分组显示十六进制结果（如32位数据用8位十六进制表示，空格分隔）。

---

### **02-2 整数的表示与运算**

#### 1. 定点数的编码表示

-   **定点数**：小数点位置固定，主要关注定点整数。
-   **原码 (True Form)**：
    -   **概念定义**：最高位为符号位 (`0`正，`1`负)，其余位为数值绝对值。
    -   **缺点**：`+0` (`0000 0000`) 和 `-0` (`1000 0000`) 有两种表示；加减运算复杂，需要先判断符号。
-   **反码 (Ones' Complement)**：
    -   **概念定义**：
        -   **正数**：同原码。
        -   **负数**：符号位不变，其余数值位按位取反。
    -   **缺点**：`+0` (`0000 0000`) 和 `-0` (`1111 1111`) 仍有两种表示。
-   **补码 (Twos' Complement)**：**计算机内部最常用**。
    -   **概念定义**：有符号整数的标准二进制表示方法，最高位为符号位 (`0`正，`1`负)。 #2015年 #2021年 #2022年 #2023年
        -   **正数**：补码和原码、反码**完全相同**。
        -   **负数**：在反码基础上末位加 `1`。
        -   **负数补码求法（直接）**：绝对值原码 -> 所有位取反（含符号位） -> 末位加 1。
    -   **优点**：`0` 表示唯一 (`0000 0000`)；减法统一为加法 `[A - B]补 = [A]补 + [-B]补`；表示范围不对称（比原码和反码多表示一个最小负数）。
    -   **补码转换技巧**：
        -   **正数机器数**：直接转换为十进制。
        -   **负数机器数**：按位取反加 `1` 求原码，再添加负号。
        -   **负数求补**：对正数补码按位取反加 `1`。

> [!tip] **`~` 按位取反操作的奥秘！**
> -   `~` 操作的是**补码**。
> -   **运算结果：`~X` 在数值上等于 `-(X+1)`**。

> [!bug] **重要！`n` 位补码的表示范围** #2022年
> -   **概念定义**：补码能够编码的整数数值区间。
> -   **关键特性**：负数范围比正数范围多 1 个数值（即负数表示范围比正数范围多 1 个数值）。
> -   **位宽分配**：`n` 位补码中，`1` 位为符号位，`(n-1)` 位为数值位。
> -   **范围**：`[-2^(n-1), 2^(n-1)-1]`。
> -   **最大正数**：符号位 `0`，数值位全 `1` (`011..` )，值为 `2^(n-1)-1`。
> -   **最小负数**：符号位 `1`，数值位全 `0` (`100..` )，值为 `-2^(n-1)`。

**补码范围推导公式**

| 位宽 | 符号位 | 数值位 | 表示范围             |
| :--- | :----- | :----- | :------------------- |
| `n` 位 | 1 位   | `(n-1)`位 | `[-2^(n-1), 2^(n-1)-1]` |
| 8 位 | 1 位   | 7 位   | `[-128, 127]`        |
| 16 位 | 1 位   | 15 位  | `[-32768, 32767]`    |
| 32 位 | 1 位   | 31 位  | `[-2³¹, 2³¹-1]`      |

**特殊补码值**

| 数值类型 | 计算方法             | 示例 (32 位)         |
| :--- | :--------------- | :---------------- |
| 最大正数 | 符号位 `0`，数值位全 `1` | `0111..₂ = 2³¹-1` |
| 最小负数 | 符号位 `1`，数值位全 `0` | `1000..₂ = -2³¹`  |
| `-1` | 所有位均为 `1`        | `1111..₂ = -1`    |

**补码最小值构造策略 (由特定数量的1和0组成)** #2015年
-   **目标**：在固定位宽和固定数量 `1` 和 `0` 的约束下，构造最小负数。

| 策略原理   | 位置分配                 | 数学依据                      |
| :--------- | :----------------------- | :---------------------------- |
| 符号位固定 | 最高位设为 `1`（负数）     | 确保结果为负数                |
| 低位集中   | 将数值位中的 `1` 放在最低位 | 补码负数越接近 `-1` 数值越小  |
| 高位清零   | 数值位高位尽量为 `0`       | 减小补码对应的绝对值（补码值） |

**带符号补码整数比较规则** #2021年
-   **概念定义**：有符号整数间的大小关系判断方法。
-   **关键特性**：同号数按无符号规则比较，异号数符号位决定。

| 比较场景 | 判断方法                         | 逻辑依据           |
| :------- | :------------------------------- | :----------------- |
| 同为正数 | 按无符号数规则比较大小           | 补码=原码，直接比较 |
| 同为负数 | 机器数（补码值）越大，真值（实际负数）越小 | 负数补码的数值规律 |
| 正负混合 | 负数恒小于正数                   | 符号位优先级最高   |

#### **2. C语言中的整数类型及其类型转换**

-   **整数类型**：
    ![[考研学习笔记02-计算机组成原理 02-数据表示和运算 2025-10-10 31.png]]
    -   `char` (通常 8位), `short` (通常 16位), `int` (通常 32位), `long`, `long long`。
-   **有符号 (signed) 和无符号 (unsigned)**：
    -   `signed`：默认，表示有正负。最高位是符号位。
    -   `unsigned`：无符号类型，只表示非负数 (0和正数)。所有位都用来表示数值，没有符号位。
-   **类型转换**： #2016年 #2019年 #2024年 #2025年
    -   **概念定义**：不同位宽或符号性整数间数值传递过程。
    -   **关键特性**：位模式不变，仅改变数值解释方式。
    -   **隐式转换 (Automatic Conversion)**：
        -   **短整数变长 (整型提升)**： #2012年 #2024年 #2025年
            -   **无符号数**：**零扩展** (高位统一填充 `0`)。
            -   **有符号数**：**符号扩展** (高位填充符号位)。
        -   **长整数变短 (截断)**： #2024年
            -   **概念定义**：高位宽向低位宽转换时，截取低位部分。
            -   **关键特性**：保留低位，丢弃高位，可能改变数值含义。
        -   **有符号与无符号混合运算**：通常将有符号数转换为无符号数再运算，可能导致意想不到的结果。
    -   **显式转换 (Explicit Conversion / Cast)**：强制类型转换，可能导致数据丢失或改变意义。

**数据类型特性对比**

| 类型          | 位宽 | 表示范围            | 最大值二进制             |
| :------------ | :--- | :------------------ | :----------------------- |
| `unsigned short` | 16 位 | `0 ~ 65535`         | `1111111111111111₂`      |
| `short`       | 16 位 | `-32768 ~ 32767`    | `0111111111111111₂`      |
| `int`         | 32 位 | `-2³¹ ~ 2³¹-1`      | `0111..₂`           |
| `unsigned int` | 32 位 | `0 ~ 2³²-1`         | `1111..₂`           |

> [!warning] **C语言整数的"溢出"问题**
> -   **有符号整数溢出**：C 语言标准中是**未定义行为**！
> -   **无符号整数溢出**：进行**模运算**。 #2016年 #2019年
>    -   **模运算**：负数转无符号数的数学等效计算 `负值 + 2^n`。
>    -   **等长有符号转无符号公式**：`result = source + 2^n` (当 `source < 0` 时)。 #2016年
>    -   **无符号转有符号（溢出）公式**：`result = source - 2^n` (当 `source > 目标类型最大正值` 时)。 #2019年
>    -   **边界值处理**：源值 = `2^n-1` 对应有符号数的 `-1`。 #2019年
>    -   **特殊转换**：负数的 short 类型转换为 unsigned int 时，按照模 `2³²` 运算，结果为 `2³² + 原值`。 #2025年

#### **3. 定点数的位移运算**

-   **位移**：将数字的二进制位整体往左或往右移动，是一种高效的运算。
-   **左移 (Left Shift)**：`X << N`
    -   **操作**：所有位整体向左移动 `N` 位。
    -   **补位**：右边（低位）空位补 `0`。
    -   **移出位**：左边（高位）移出的位被丢弃。
    -   **效果**：对于无符号数和补码表示的正数，相当于乘以 `2^N`。
    -   **注意**：可能发生溢出！
-   **逻辑右移 (Logical Right Shift)**： #2018年
    -   **概念定义**：纯二进制位移操作，忽略符号位。
    -   **操作**：所有位整体向右移动 `N` 位。
    -   **补位**：左边（高位）空位补 `0`。
    -   **移出位**：右边（低位）移出的位被丢弃。
    -   **效果**：对于无符号数，相当于除以 `2^N` (向下取整)。
-   **算术右移 (Arithmetic Right Shift)**： #2018年
    -   **概念定义**：保持数值符号的位移。
    -   **操作**：所有位整体向右移动 `N` 位。
    -   **补位**：左边（高位）空位**补原数的符号位** (`0`或`1`)。
    -   **移出位**：右边（低位）移出的位被丢弃。
    -   **效果**：对于有符号数，相当于除以 `2^N` (向下取整)，并保持符号不变。
-   **循环移位 (Circular Shift)**：移出的位会从另一端补回来，形成一个环（C语言无直接运算符）。

**移位操作规则对比** #2013年 #2018年

| 移位类型 | 操作方向 | 补位规则         | 等价运算             |
| :------- | :------- | :--------------- | :------------------- |
| 逻辑左移 | 向左移位 | 右端补 `0`         | 乘以 `2^n` (无符号)   |
| 算术左移 | 向左移位 | 右端补 `0`         | 乘以 `2^n` (有符号)   |
| 逻辑右移 | 向右移位 | 左端补 `0`         | 除以 `2^n` (无符号)   |
| 算术右移 | 向右移位 | 左端补符号位     | 除以 `2^n` (有符号)   |
-   **关键技巧**：算术移位保持符号位语义，右移时符号位向右扩展（负数右移左端补1）。
-   **运算优化**：乘除 `2` 的幂次可以直接用移位实现，效率更高。

#### **4. 定点数的加减运算**

-   **核心原理**：**统一用补码进行加法运算！** #2009年 #2018年 #2023年
    -   `[X + Y]补 = [X]补 + [Y]补`
    -   `[X - Y]补 = [X]补 + [-Y]补` (减去一个数，等价于加上这个数的负数的补码！)
-   **如何求 `[-Y]补`？** #2018年 #2025年
    -   对 `[Y]补` 的**所有位取反（包括符号位）**，然后**末位加 1**。
-   **溢出判断 (Overflow Detection)**： #2014年 #2023年 #2025年
    -   **概念定义**：运算结果超出数据类型表示范围。
    -   **关键特性**：符号位与最高位进位不一致时发生。
    -   **方法一：单符号位判断 (结果判断法)**：
        -   `正数 + 正数 = 负数` --> 溢出！
        -   `负数 + 负数 = 正数` --> 溢出！
        -   `正数 + 负数` --> 永不溢出！
    -   **方法二：双符号位判断 (变形补码)**：
        -   用两位表示符号位 (`00`正，`11`负)。
        -   如果运算结果的两位符号位不同 (出现 `01` 或 `10`)，则溢出。
    -   **方法三：进位判断法** (硬件常用)：
        -   比较**最高位的进位** (`Cn`) 和 **次高位的进位** (`Cn-1`)。
        -   如果 `Cn` 和 `Cn-1` **不相同**，则溢出 (`Cn XOR Cn-1 = 1`)。
    -   **符号异常法**：同号相加得异号结果时 `OF=1`。 #2025年

**8位补码表示范围与溢出条件** #2014年

| 数值类型 | 范围边界 | 临界值     | 溢出判断              |
| :------- | :------- | :--------- | :-------------------- |
| 正数上限 | `+127`   | `01111111₂` | 结果 `> 127` 时正溢出 |
| 负数下限 | `-128`   | `10000000₂` | 结果 `< -128` 时负溢出 |
| 安全区间 | `[-128, 127]` | 8 位可表示 | 无溢出风险            |

**运算方法对比**

| 方法   | 操作流程               | 优劣分析               |
| :----- | :--------------------- | :--------------------- |
| 十进制法 | 1. 转十进制数值        | 直观易懂，适合验证     |
|        | 2. 进行十进制运算      |                        |
|        | 3. 结果转补码          |                        |
| 二进制法 | 1. 直接操作补码        | 模拟计算机运算，更准确 |
|        | 2. 减法转加法运算      |                        |
|        | 3. 处理进位溢出        |                        |

#### **5. 定点数的乘除运算**

-   **乘法**： #2010年
    -   `n` 位的数乘以 `n` 位的数，结果通常需要 `2n` 位来存放。
    -   **符号处理**：乘积的符号是两个乘数符号的**异或**结果。
    -   **溢出**：如果最终结果超出了你指定的存放结果的寄存器位数，就会发生溢出。
    -   **正上溢**：正数结果超过最大正数。
    -   **负下溢**：负数结果超过最小负数。
    -   **溢出预判**：估算乘积数量级，例如两个较大负数相乘易正溢出。
-   **除法**：更复杂，通常通过硬件电路实现。
-   **常数乘法优化**：编译器可将 `变量 * 常数` 优化为若干条移位及加/减运算指令（利用二进制表示的位权特性）。 #2024年
-   **变量乘法算法**：两个变量的乘法可以通过 Booth 算法、改进 Booth 算法等循环实现（并非无法编译转换为位移及加法等指令的循环实现）。 #2024年

**乘法实现技术对比** #2024年

| 实现方式       | 硬件需求           | 时间复杂度     | 应用场景     |
| :------------- | :----------------- | :------------- | :----------- |
| 阵列乘法器     | 大量组合逻辑门     | `O(1)` - 单周期 | 高性能处理器 |
| ALU 串行乘法   | 加法器 + 移位器    | `O(n)` - `n` 周期 | 低成本处理器 |
| 移位加法优化   | 标准 ALU           | `O(log n)`     | 编译优化     |
| 算法循环实现   | 基础运算单元       | `O(n)`         | 通用实现     |

#### **6. 基本运算部件与标志位（ALU）**
-   **ALU (Arithmetic Logic Unit)**：**算术逻辑单元**，运算器的核心部件。负责算术运算和逻辑运算。 #2009年
    -   **概念定义**：CPU中负责所有数据处理的"大脑皮层"，是计算机硬件中最核心的部件之一。
    -   **关键特性**：ALU是一种**组合逻辑电路**，内部由加法器、移位器、比较器、各种逻辑门等组成。
    -   **核心中的核心**：加法器是ALU的核心部件，因为所有复杂的运算都基于加法和移位实现。
-   **ALU的功能与控制**：
    -   **地位**：ALU是CPU里的"计算高手"和"逻辑专家"，是运算器的核心。
    -   **输入**：运算数A、运算数B (n位)，Cin (进位输入)。
    -   **输出**：运算结果F (n位)，以及多个**标志位**。
    -   **控制信号**：由控制器产生，用于**选择ALU要执行的特定功能**（如加法、减法、与、或等）。
        -   如果ALU支持 `k` 种功能，则至少需要 `m` 位控制信号，满足 `m ≥ log₂(k)`。
    -   **位数特性**：ALU运算数和结果的位数 `n` 通常与计算机的**机器字长**相同。

![[带标志的ALU.png|ALU|391x375]]
![[加法器逻辑电路.png|带标志加法器逻辑电路]]
![[考研学习笔记02-计算机组成原理 ALU 今天09_34.png]]

-   **ALU输出的标志位**： #2018年 #2023年 #2025年
    -   这些标志位是本次运算结果的"特征总结"，它们通常会被送入 **PSW（程序状态字寄存器）**或**标志寄存器 (FR/Flag Register)** 中。
    -   **OF (Overflow Flag)**：**溢出标志**，用于判断**带符号数**加减运算是否溢出。
        -   **概念定义**：反映有符号数运算的溢出情况。
        -   `OF = 1` 溢出；`OF = 0` 未溢出。
        -   **生成逻辑**：`OF = Cn ⊕ Cn-1` (最高位进位 `Cn` 异或 次高位进位 `Cn-1`)。
        -   **关键特性**：符号位运算结果与实际符号不符时 `OF=1`。
    -   **SF (Sign Flag)**：**符号标志**，用于判断**带符号数**加减运算结果的正负性。
        -   **概念定义**：用于判断带符号数加减运算结果的正负性。
        -   `SF = 1` 结果为负；`SF = 0` 结果为正。
        -   **生成逻辑**：`SF = Sn` (运算结果的最高位/符号位)。
    -   **ZF (Zero Flag)**：**零标志**，用于判断加减运算结果是否为 `0`。
        -   **概念定义**：用于判断加减运算结果是否为 `0`。
        -   `ZF = 1` 结果为 `0`；`ZF = 0` 结果不为 `0`。
        -   **生成逻辑**：`ZF = 1` 仅当运算结果所有 bit 全 `0` 时。
    -   **CF (Carry Flag)**：**进位/借位标志**，主要用于判断**无符号数**加减运算是否溢出。
        -   **概念定义**：反映无符号数运算的进位或借位情况。
        -   `CF = 1` 无符号数运算发生溢出（最高位产生了进位或借位）；`CF = 0` 未溢出。
        -   **生成逻辑**：`CF = Cn` (通常指从最高位产生的进位)。
        -   **关键特性**：减法时：被减数 < 减数时 `CF=1`，否则 `CF=0`。
    -   **标志位独立性**：CF 针对无符号数，OF 针对有符号数，它们同一运算可产生不同标志位组合。

**减法指令标志位判断规则 (`A - B`)** #2018年 #2023年 #2025年

| 标志位 | 适用数据类型 | 设置条件                   | 判断方法                   |
| :----- | :----------- | :------------------------- | :------------------------- |
| CF     | 无符号数     | 减法产生借位时 `CF=1`      | 比较被减数与减数大小关系：被减数 < 减数时 `CF=1` |
| OF     | 有符号数     | 结果超出表示范围时 `OF=1`  | 分析操作数和结果的符号位变化规律 |

---

### 02-3 浮点数的表示与运算

#### **1. 浮点数的表示 (IEEE 754 标准)**
-   **浮点数**：即带小数点的数，通过类似科学计数法的方式在有限存储空间内表示非常大或非常小的数值，可能牺牲精度。
-   **IEEE 754 标准**：国际上通用的浮点数表示标准，规定了浮点数的二进制存储格式。
-   **浮点数结构**：`S | E | M`
    -   **计算公式**：`Value = (-1)^S × (1.M) × 2^(E_实际)`
        -   **S (Sign - 符号位)**：**1 位** (`0`正，`1`负)。
        -   **E (Exponent - 阶码/指数位)**：存储**移码 (Bias/偏置码)** 形式的指数。
            -   **Bias (偏置值/偏移量)**：用于将实际指数转换为非负整数，便于比较。
                -   **单精度 (8位E)**：`Bias = 2^(8-1) - 1 = 127`。
                -   **双精度 (11位E)**：`Bias = 2^(11-1) - 1 = 1023`。
            -   **实际指数**：`E_实际 = E_存储 - Bias`。
            -   **`阶码决定了数值范围`**（能表示的整数部分位数及小数部分的数量级）。
        -   **M (Mantissa / Fraction - 尾数/小数部分)**：存储小数部分。
            -   **隐藏位 (Hidden Bit)**：对于**规格化浮点数**，默认小数点前有一个**隐含的 `1`** (即表示形式为 `1.M`)。这个 `1` 不占用存储位，是为了在有限的位数下增加一位有效精度！
            -   **`尾数的位数表明了精度`**（有效数字的位数）。

![[考研学习笔记02-计算机组成原理 02-数据表示和运算 2025-10-17 1247.png]]

-   **单精度浮点数 (`float`)**： #2011年 #2012年 #2013年 #2014年 #2022年 #2025年
    -   总长：**32 位**。
    -   结构：`S (1位) | E (8位) | M (23位)`。
    -   `Bias = 127`。
-   **双精度浮点数 (`double`)**：
    -   总长：**64 位**。
    -   结构：`S (1位) | E (11位) | M (52位)`。
    -   `Bias = 1023`。

| **类型**                   | **位数** | **范围 (近似)**                     | **有效位数 (近似)**          |
| ------------------------ | ------ | ------------------------------- | ---------------------- |
| **float** (IEEE754 单精度)  | 32     | $[\pm 10^{-38}, \pm 10^{38}]$   | **约 7 位** (24 bit 尾数)  |
| **double** (IEEE754 双精度) | 64     | $[\pm 10^{-308}, \pm 10^{308}]$ | **约 15 位** (53 bit 尾数) |

**IEEE754 格式字段定义**

| 字段         | 位数 | 位置        | 编码规则/功能          | 作用         |
| :----------- | :--- | :---------- | :--------------------- | :----------- |
| 符号位 (S)   | 1 位 | 第 31 位    | `0`=正数，`1`=负数     | 确定数值符号 |
| 阶码 (E)     | 8 位 | 第 30-23 位 | 移码表示，偏置值 `127` | 确定数量级   |
| 尾数 (M)     | 23 位 | 第 22-0 位  | 省略隐含位 `1` 的小数部分 | 确定精度值   |

-   **`E_存储` 的关键区间和特殊值**： #2012年 #2018年 #2020年 #2023年
    1.  **规格化浮点数** (Normalized Number)：
        -   **特征**：`E_存储` 的值在 `1` 到 `2^(E位数)-2` 之间 (单精度 `[1, 254]`)。
        -   **表示**：`(-1)^S × (1.M) × 2^(E_存储 - Bias)`。
        -   **隐藏位**：存在，为 `1`。
    2.  **非规格化浮点数** (Denormalized / Subnormal Number)： #2023年
        -   **特征**：`E_存储` **全为 `0`** (`0000 0000`)。
        -   **表示**：`(-1)^S × (0.M) × 2^(-Bias + 1)` (注意这里的实际指数固定为 `-Bias + 1`)。
        -   **隐藏位**：不存在（隐含的 `1` 变为 `0`）。
        -   包括精确的 `+0` (`S=0, E=0, M=0`) 和 `-0` (`S=1, E=0, M=0`)。
        -   **用途**：避免了**下溢 (Underflow)** 造成的精度突然损失，能够表示出比最小规格化数更小的非零数，提供渐进式下溢(gradual underflow)机制。
    3.  **特殊值** (当 `E_存储` **全为 `1`** 时)：
        -   **无穷大 (Infinity)**：`M` **全为 `0`**。
        -   **非数 (NaN - Not a Number)**：`M` **不全为 `0`**。

**IEEE754 格式特征和特殊值边界分析** #2012年 #2023年

| 字段组合 | S   | E    | M    | 表示类型       | 数值含义             |
| :------- | :-- | :--- | :--- | :------------- | :------------------- |
| 零值     | 0/1 | 0    | 0    | 特殊值         | `±0`                 |
| 非规格化数 | 0/1 | 0    | `≠0` | 下溢数         | `±0.M × 2⁻¹²⁶`       |
| 规格化数 | 0/1 | 1-254 | 任意  | 正常数         | `±1.M × 2^(E-127)`   |
| 无穷大   | 0/1 | 255  | 0    | 特殊值         | `±∞`                 |
| NaN      | 0/1 | 255  | `≠0` | 非数 Not a Number | 非数值               |

| 边界情况 | E 值 | 限制原因           | 表示含义           |
| :------- | :--- | :----------------- | :----------------- |
| E=0      | 保留 | 非规格化数和零     | 特殊编码           |
| E=255    | 保留 | 无穷大和 NaN       | 特殊编码           |
| E=254    | 最大有效 | 最大规格化指数 `2^127` | 正常规格化数       |
| E=1      | 最小有效 | 最小规格化指数 `2^-126` | 正常规格化数       |

-   **数值范围 (`阶码决定`)**：由指数 `E` 的有效取值范围决定。 #2012年
    -   最小规格化正数：`1.0 × 2^(-Bias + 1)` (单精度 `1.0 × 2⁻¹²⁶`)。 #2018年
    -   最大规格化正数：`(2 - 2⁻²³) × 2¹²⁷` (单精度 `2¹²⁸ - 2¹⁰⁴`)。 #2012年
-   **精度 (`尾数决定`)**：由尾数 `M` 的位数决定。尾数位数越多，能表示的有效数字越多，精度越高。
    -   单精度 `float` (23位尾数 + 1位隐藏位) 大约 6-7 位十进制有效数字。
    -   双精度 `double` (52位尾数 + 1位隐藏位) 大约 15-17 位十进制有效数字。

**浮点数转换技巧 (真值与IEEE754格式互转)** #2011年 #2013年 #2014年 #2022年 #2025年

| 转换步骤           | 操作要点                                   | 易错提醒/关键技巧                      |
| :----------------- | :----------------------------------------- | :------------------------------------- |
| **真值 → IEEE754** |                                            |                                        |
| 1. 符号位确定      | 正数 `S=0`，负数 `S=1`                     | 直接由数值符号确定                     |
| 2. 二进制转换      | 将真值绝对值转换为二进制小数形式           | 整数部分和小数部分分别转换             |
| 3. 规格化          | 调整为 `1.M × 2^n` 形式                    | 确保整数部分为 `1`，确定指数 `n`         |
| 4. 阶码计算        | `E_存储 = n + Bias`                        | 移码偏置 `Bias` 固定为 127/1023        |
| 5. 尾数提取        | 取小数点后 23/52 位作为 M 字段，末尾补 `0` 补齐 | 省略隐含整数位 `1`                     |
| 6. 组合与十六进制  | 按 S-E-M 顺序拼接，4 位二进制转 1 位十六进制 | 从高位开始分组                         |
| **IEEE754 → 真值** |                                            |                                        |
| 1. 十六进制转二进制 | 逐位转换为 4 位二进制，保持 32/64 位完整性 |                                        |
| 2. 字段分离        | 按 S (1位)、E (8/11位)、M (23/52位) 划分 | 严格按标准位置划分                     |
| 3. 判断数值类型    | 根据 E 和 M 的值确定数值类型               | E=0 或 E=全1 的特殊情况优先判断        |
| 4. 各字段数值解析  | 符号因子 `(-1)^S`；真实指数 `E_存储 - Bias`；规格化尾数 `1.M` 或非规格化尾数 `0.M` | **不要遗漏隐含位 `1`**（规格化数）或 `0`（非规格化数） |
| 5. 应用公式计算    | 代入相应公式 `(-1)^S × (1.M) × 2^(E_实际)` | 验证数量级合理性                       |

**精确表示条件** #2021年
-   IEEE754 浮点数能**精确表示**的十进制数，必须满足其小数部分可表示为 `i/2^k` 的形式，其中 `i, k` 为非负整数，且 `k` 不超过尾数精度限制。
-   **实用判别法则**：
    1.  将十进制小数转换为**最简分数形式**。
    2.  检查分母的**质因数分解**。
    3.  若分母仅含因子 `2`，则可精确表示（有限二进制展开）。
    4.  若分母含 `2` 以外的质因子 (如 `3, 5, 7` 等)，则无法精确表示（无限二进制循环，产生舍入误差）。

#### **2. 浮点数的加减运算**
-   **浮点数加减运算过程**一般包括对阶、尾数运算、规格化、舍入和判溢出等步骤。 #2009年 #2015年
![[考研学习笔记02-计算机组成原理 02-数据表示和运算 2025-10-10 36.png]]
1.  **对阶 (Exponent Alignment)**： #2009年
    -   **概念定义**：让两个浮点数的**实际指数 `E_实际` 变得相同**。
    -   **关键特性**：通常是"小阶向大阶看齐"：指数小的数，将其尾数右移，每右移一位，阶码加1。阶码差值决定尾数右移位数。
    -   **溢出风险分析**：**对阶操作不会引起阶码上溢或下溢**（阶码在有效范围内调整，仅选择现有较大值）。 #2015年
2.  **尾数加减 (Mantissa Addition/Subtraction)**： #2009年
    -   对齐后，直接对两个数的尾数部分进行加减运算。
    -   **溢出风险分析**：**尾数溢出时结果不一定溢出**。尾数运算产生进位超出范围后，可通过右规调整来补偿。若调整后阶码仍在有效范围，则不发生最终溢出。 #2015年
3.  **规格化 (Normalization)**： #2009年
    -   **概念定义**：调整运算结果的尾数，使其符合 `1.M` 的规格化形式（尾数最高位为 `1`）。
    -   **关键特性**：尾数左移/右移，阶码相应调整。
    -   **溢出风险分析**：**右规和尾数舍入都可能引起阶码上溢**。当 E=最大有效阶码 (如254) 时，右规或舍入导致阶码+1， E变为255，触发上溢（产生±∞）。 #2015年
4.  **舍入 (Rounding)**： #2009年
    -   **概念定义**：根据精度要求对尾数进行数值调整，通常在规格化之后。
    -   如果尾数运算后超出了 23 位的精度，需要进行舍入操作。
    -   **溢出风险分析**：舍入进位可能使尾数触发右规，若原 E=最大有效阶码，则产生阶码上溢。 #2015年
5.  **溢出判断 (Overflow Detection)**： #2009年
    -   **概念定义**：主要判断**阶码**是否超出表示范围。
    -   **关键特性**：阶码符号位变化检测溢出。
    -   **溢出风险分析**：**左规时可能引起阶码下溢**。当 E=最小有效阶码 (如1) 时，左规导致阶码-1， E变为0，触发下溢（非规格化数或零）。 #2015年

**浮点运算溢出风险分析总结** #2015年

| 运算阶段    | 操作内容         | 溢出类型     | 溢出条件                   |
| :------ | :----------- | :------- | :--------------------- |
| 对阶      | 小阶向大阶对齐，尾数右移 | 无阶码溢出    | 阶码在有效范围内调整             |
| 尾数运算    | 尾数相加或相减      | 尾数溢出（可能） | 结果超出尾数表示范围（可通过右规补偿）    |
| 规格化（右规） | 尾数右移，阶码+1    | 阶码上溢（可能） | `E+1` 超出最大值，导致 `E=255` |
| 规格化（左规） | 尾数左移，阶码-1    | 阶码下溢（可能） | `E-1` 低于最小值，导致 `E=0`   |
| 舍入      | 尾数精度处理       | 阶码上溢（可能） | 进位导致右规，进一步触发阶码上溢       |

**问题背景**：计算 $X+Y$ 的浮点加法，其中 $X = 2^7 \times \frac{29}{32}$，$Y = 2^5 \times \frac{5}{8}$，采用 **5 位（1 位阶码符号位 + 3 位阶码 + 1 位尾数符号位 + 5 位尾数）** 的自定义浮点格式。

**格式定义确认**
-   **浮点格式**：`[阶码符号位][阶码 3 位][尾数符号位][尾数 5 位]`
-   **$X$ 的二进制**：$27 \times 29/32 = 2^7 \times (0.11101)_2$ → `00111|0011101`
-   **$Y$ 的二进制**：$2^5 \times 5/8 = 2^5 \times (0.10100)_2$ → `00101|0010100`

**第一步：对阶操作**
-   **阶码比较**：$X$ 阶码 = `0111` (7)，$Y$ 阶码 = `0101` (5)
-   **阶码差值**：$7 - 5 = 2$
-   **对阶调整**：$Y$ 的尾数右移 2 位，阶码调整为 `0111`
-   **对阶结果**：$Y' = (0.00101)_2$，新阶码 = `00111`

**第二步：尾数加法运算**
-   **$X$ 的尾数**：$(0.11101)_2$
-   **$Y'$ 的尾数**：$(0.00101)_2$
-   **加法结果**：$(0.11101)_2 + (0.00101)_2 = (1.00010)_2$
-   **关键现象**：尾数和 $(1.00010)_2$ 超出 $[0,1)$ 范围，**已经出现了尾数溢出**。

**第三步：规格化处理（右规）**
-   **尾数分析**：$(1.00010)_2$ 超出 $[0,1)$ 范围，**需要右规**
-   **右规操作**：
    -   尾数右移 1 位：$(1.00010)_2 \rightarrow (0.10001)_2$
    -   阶码加 1：`0111 + 0001 = 1000`
-   **调整后的阶码**：`1000`

**第四步：溢出检测（阶码正溢出）**
-   **阶码分析**：调整后阶码为 `1000`
-   **符号位检查**：
    -   原阶码符号位 = `0`（正数）
    -   新阶码符号位 = `1`（负数）
-   **溢出判断**：**符号位从 0 变为 1，表明阶码正溢出**
-   **溢出原因**：
    -   3 位阶码补码最大值 = `011` (十进制 +3)
    -   右规后计算 `0111 + 0001 = 1000`（四位结果发生进位）
    -   在 3 位补码中，`1000` 被截断为 `000` 或理解为最高位溢出
    -   实际上 `1000` 在 3 位补码表示中对应 **-4**（最小值），而不是 +4
    -   这导致**符号位翻转**，产生阶码正溢出现象

**关键知识点总结**
-   **对阶不会导致溢出**：对阶仅是调整指数相等，不超出有效范围
-   **尾数溢出可以通过右规补偿**：尾数相加超出范围后，右规可以恢复有效范围
-   **规格化中的右规会增加阶码**：这是导致阶码溢出的直接原因
-   **符号位翻转是检测溢出的关键**：在有限位数补码中，阶码在有效范围与无效范围之间的转换通过符号位变化体现
-   **浮点格式设计限制**：过小的阶码字段（如 3 位）容易在某些计算中触发溢出，这是浮点数表示精度与范围的权衡

#### **3. C语言中的浮点数类型**
-   `float`：单精度浮点数，占用 4 字节 (32位)。
-   `double`：双精度浮点数，占用 8 字节 (64位)。精度更高，范围更大。
-   **精度问题**：浮点数采用二进制表示，但很多十进制小数（如 `0.1`、`0.2`）无法用有限位的二进制小数精确表示，可能存在**精度损失**。 #2010年
    -   因此，浮点数比较通常不直接用 `\==`，而是判断差值绝对值是否在一个很小的范围内。
-   **类型转换规则**： #2010年
    -   `int` → `float`：可能损失精度（如果 `int` 的有效数字超过 `float` 的 24 位）。
    -   `float` → `int`：截断小数部分。
    -   `float` → `double`：精度提升，完全无损。
    -   `double` → `float`：可能损失精度（如果原值超出 `float` 范围或精度要求更高）。
    -   **注意**：浮点数数量级差异过大时，小数值对大数值的加减可能因对阶而丢失精度（例如 `(d+f)-d == f` 可能为假）。

**数据类型选择依据** #2024年
-   在科学计算中，数据表示方法的选择遵循"精度优先，性能次之"原则。

| 判断步骤   | 分析要点                       | 优先级考虑             |
| :--------- | :----------------------------- | :--------------------- |
| 1. 范围检查 | 确保数据类型能完全覆盖参数范围 | **必要条件**           |
| 2. 精度验证 | 计算所需最大有效位数           | **核心要求**           |
| 3. 性能评估 | 整数 > 单精度 > 双精度 (速度)  | **优化目标**           |
| 4. 类型匹配 | 在满足精度前提下选择最快类型   | **最终决策**           |

---

### 02-4 数据的大小端和对齐存储
-   **大小端 (Endianness)**：指的是多字节数据（比如 `int`、`float`）在内存中存储时，**字节的顺序**。
    -   **概念定义**：多字节数据在内存中的存储顺序。
    -   **大端模式 (Big-Endian)**：数据的**高位字节**存储在**低内存地址**。这更符合人类阅读数字的习惯。
    -   **小端模式 (Little-Endian)**：数据的**低位字节**存储在**低内存地址**。Intel 的处理器（x86架构）就是小端模式！ #2012年 #2016年 #2018年 #2020年 #2025年
    -   **例子**：一个 4 字节的整数 `0x12345678`。
        -   内存地址 `0x1000` `0x1001` `0x1002` `0x1003`
        -   大端模式：`12` `34` `56` `78`
        -   小端模式：`78` `56` `34` `12`
    -   **重要性**：网络传输（通常是大端）、跨平台文件读写时，需要注意数据的字节序，否则会读出错误的值！
-   **对齐存储 (Alignment)**：
    -   **概念定义**：为了提高内存访问效率，计算机硬件通常要求数据存储在**特定的内存地址边界**上。 #2012年 #2020年 #2025年
    -   **按字节编址**：每个字节占用一个地址单元，地址递增步长为 1。
    -   **对齐规则**：通常要求数据类型的起始地址是其大小的整数倍。
        -   例如，一个 4 字节的 `int` 类型变量，可能要求它的起始地址必须是 4 的倍数 (0x0000, 0x0004, 0x0008 等)。
        -   `int` (4 字节) 需 4 字节对齐，`short` (2 字节) 需 2 字节对齐，`char` (1 字节) 需 1 字节对齐。
    -   **Padding (填充)**： #2012年 #2020年 #2025年
        -   **概念定义**：为了满足对齐要求，编译器会在结构体成员之间或者结构体末尾添加一些**空余的字节**。
        -   **结构体填充**：成员按各自对齐要求排列，可能需要填充字节。结构体的总大小通常也是最大成员对齐值的整数倍。
    -   **影响**：对齐存储会**增加内存占用**，但可以**提高内存访问速度**。这是一个空间换时间的策略。

**内存布局分析技巧** #2012年 #2016年 #2018年 #2020年 #2025年

| 解题步骤        | 操作要点                                                           | 关键技巧/注意事项                      |
| :---------- | :------------------------------------------------------------- | :----------------------------- |
| 1. 确定数据类型大小 | `int` (4 字节), `short` (2 字节), `char` (1 字节), `double` (8 字节) 等 | 根据编译器规定和数据类型大小                 |
| 2. 计算边界对齐   | 每个成员按其自身大小对齐                                                   | `int` 通常 4 字节对齐，`short` 2 字节对齐 |
| 3. 结构体填充    | 成员间可能需要插入填充字节以满足后续成员的对齐要求                                      | 填充至最大成员对齐值的倍数或编译器特定规则          |
| 4. 绘制内存布局图  | 从首地址按序分配空间，包括填充字节                                              | 清晰标注每个地址单元对应的变量部分              |
| 5. 应用字节序规则  | 多字节数据按**小端**方式存储                                               | **低位字节在低地址**，数据字节逆序存储          |
| 6. 定位目标地址   | 根据布局图确定具体内容和地址                                                 | 验证对齐和字节序的正确性                   |
-   **机器指令中的立即数**：x86架构的 `MOV` 指令会将立即数（常量值）按小端字节序存储在指令中。
