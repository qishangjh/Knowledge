---
科目:
课程名称:
tags: [排序]
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
aliases: 08 排序：核心概念与算法解析
linter-yaml-title-alias: 08 排序：核心概念与算法解析
---

# 08 排序

## 08-1 排序的基本概念

### 1. 排序的定义
* **定义**: 将一组无序的数据元素，按照特定的规则（如升序或降序）重新排列，使其成为一个有序序列的过程。
* **分类**:
    * **内部排序 (Internal Sort)**: 所有待排序的数据都能一次性载入内存进行排序。
    * **外部排序 (External Sort)**: 待排序的数据量过大，无法一次性载入内存，需要借助外部存储器（如磁盘）进行排序。
* **稳定性 (Stability)**:
    * **定义**: 如果待排序序列中存在值相等的元素，排序后，这些相等元素的相对次序保持不变，则称该排序算法是**稳定**的。
    * **不稳定**: 如果相等元素的相对次序可能发生改变，则称该排序算法是**不稳定**的。
        * 对于不稳定的排序，列出一组关键字，说明它的不稳定性即可。
        #希尔排序 #快速排序 #简单选择排序

## 08-2 插入排序
#插入排序
### 1. 直接插入排序 (Straight Insertion Sort)
#直接插入排序
* **基本思想**: 将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到所有记录插入完成。
* **过程**: 每次取一个未排序的元素，与已排序部分的元素从后向前依次比较，找到合适位置并插入。
* **特点**:
    * **时间复杂度**:
        * 最好情况 (已序): O(n)
        * 最坏情况 (逆序): O(n^2)
        * 平均情况: O(n^2)
    * **空间复杂度**: O(1) (原地排序)
    * **稳定性**: **稳定**。
* **适用场景**: 数据量较小或数据基本有序时效率较高。

### 2. 折半插入排序 (Binary Insertion Sort)
* **基本思想**: 在直接插入排序的基础上，利用**二分查找** #折半查找 来寻找插入位置，减少比较次数。 #二分查找
* **过程**: 确定插入位置时使用二分查找，但元素的移动（插入操作）仍需逐个后移。
* **特点**:
    * **时间复杂度**:
        * 比较次数: $O(n log n)$
        * 移动次数: O(n^2)
        * 总时间复杂度: $O(n^2)$
    * **空间复杂度**: O(1)
    * **稳定性**: **稳定**。
* **适用场景**: 当比较操作的开销远大于移动操作时，有一定优势。

### 3. 希尔排序 (Shell Sort / 缩小增量排序)
#希尔排序
* **基本思想**: 先将整个待排序序列分割成若干个子序列（间隔为`d`），对每个子序列进行直接插入排序。然后逐渐缩小增量`d`，重复上述过程，直到增量`d`为1时，进行最后一次直接插入排序。
* **过程**: 采用"跳跃式"的插入排序，先进行大范围的粗略调整，再进行小范围的精细调整。
* **特点**:
    * **时间复杂度**: 介于 O(n) 到 O(n^2) 之间，具体取决于增量序列的选择，通常优于 O(n^2) 算法。
    * **空间复杂度**: O(1)。
    * **稳定性**: **不稳定**。因为跳跃式的比较和移动可能改变等值元素的相对顺序。
* **适用场景**: 对中等规模的数据排序效果较好。

## 08-3 交换排序
#交换排序
### 1. 冒泡排序 (Bubble Sort)
#冒泡排序
* **基本思想**: 重复遍历待排序序列，比较相邻的两个元素，如果它们的顺序不符合要求就进行交换，直到没有元素需要交换，即序列有序。
* **过程**: 每一趟将当前未排序部分的最大（或最小）元素"冒泡"到其最终位置。
* **特点**:
    * **时间复杂度**:
        * 最好情况 (已序): O(n)
        * 最坏情况 (逆序): $O(n^2)$
        * 平均情况: O(n^2)
    * **空间复杂度**: O(1)。
    * **稳定性**: **稳定**。
* **适用场景**: 数据量很小或作为教学示例。

```c
// 冒泡排序的算法
void BubbleSort(ElemType A[],int n){
        for(int i=0;i<n-1;i++){
            bool flag=false;  //设置交换标志
            for (int j=n-1;j>i;j--) //一趟冒泡排序
                if(A[j-1]>A[j]){ //若为逆序
                    swap(A[j-i],A[j]); //使用封装的swap函数交换
                    flag=true;
                }
            if(flag==false)
                return; //若一趟排序未发生交换，说明已有序，提前终止
        }
}
```

### 2. 快速排序 (Quick Sort)
#快速排序
* **基本思想**: 采用**分治法**。选择一个元素作为"基准"（pivot），通过一趟排序将待排序序列分割成独立的两部分，其中一部分的所有元素都比基准小，另一部分的所有元素都比基准大。然后对这两部分再分别进行快速排序。
* **过程**:
    1. **选择基准**: 从序列中选择一个元素作为基准。
    2. **分区**: 重新排列序列，将所有小于基准的元素移到基准之前，所有大于基准的元素移到基准之后。
    3. **递归**: 对基准前后的子序列递归地进行快速排序。
* **特点**:
    * **时间复杂度**:
        * 平均情况: $O(n log n)$ (性能最优)
        * 最坏情况: $O(n^2)$(基准选择不当，如序列已基本有序或逆序)
    * **空间复杂度**: O(log n) (递归栈空间)，最坏情况 O(n)。
    * **稳定性**: **不稳定**。因为交换操作可能改变等值元素的相对顺序。
* **适用场景**: 内部排序中平均性能最好的算法之一，是考研408的重点和难点。

### 3. 其他交换排序
* 除了冒泡排序和快速排序，交换排序还有一些变种（如双向冒泡排序），但在考研408中，快速排序是交换排序的绝对核心。

## 08-4 选择排序
#选择排序
### 1. 简单选择排序 (Simple Selection Sort)
* **基本思想**: 每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放到序列的起始位置，直到全部排完。
* **过程**: 遍历未排序部分，找到最小元素，与当前未排序部分的第一个元素交换位置。
* **特点**:
    * **时间复杂度**: 最好、最坏、平均都是 O(n^2)。
    * **空间复杂度**: O(1)。
    * **稳定性**: **不稳定**。因为交换操作可能改变等值元素的相对顺序。
* **适用场景**: 数据量小。

### 2. 堆排序 (Heap Sort)
#堆排序
* **堆**（一种特殊的 #完全二叉树）
    n个关键字序列$L[1…n]$ ,满足$L(i)≥L(2i) \&\& L(i)≥L(2i+1)$——大根堆
    $L(i)≤L(2i) \&\& L(i)≤L(2i+1)$——小根堆
    * 大根堆：所有子树根结点的值大于等于其左右孩子结点的值。![[考研学习笔记01-数据结构 08 排序 2025-10-09 31.png]]
    * 小根堆：所有子树根结点的值小于等于其左右孩子结点的值。![[考研学习笔记01-数据结构 08 排序 今天16_46.png]]
    * i的左孩子：2i
    * i的右孩子：2i+1
    * i的父节点：i/2
    * i的所在层：$\log_2(n+1)$或 $\log_2n+1$
* **过程**:
    1. **构建堆**: 将待排序序列构建成一个大顶堆（或小顶堆），此时堆顶元素是最大（或最小）的元素。最后一个结点是$L(n/2)$结点的孩子。从根向前依次进行交换
    2. **堆调整**: 将堆顶元素与堆的最后一个元素交换，然后将剩余元素调整为新的堆。
    3. **重复**: 重复步骤2，直到堆中只剩一个元素。
* **特点**:
    * **时间复杂度**: 最好、最坏、平均都是$O(n log n)$。
    * **空间复杂度**: O(1) (原地排序)。
    * **稳定性**: **不稳定**。因为调整堆结构和交换操作可能改变等值元素的相对顺序。
* **适用场景**: 效率高，空间复杂度低，适合数据量大的情况。
* **堆插入新元素**：
    * **大根堆**：
    * **小根堆**：新元素放到表尾，与⽗节点对⽐，若新元素⽐⽗节点更⼩，则将⼆者互换。新元素就这样⼀路"上升"，直到⽆法继续上升为⽌
* **堆删除元素**：被删除的元素⽤堆底元素替代，然后让该元素不断"下坠"，直到⽆法下坠为⽌

## 08-5 归并排序、基数排序和计数排序

### 1. 归并排序 (Merge Sort)
#归并排序merge
* **基本思想**: 采用**分治法**。将待排序序列递归地分成两半，直到每个子序列只有一个元素（自然有序），然后将这些有序的子序列两两合并，直到合并成一个完整的有序序列。
* **过程**:
    1. **分解**: 将序列递归地分解为两个子序列。
    2. **解决**: 对两个子序列进行递归排序。
    3. **合并**: 将两个已排序的子序列合并成一个完整的有序序列。
* **特点**:
    * **时间复杂度**: 最好、最坏、平均都是 $O(n log n)$。
    * **空间复杂度**: O(n) (需要额外的空间来存放合并后的序列)。
    * **稳定性**: **稳定**。
* **适用场景**: 性能稳定，适合数据量大且要求稳定的情况。是唯一一个可以用于外部排序的内部排序算法。

```c
ElemType
```

### 2. 基数排序 (Radix Sort)
* **基本思想**: 一种**非比较排序**算法。它不通过比较元素大小来排序，而是将整数按位数切割成不同的数字，然后按每个位数分别比较。通常从最低位开始，依次对每一位进行"分配"（放入桶中）和"收集"（从桶中取出）。
* **过程**: 针对每一位（从低位到高位），使用稳定的计数排序（或桶排序）对元素进行排序。
* **特点**:
    * **时间复杂度**: O(d * (n + r))，其中 `d` 是数据的位数，`n` 是数据个数，`r` 是基数（如十进制为10）。在特定条件下（位数和基数固定），非常快。
    * **空间复杂度**: O(n + r)。
    * **稳定性**: **稳定**。
* **适用场景**: 适用于整数排序，且位数固定或范围不大的情况。

### 3. 计数排序 (Counting Sort)

* **基本思想**: 一种**非比较排序**算法。它统计每个元素出现的次数，然后根据这些次数直接将元素放到正确的位置上。
* **过程**:
    1. 找出待排序序列中的最大值和最小值。
    2. 创建一个计数数组，大小为 `最大值 - 最小值 + 1`。
    3. 遍历待排序序列，统计每个元素出现的次数，并存入计数数组。
    4. 修改计数数组，使其存储的不再是某个元素出现的次数，而是小于等于该元素的元素总数（前缀和）。
    5. 倒序遍历原始序列，根据计数数组中的位置将元素放到输出数组中，并递减计数数组中对应位置的值。
* **特点**:
    * **时间复杂度**: O(n + k)，其中 `n` 是元素个数，`k` 是数据范围（最大值 - 最小值 + 1）。
    * **空间复杂度**: O(k)。
    * **稳定性**: **稳定**。
* **适用场景**: 适用于整数排序，且数据范围 `k` 不大的情况。

## 08-6 各种内部排序算法的比较及应用
### 1. 内部排序算法的比较

| 排序方法      | 基本思想                                                                              | 一趟确定最终位置？        | 适用场景/特点                    |
| :-------- | :-------------------------------------------------------------------------------- | :--------------- | :------------------------- |
| **插入类排序** |                                                                                   |                  |                            |
| 1. 直接插入排序 | 将一个记录插入到已排好序的有序序列中，从而得到一个新的、记录数增加1的有序序列。                                          | 否                | **小规模数据**，或数据**基本有序**时效率高  |
| 2. 希尔排序   | 先将待排记录分成若干子序列，对每个子序列进行直接插入排序，然后逐步缩小增量，重复上述过程，直到增量为1。                              | 否                | **中等规模数据**，对大部分数据都有效率提升    |
| **交换类排序** |                                                                                   |                  |                            |
| 1. 冒泡排序   | 重复遍历待排序的序列，依次比较相邻的两个元素，如果它们的顺序错误就把它们交换过来。                                         | **是** (每趟确定一个最值) | 实现简单，但在内存中效率较低，**不推荐**     |
| 2. 快速排序   | 采用分治思想。选择一个基准元素，通过一趟排序将序列分成两部分：所有小于基准的放在基准左边，所有大于基准的放在基准右边，基准元素放到最终位置。然后对两部分递归排序。 | **是** (每趟确定基准位置) | **实践中最常用**，平均性能最好，**非常重要** |
| **选择类排序** |                                                                                   |                  |                            |
| 1. 简单选择排序 | 每趟从待排序序列中选出最小（或最大）的一个元素，存放到序列的起始（或结束）位置。                                          | **是** (每趟确定一个最值) | 实现简单，交换次数少，但总效率不高          |
| 2. 堆排序    | 将待排序序列构建成一个大顶堆（或小顶堆），然后将堆顶元素与堆尾元素交换，并对剩余元素重新调整为堆。重复此过程。                           | **是** (每趟确定一个最值) | **高效的原地排序算法**，适用于大规模内存数据   |
| 二路归并排序    | 采用分治思想。将序列递归地分成两半，直到每个子序列只有一个元素，然后将两个有序子序列合并成一个更大的有序序列。                           | 否                | 高效、稳定，但需要额外内存，是**外部排序的基础** |
| 基数排序      | 将整数按位数切割成若干独立的数字，再从最低位（LSD）或最高位（MSD）开始，依次进行分配和收集。                                 | 否                | 对**整数**排序非常高效，不基于比较，适用范围有限 |


| 算法名称   | 平均时间复杂度           | 最坏时间复杂度    | 空间复杂度    | 稳定性 | 备注               |
| :----- | :---------------- | :--------- | :------- | :-- | :--------------- |
| 直接插入排序 | O(n^2)            | O(n^2)     | O(1)     | 稳定  | 小数据量或基本有序时较好     |
| 折半插入排序 | O(n^2)            | O(n^2)     | O(1)     | 稳定  | 比较次数少，移动次数不变     |
| 希尔排序   | O(n^1.3) ~ O(n^2) | O(n^2)     | O(1)     | 不稳定 | 中等数据量，比O(n^2)快   |
| 冒泡排序   | O(n^2)            | O(n^2)     | O(1)     | 稳定  | 简单直观，效率低         |
| 快速排序   | O(n log n)        | O(n^2)     | O(log n) | 不稳定 | 平均性能最好，考研重点      |
| 简单选择排序 | O(n^2)            | O(n^2)     | O(1)     | 不稳定 | 效率低              |
| 堆排序    | O(n log n)        | O(n log n) | O(1)     | 不稳定 | 效率高，原地排序         |
| 归并排序   | O(n log n)        | O(n log n) | O(n)     | 稳定  | 性能稳定，可用于外部排序     |
| 计数排序   | O(n+k)            | O(n+k)     | O(k)     | 稳定  | 非比较排序，数据范围k不大时高效 |
| 基数排序   | O(d*(n+r))        | O(d*(n+r)) | O(n+r)   | 稳定  | 非比较排序，整数且位数固定时高效 |

### 2. 内部排序算法的应用
* **数据量小**: 直接插入排序（简单易实现）。
* **数据量大**:
    * **追求平均效率**: 快速排序。
    * **追求稳定且效率高**: 归并排序。
    * **追求原地排序且效率高**: 堆排序。
* **特定数据类型 (整数，范围或位数有限)**: 计数排序、基数排序。

## 08-7 外部排序
### 1. 外部排序的基本概念
* **定义**: 当待排序的数据量远大于内存容量时，需要将数据存储在外部存储器（如磁盘）上，并借助外部存储器进行排序。
* **核心问题**: 磁盘I/O操作是外部排序的主要瓶颈，因此外部排序的目标是**尽可能减少磁盘I/O次数**。

### 2. 外部排序的方法
* 主要采用**多路平衡归并排序**。
* **基本步骤**:
    1. **生成初始归并段 (Initial Runs)**: 将大文件分成若干个小文件，每个小文件都能装入内存。在内存中对这些小文件进行内部排序，生成一个个有序的"初始归并段"。
    2. **多路归并**: 将这些有序的初始归并段进行多路归并，逐步合并成更大的有序段，直到最终合并成一个完整的有序文件。

| 排序方法       | 时间复杂度                          | 空间复杂度                    | 稳定性                | 适用场景/特点                 |
| :--------- | :----------------------------- | :----------------------- | :----------------- | :---------------------- |
| **多路归并排序** | $O(N \log_k N)$ (N为记录数，k为归并路数) | $O(M)$ (M为内存容量，用于每次归并操作) | 取决于内部排序算法和归并算法的稳定性 | **超大规模数据**排序（如数据库、文件系统） |
### 3. 多路平衡归并与败者树

* **多路归并**: 同时合并 `K` 个有序段，可以减少归并趟数，从而减少磁盘I/O次数。
* **败者树 (Loser Tree)**:
    * **目的**: 提高多路归并的效率，快速找到 `K` 个归并段中下一个最小的元素。
    * **原理**: 一种完全二叉树，每个非叶子节点存储的是其子节点中的"败者"（即较小的那个），而胜者则继续向上比较，最终根节点存储的是所有 `K` 个元素中的最小者。
    * **优势**: 每次选择最小元素的时间复杂度从 O(K) 降到 O(log K)。

### 4. 置换-选择排序（生成初始归并段）

* **目的**: 在生成初始归并段时，尽可能地生成更长的有序段，以减少初始归并段的数量，从而减少后续归并的趟数。
* **基本思想**: 利用内存缓冲区，边读入数据边进行排序。通过维护一个"小顶堆"（或败者树），将当前内存中最小的元素输出，同时从外部读入新的元素补充到内存中，并调整堆结构。如果新读入的元素比当前输出的元素小，则它属于下一个归并段。

### 5. 最佳归并树

* **目的**: 当初始归并段的数量不是 `K` 的整数倍时，如何安排归并的顺序，才能使得总的磁盘I/O次数最少。
* **思想**: 类似于哈夫曼树的构建过程，通过构建一棵"最佳归并树"，使得带权路径长度最小，从而达到最少的I/O次数。

---
**【内部排序与外部排序的联系与考点】**

1.  **分治思想：** 外部排序的核心是**分治策略**。将大问题分解为小问题（生成初始归并段），再将小问题的解合并（多路归并）为大问题的解。
2.  **内部排序的应用：** 外部排序的第一个阶段（生成初始归并段）**必须依赖**内部排序算法。通常选择快速排序或堆排序，因为它们效率高且空间占用少。
3.  **磁盘 I/O 优化：** 外部排序的主要目标是**最小化磁盘 I/O 次数**。
    *   **增加归并路数 `k`：** 可以在内存中同时合并更多的归并段，减少归并趟数，从而减少磁盘读写次数。但 `k` 受限于内存容量。
    *   **增加初始归并段长度：** 尽可能使每个初始归并段更长，减少初始归并段的数量，也能减少归并趟数。
    *   **I/O 缓冲区：** 为每个输入归并段和输出归并段设置缓冲区，减少频繁的磁盘读写。
4.  **败者树 (Loser Tree) / 胜者树 (Winner Tree)：** 为了在多路归并时高效地从 `k` 个归并段中选择下一个最小元素，可以采用败者树或胜者树进行优化，将选择操作的时间复杂度从 $O(k)$ 降低到 $O(\log k)$。
5.  **稳定性：** 如果要求外部排序结果稳定，则必须选择稳定的内部排序算法，并且归并过程也要是稳定的。
6.  **考点：** 外部排序通常以**概念选择题**或**简答题**形式出现，要求理解其基本原理、两阶段工作方式、如何优化 I/O (归并路数 `k`、初始归并段长度、缓冲区、败者树等)。对多路归并排序的 **时间复杂度计算** 也是重点。