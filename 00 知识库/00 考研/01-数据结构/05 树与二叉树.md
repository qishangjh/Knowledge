---
科目: "408"
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 05 树与二叉树
非线性数据结构
## 5.1 树的基本概念
### 1. 树的定义
#树
* **官方定义：** 树是N个结点的有限集合。
    * 当N=0时，称为空树。
    * 当N>0时，它满足以下条件：
        1. 有且仅有一个特定的结点被称为**根 (Root)**。
        2. 其余N-1个结点可以分成m个互不相交的有限集合 $T_1, T_2, …, T_m$，其中每个集合又都是一棵树，并且被称为根的**子树 (Subtree)**。

### 2. 基本术语
* **结点 (Node)：** 树中的每一个元素。
* **根结点 (Root Node)：** 树中最顶层的结点，没有父结点。
* **父结点 (Parent Node)：** 若一个结点有子结点，则这个结点是其子结点的父结点。
* **子结点 (Child Node)：** 若一个结点是另一个结点的子树的根，则这个结点是其父结点的子结点。
* **兄弟结点 (Sibling Node)：** 具有相同父结点的结点互为兄弟结点。
* **祖先结点 (Ancestor Node)：** 从根结点到该结点路径上的所有结点（不包括该结点本身）。
* **子孙结点 (Descendant Node)：** 以该结点为根的子树中的所有结点（不包括该结点本身）。

* **结点的度 (Degree of a Node)：** 一个结点拥有的子树的个数（或子结点的个数）。
* **树的度 (Degree of a Tree)：** 树中所有结点的度的最大值。
* **叶子结点 (Leaf Node) / 终端结点：** 度为0的结点（没有子结点）。
* **分支结点 (Branch Node) / 非终端结点：** 度不为0的结点（有子结点）。
* **层 (Level)：** 根结点在第1层，根的子结点在第2层，以此类推。
* **深度 (Depth)：** 结点的深度是从根结点到该结点的路径上的边数（或结点数-1）。根结点的深度为0（或1，取决于定义）。
* **高度 (Height)：** 树的高度是树中结点的最大深度加1（或最长路径上的结点数）。叶子结点的高度为1。
* **平衡因子**：`Height(左子树) - Height(右子树)`。
* **路径 (Path)：** 从一个结点到另一个结点之间所经过的结点序列。
* **路径长度：** 路径上边的数量。
* **森林 (Forest)：** m棵互不相交的树的集合。
* 有序树V.S无序树
    * **有序树**：逻辑上看，树中结点的各子树从左至右是有次序的，不能互换
    * **无序树**：逻辑上看，树中结点的各子树从左至右是无次序的，可以互换
### 3. 树的性质
![[5.1.3 树的性质.pdf#page=3&rect=124,276,840,456|5.1.3 树的性质, p.3]]
1. **结点数 = 总度数 + 1：** 树中所有结点的度数之和等于结点总数减1（因为除了根结点，每个结点都只有一条边指向它）。
2. **度为m的树中，第i层上最多有 $m^{i-1}$ 个结点。**
3. m叉树，第i层至多有$m^{i-1}$个结点
4. **高度为h的m叉树中，最多有 $\frac{m^h - 1}{m-1}$ 个结点。**
5. 高度为h的 m叉树至少有h个结点
6. 高度为h的 度为m的树至少有h+m-1个结点
7. **具有n个结点的m叉树的最小高度为 $\lceil log_m (n(m-1)+1) \rceil$。**

## 5.2 二叉树的概念
#二叉树
### 1. 二叉树的定义及其主要内容性质
* **定义：** 二叉树是N个结点的有限集合。
    * 当N=0时，称为空二叉树。
    * 当N>0时，它由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成。
* **与普通树的区别：**
    1. 每个结点最多只有两个子结点（左子结点和右子结点）。
    2. 子结点有左右之分，即使只有一个子结点，也要区分是左子结点还是右子结点。（有序树，左右节点不能颠倒）
* **五种基本形态：** 空二叉树、只有一个根结点、只有左子树、只有右子树、左右子树都有。
* **特殊二叉树类型 (重点！)：**
    1. **满二叉树 (Full Binary Tree)：**
        * **定义：** 除叶子结点外，所有结点都有两个子结点，且所有叶子结点都在同一层。
        * **特点：**
            * 树形最"饱满"，结点数最多。$2^{h}-1$个
            * 不存在度为1的结点
            * 按层序从1开始编号，结点i的左孩子为2i，右孩子为$2i+1$；结点i的父节点为$\frac{i}{2}$
    2. **完全二叉树 (Complete Binary Tree) (非常重要！)：**
        * **定义：** 除最后一层外，其余各层都是满的，并且最后一层从左到右依次填充的二叉树。 #完全二叉树
        * **特点：** 结点数达到最大值，且结点排列紧密。
        * **性质：**
            * 若对一棵有n个结点的完全二叉树的结点按层序编号（从1开始），则：
                * 若结点i有左孩子，则其左孩子为 $2i$。
                * 若结点i有右孩子，则其右孩子为 $2i+1$。
                * 若结点i的父结点为 $\lfloor i/2 \rfloor$。
                * 没有右孩子的结点是最后一个非叶子结点。
            * **重要应用：** 堆（Heap）就是一种完全二叉树，通常用数组存储。
    3. **二叉排序树 (Binary Search Tree / BST)：** #二叉排序树
        * 一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
            * 左子树上所有结点的关键字均小于根结点的关键字；
            * 右子树上所有结点的关键字均大于根结点的关键字。左子树和右子树又各是一棵二叉排序树。
    4. **平衡二叉树 (AVL Tree / Red-Black Tree)：**   #平衡二叉树
             左右子树的高度差的绝对值不超过1的二叉查找树（如 #AVL树 ）。
             特点：树的高度尽可能低，从而保证查找效率。
* **二叉树的重要性质 (必考！)：**
    1. 在二叉树的第 `i` 层上，最多有 $2^{i-1}$ 个结点（`i >= 1`）。
    2. 深度为 `k` 的二叉树，最多有 $2^k - 1$ 个结点。
    3. 对任何一棵非空二叉树，如果其叶子结点数为 $n_0$，度为2的结点数为 $n_2$，则有：**$n_0 = n_2 + 1$**。(这个性质非常重要，常考！)
    4. 具有 `n` 个结点的完全二叉树的深度为 $\lfloor log_2 n \rfloor + 1$。
### 2. 二叉树的存储结构
1. **顺序存储结构 (数组存储)：**
    * **原理：** 用一维数组按层序遍历的顺序存储二叉树的结点。
    * **适用范围：** 主要适用于**完全二叉树**。因为完全二叉树的结点排列紧密，不会浪费太多数组空间。
    * **优点：** 节省存储空间（不需要指针），可以快速定位父子结点。
    * **缺点：** 对于非完全二叉树，会浪费大量存储空间。插入和删除操作困难。
    * **考点：** 掌握完全二叉树在数组中的父子结点下标关系。

2. **链式存储结构 (二叉链表)：**
    * **原理：** 每个结点由数据域、左孩子指针和右孩子指针组成。
    * **C语言定义：**

  ```c
        typedef struct BiTNode {
            ElemType data;             // 数据域
            struct BiTNode *lchild;    // 左孩子指针
            struct BiTNode *rchild;    // 右孩子指针
        } BiTNode, *BiTree; // BiTNode是结点类型，BiTree是指向结点的指针类型
```

* **优点：** 灵活，适用于任意二叉树，插入和删除操作相对容易。
* **缺点：** 需要额外的空间存储指针，不如顺序存储紧凑。
* **考点：** 掌握二叉链表的定义和基本操作。

## 5.3 二叉树的遍历和线索二叉树
### 1. 二叉树的遍历
* **概念：** 二叉树的遍历 (Binary Tree Traversal)  按照某种次序访问二叉树中所有结点，且每个结点只访问一次。

### 2. 遍历的基本方法
* **先序 + 中序**可以唯一确定一棵二叉树。
* **中序 + 后序**可以唯一确定一棵二叉树。
* **先序 + 后序 不能**唯一确定一棵二叉树（除非是特殊情况，如只有单个节点或某些斜树）。
深度优先搜索 (DFS) vs. 广度优先搜索 (BFS)
*   **深度优先搜索 (DFS - Depth-First Search)**：
    *   思想：尽可能深地探索树的分支。
    *   实现：通常使用**递归**或**栈**来实现。
    *   包含：前序遍历、中序遍历、后序遍历。
*   **广度优先搜索 (BFS - Breadth-First Search)**：
    *   思想：先访问所有同一层的节点，再访问下一层。
    *   实现：通常使用**队列**来实现。
    *   包含：层序遍历。
#### A.深度优先搜索
##### 1. 先序遍历 (PreOrder Traversal)
**根 -> 左子树 -> 右子树** #先序遍历
* **应用：** 复制二叉树、构建表达式树。
*   **示例**：
```
          A
         / \
        B   C
       / \ / \
      D  E F  G
 ```
*   **遍历顺序**：`A -> B -> D -> E -> C -> F -> G`
  * 递归实现：
```c
void preorderTraversal(TreeNode* root) {
        if (root == NULL) { // 递归终止条件：节点为空
            return;
        }
        printf("%c ", root->data);      // 1. 访问根节点
        preorderTraversal(root->left);  // 2. 前序遍历左子树
        preorderTraversal(root->right); // 3. 前序遍历右子树
        }
```
*   **非递归实现 (使用栈)**：
```c
        void preorderTraversalIterative(TreeNode* root) {
            if (root == NULL) return;
            Stack s; // 假设有一个栈的数据结构
            initStack(&s);
            push(&s, root); // 根节点入栈

            while (!isEmpty(&s)) {
                TreeNode* current = pop(&s); // 弹出栈顶节点并访问
                printf("%c ", current->data);

                // 先将右子节点入栈，再将左子节点入栈
                // 这样左子节点会先被弹出，实现“根左右”
                if (current->right != NULL) {
                    push(&s, current->right);
                }
                if (current->left != NULL) {
                    push(&s, current->left);
                }
            }
        }
```
##### 2. 中序遍历 (InOrder Traversal)
**左子树 -> 根 -> 右子树** #中序遍历
* **应用：**   对于**二叉搜索树 (BST)**，中序遍历得到的是节点数据的**有序序列**。
```
          A
         / \
        B   C
       / \ / \
      D  E F  G
```
*   **遍历顺序**：`D -> B -> E -> A -> F -> C -> G

* **递归实现：**
 ```c
void inorderTraversal(TreeNode* root) {
    if (root == NULL) {
        return;
    }
    inorderTraversal(root->left);  // 1. 中序遍历左子树
    printf("%c ", root->data);      // 2. 访问根节点
    inorderTraversal(root->right); // 3. 中序遍历右子树
}
```
*   **非递归实现 (使用栈)**：
```c
void inorderTraversalIterative(TreeNode* root) {
    Stack s;
    initStack(&s);
    TreeNode* current = root;

    while (current != NULL || !isEmpty(&s)) {
        // 一直向左，并将沿途节点入栈
        while (current != NULL) {
            push(&s, current);
            current = current->left;
        }

        // 弹出栈顶节点（此时没有左子树了），访问它
        current = pop(&s);
        printf("%c ", current->data);

        // 转向右子树
        current = current->right;
    }
}
```

##### 3. 后序遍历 (PostOrder Traversal)
 **左子树 -> 右子树 -> 根** #后序遍历
```
          A
         / \
        B   C
       / \ / \
      D  E F  G
```
*   **遍历顺序**：`D -> E -> B -> F -> G -> C -> A`
*   **应用**：常用于计算二叉树高度、删除整棵树（先删除子节点，再删除父节点）。
*   **递归实现**：
```c
void postorderTraversal(TreeNode* root) {
    if (root == NULL) {
        return;
    }
    postorderTraversal(root->left);  // 1. 后序遍历左子树
    postorderTraversal(root->right); // 2. 后序遍历右子树
    printf("%c ", root->data);      // 3. 访问根节点
}
```

* **非递归实现 (使用栈)**：后序遍历的非递归实现相对复杂，通常需要一个额外的指针来记录上一个访问的节点，或者使用两个栈。
```c
        // 使用两个栈的实现思路 (S1用于正常入栈，S2用于存储逆序的后序遍历结果)
        void postorderTraversalIterativeTwoStacks(TreeNode* root) {
            if (root == NULL) return;
            Stack s1, s2;
            initStack(&s1);
            initStack(&s2);

            push(&s1, root); // 根节点入S1

            while (!isEmpty(&s1)) {
                TreeNode* current = pop(&s1); // 从S1弹出，立即压入S2
                push(&s2, current);

                // 先压左子节点，再压右子节点到S1
                // 这样S1弹出时先右后左
                if (current->left != NULL) {
                    push(&s1, current->left);
                }
                if (current->right != NULL) {
                    push(&s1, current->right);
                }
            }

            // 最终S2弹出的顺序就是后序遍历顺序
            while (!isEmpty(&s2)) {
                printf("%c ", pop(&s2)->data);
            }
        }
```
* **应用：** 常用于删除树或计算表达式树的高度等。

#### **B. 广度优先遍历 (BFS) 的一种方式**
##### **1. 层序遍历 (Level Order Traversal)**
*   **访问顺序**：
    1.  **从上到下**：先访问根节点。
    2.  **从左到右**：再访问根节点的左子节点，然后右子节点。
    3.  依此类推，访问完当前层的所有节点后，再访问下一层的所有节点。
*   **口诀**：**"一层一层，从左到右"**
*   **示例**：
```
          A
         / \
        B   C
       / \ / \
      D  E F  G
 ```
*   **遍历顺序**：`A -> B -> C -> D -> E -> F -> G`

*   **实现方式 (使用队列)**：

    ```c
    void levelorderTraversal(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        Queue q; // 假设有一个队列的数据结构
        initQueue(&q);
        enqueue(&q, root); // 根节点入队

        while (!isEmpty(&q)) {
            TreeNode* current = dequeue(&q); // 队头节点出队并访问
            printf("%c ", current->data);

            // 将当前节点的左子节点入队
            if (current->left != NULL) {
                enqueue(&q, current->left);
            }
            // 将当前节点的右子节点入队
            if (current->right != NULL) {
                enqueue(&q, current->right);
            }
        }
    }
    ```

---

#### **C. 遍历的时间复杂度和空间复杂度**

*   **时间复杂度**：对于任何一种遍历方式，每个节点都会被访问且只被访问一次。所以，如果二叉树有 $N$ 个节点，时间复杂度都是 $O(N)$。
*   **空间复杂度**：
    *   **递归实现**：取决于递归的深度，即树的高度 $H$。最坏情况下（链式树），$H=N$，空间复杂度为 $O(N)$。最好情况下（完全二叉树），$H=\log N$，空间复杂度为 $O(\log N)$。
    *   **非递归实现 (使用栈/队列)**：
        *   **深度优先 (栈)**：最坏情况下（链式树），栈的深度为 $N$，空间复杂度为 $O(N)$。最好情况下（完全二叉树），栈的深度为 $\log N$，空间复杂度为 $O(\log N)$。
        *   **广度优先 (队列)**：最坏情况下（满二叉树的最后一层，节点数最多），队列中可能存储 $N/2$ 个节点，空间复杂度为 $O(N)$。

---

### 2. 线索二叉树(Threaded Binary Tree)
#线索二叉树
*   **重点关注**：线索二叉树的基本概念和构造是近年来的热门考点。2010年和2014年都直接考察了定义和线索指向。
#### 1.1 线索二叉树的定义
*   **利用空指针**：设想能否利用这 $n+1$ 个空指针来存放指向其前驱或后继的指针，从而方便像遍历链表一样遍历二叉树。
*   **线索 (Thread)**：指向结点前驱或后继的指针。
*   **线索二叉树 (Threaded Binary Tree)**：在二叉树的二叉链表存储结构中，利用空指针域来存放指向结点在某种遍历次序下的**前驱或后继**的指针。

#### **1.2 结点结构**
*   为了区分指针域是指向孩子还是指向前驱/后继，需要增加**标志域**。
*   **存储结构**：
    ```c
    typedef struct ThreadNode {
        ElemType data;              // 数据元素
        struct ThreadNode *lchild, *rchild; // 左、右孩子指针
        int ltag, rtag;             // 左、右线索标志
    } ThreadNode, *ThreadTree;
    ```
*   **标志域含义**：
    *   `ltag = 0`：`lchild` 指向**左孩子**。
    *   `ltag = 1`：`lchild` 指向**前驱结点**。
    *   `rtag = 0`：`rchild` 指向**右孩子**。
    *   `rtag = 1`：`rchild` 指向**后继结点**。

#### **2. 线索化**
*   **目的**：将二叉链表中的空指针域改造为线索。
*   **实质**：通过**遍历**一次二叉树来建立前驱和后继信息。
*   **核心思想**：在遍历过程中，记录刚刚访问过的结点 `pre`，当前正在访问的结点 `p`。
    *   当 `p` 的 `lchild` 为空时，将其指向 `pre`（前驱线索）。
    *   当 `pre` 的 `rchild` 为空时，将其指向 `p`（后继线索）。

#### 2.1 中序线索二叉树
*   **中序遍历次序**：左子树 -> 根结点 -> 右子树。
*   **算法思路**：
    1.  用指针 `pre` 记录上一个访问的结点，`p` 为当前访问的结点。
    2.  中序遍历到 `p` 时，先处理 `p` 的左子树。
    3.  `p` 的左子树处理完后，`p` 的前驱就是 `pre`。如果 `p->lchild` 为空，则将其指向 `pre`，并设置 `p->ltag = 1`。
    4.  如果 `pre` 不为空且 `pre->rchild` 为空，则说明 `p` 是 `pre` 的后继，将 `pre->rchild` 指向 `p`，并设置 `pre->rtag = 1`。
    5.  更新 `pre = p`，即当前结点成为下一个结点的前驱。
    6.  处理 `p` 的右子树。

*   **递归算法示例（伪代码）**：
```c
    ThreadTree pre = NULL; // 全局或传入引用，记录前驱
    void InThread(ThreadTree p) {
        if (p != NULL) {
            InThread(p->lchild); // 递归线索化左子树

            // 处理当前结点 p
            if (p->lchild == NULL) { // p 的左孩子为空，建立前驱线索
                p->lchild = pre;
                p->ltag = 1;
            }
            if (pre != NULL && pre->rchild == NULL) { // pre 的右孩子为空，建立后继线索
                pre->rchild = p;
                pre->rtag = 1;
            }
            pre = p; // 标记当前结点 p 为下一个结点的前驱

            InThread(p->rchild); // 递归线索化右子树
        }
    }

    // 主函数调用
    void CreateInThread(ThreadTree T) {
        if (T != NULL) {
            InThread(T);
            // 处理中序序列中的最后一个结点的后继线索（它没有后继，通常设为NULL或指向头结点）
            pre->rchild = NULL; 
            pre->rtag = 1;
        }
    }
```
*   **带头结点的线索二叉树**：
    *   为了方便遍历，常引入一个头结点。
    *   **设置**：
        *   头结点的 `lchild` 指向二叉树的根结点。
        *   头结点的 `rchild` 指向中序遍历时访问的**最后一个结点**。
        *   二叉树中序序列的**第一个结点**的 `lchild` 指向头结点。
        *   二叉树中序序列的**最后一个结点**的 `rchild` 指向头结点。
    *   这样可以形成一个双向循环链表，使得遍历更方便。

#### **3.1 中序线索二叉树的遍历**
*   **核心思想**：先找到中序序列的第一个结点，然后不断找其后继，直到后继为空。
*   **1. 寻找中序序列的第一个结点 `FirstNode(p)`**：
    *   从 `p` 开始，沿着左孩子一直往下找，直到遇到 `ltag=1`（说明 `lchild` 指向前驱而不是左孩子）。
    *   这个结点就是中序序列的第一个结点（即最左下角的那个结点）。
* l
```c
    ThreadNode *FirstNode(ThreadNode *p) {
        while (p != NULL && p->ltag == 0) {
            p = p->lchild;
        }
        return p;
    }
```
*   **2. 寻找结点 `p` 在中序序列下的后继 `NextNode(p)`**：
    *   **情况1**：如果 `p->rtag == 1`（右指针是线索），则 `p->rchild` 直接指向其后继。
    *   **情况2**：如果 `p->rtag == 0`（右指针是右孩子），则 `p` 的后继是其右子树中第一个被访问的结点，即右子树的最左下角结点。需要调用 `FirstNode(p->rchild)`。
* l
```c
    ThreadNode *NextNode(ThreadNode *p) {
        if (p->rtag == 1) { // 右线索，直接返回后继
            return p->rchild;
        } else { // 有右孩子，找右子树的最左下结点
            return FirstNode(p->rchild);
        }
    }
```
*   **3. 中序遍历算法**：
```c
    void InorderTraverse(ThreadTree T) {
        for (ThreadNode *p = FirstNode(T); p != NULL; p = NextNode(p)) {
            visit(p); // 访问结点 p
        }
    }
 ```
*   **寻找中序序列的最后一个结点 `LastNode(p)`** (自行拓展)：
    *   与 `FirstNode` 类似，沿着右孩子一直往下找，直到遇到 `rtag=1`。
* l
```c
ThreadNode *LastNode(ThreadNode *p) {
      while (p != NULL && p->rtag == 0) {
        p = p->rchild;
    }
      return p;
}
```
*   **寻找结点 `p` 在中序序列下的前驱 `PreNode(p)`** (自行拓展)：
    *   **情况1**：如果 `p->ltag == 1`，则 `p->lchild` 直接指向其前驱。
    *   **情况2**：如果 `p->ltag == 0`，则 `p` 的前驱是其左子树中最后一个被访问的结点，即左子树的最右下角结点。需要调用 `LastNode(p->lchild)`。
* l
```c
ThreadNode *PreNode(ThreadNode *p) {
        if (p->ltag == 1) { // 左线索，直接返回前驱
            return p->lchild;
        } else { // 有左孩子，找左子树的最右下结点
            return LastNode(p->lchild);
        }
    }
```

#### **2.2 先序线索二叉树的构造**
![[05 树与二叉树-1763708979345.png|300]]
*   **先序遍历次序**：根结点 -> 左子树 -> 右子树。
*   **线索化逻辑变化**：在访问根结点时，即可确定其前驱（如果 `pre` 存在）。
    ```c
    ThreadTree pre = NULL;
    void PreThread(ThreadTree p) {
        if (p != NULL) {
            // 在访问 p 时处理 p 的前驱和 pre 的后继
            if (p->lchild == NULL) { 
                p->lchild = pre;
                p->ltag = 1;
            }
            if (pre != NULL && pre->rchild == NULL) { 
                pre->rchild = p;
                pre->rtag = 1;
            }
            pre = p; 

            // 注意：只有当 ltag == 0 时才递归左子树
            // 否则 p->lchild 已经指向前驱，不能再作为树的孩子指针
            if (p->ltag == 0) { // 只有左孩子是真的孩子才进入
                PreThread(p->lchild);
            }
            // 同样，只有当 rtag == 0 时才递归右子树
            if (p->rtag == 0) { // 只有右孩子是真的孩子才进入
                PreThread(p->rchild);
            }
        }
    }
    ```
    *   **关键区别**：先序遍历在访问当前结点时，就立即处理该结点的 `lchild` 和 `pre` 结点的 `rchild`（如果为空）。因此，递归调用左右子树时，需要先判断 `ltag` 和 `rtag` 是否为 `0`，避免将线索当成孩子指针再次遍历。

#### **2.3 后序线索二叉树的构造**

*   **后序遍历次序**：左子树 -> 右子树 -> 根结点。
*   **线索化逻辑变化**：在访问根结点时，其左右子树都已访问完毕。
```c
    ThreadTree pre = NULL;
    void PostThread(ThreadTree p) {
        if (p != NULL) {
            PostThread(p->lchild);
            PostThread(p->rchild);

            // 在访问 p 时处理 p 的前驱和 pre 的后继
            if (p->lchild == NULL) {
                p->lchild = pre;
                p->ltag = 1;
            }
            if (pre != NULL && pre->rchild == NULL) {
                pre->rchild = p;
                pre->rtag = 1;
            }
            pre = p; 
        }
    }
```
*   **关键区别**：与中序类似，线索化改造的代码段放在**左右子树递归调用之后**。

#### **3.2 先序线索二叉树的遍历**

*   **寻找结点 `x` 的后继**：
    1.  若 `x` 有左孩子 (`x->ltag == 0`)，则左孩子就是其后继。
    2.  若 `x` 无左孩子 (`x->ltag == 1`) 但有右孩子 (`x->rtag == 0`)，则右孩子就是其后继。
    3.  若 `x` 是叶结点 (`x->ltag == 1 && x->rtag == 1`)，则 `x->rchild` 直接指示其后继（线索）。
*   **复杂性**：需要注意处理优先级，先考虑真正的孩子，再考虑线索。

#### **3.3 后序线索二叉树的遍历**

*   **寻找结点 `x` 的后继**：
    1.  若结点 `x` 是二叉树的根，则其后继为空。
    2.  若结点 `x` 是其**双亲的右孩子**，或 `x` 是其**双亲的左孩子且其双亲没有右子树**，则 `x` 的后继即为其**双亲**。
    3.  若结点 `x` 是其**双亲的左孩子，且其双亲有右子树**，则 `x` 的后继为**双亲的右子树上按后序遍历列出的第一个结点**。
*   **复杂性**：后序遍历时找后继较为复杂，通常需要知道结点的**双亲信息**，可能需要采用**三叉链表**（增加父指针）作为存储结构，或者在遍历时利用栈来辅助。这也是后序线索二叉树不常用非递归遍历的原因之一。

---

## 5.4 树、森林
### 1. 树的存储结构
除了二叉树的存储，普通树也有几种存储方式：

1. **双亲表示法：** 每个结点存储其父结点的下标。
2. **孩子表示法：** 每个结点存储一个链表，链表中包含其所有孩子的指针。
3. **孩子兄弟表示法 (二叉链表表示法) (重要！)：**
    * **原理：** 将任意一棵树转换为一棵二叉树来存储。每个结点包含数据域、指向其**第一个孩子**的指针（`firstchild`）和指向其**右兄弟**的指针（`nextsibling`）。
    * **C语言定义：**

        ```c
        typedef struct CSNode { // Child-Sibling Node
            ElemType data;
            struct CSNode *firstchild; // 指向第一个孩子
            struct CSNode *nextsibling; // 指向右兄弟
        } CSNode, *CSTree;
        ```

    * **优点：** 方便将普通树的操作转换为二叉树的操作。
    * **考点：** 掌握其定义和转换原理。
### 2. 树、森林与二叉树的转换
![[考研学习笔记01-数据结构 05 树与二叉树 今天16_10.png]]
* **树转换为二叉树：**
    ![[考研学习笔记01-数据结构 05 树与二叉树 今天16_07.png]]
    * ①先在二叉树中，画一个根节点。
    * ②按"树的层序"依次处理每个结点。
        * 处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点 "用右指针串成糖葫芦"，并在二叉树中把第一个孩子挂在当前结点的左指针下方
* **森林转换为二叉树：** 将每棵树转换为二叉树后，再将这些二叉树的根结点用线连接起来。![[考研学习笔记01-数据结构 05 树与二叉树 今天16_04.png]]
    * ①先把所有树的根结点画出来，在二叉树中用右指针串成糖葫芦。
    * ②按"森林的层序"依次处理每个结点。
        * **处理一个结点的方法是**：如果当前处理的结点在树中有孩子，就把所有孩子结点"用右指针串成糖葫芦"，并在二叉树中把第一个孩子挂在当前结点的左指针下方
        * 森林中各棵树的根节点视为平级的兄弟关系
* **二叉树转换为树/森林：** 逆过程。

### 3. 树和森林的遍历
* **树的遍历：**
    * **先根遍历：** 访问根，再依次先根遍历其子树。
    * **后根遍历：** 依次后根遍历其子树，再访问根。
* **森林的遍历：**
    * **先序遍历森林：** 访问第一棵树的根，先序遍历第一棵树的子树森林，先序遍历除第一棵树外的森林。
    * **中序遍历森林：** 中序遍历第一棵树的左子树，访问第一棵树的根，中序遍历第一棵树的右子树。
* **考点：** 了解这些遍历方式。
---

## 5.5 树与二叉树的应用
### 1. 哈夫曼树 (Huffman Tree) 和哈夫曼编码 (Huffman Coding)
( #重要 #必考 )
* **概念：** #哈夫曼树 （Huffman Tree），又称**最优二叉树**，是**带权路径长度 (WPL)** 最短的二叉树。
	* **路径长度 ( $l_i$ )：** 从根结点到某结点 $i$ 的路径上**边的数量**（即结点的层次数减一）。
	* **结点的带权路径长度：** 结点权值 $w_i$ 与其路径长度 $l_i$ 的乘积 ($w_i \times l_i$)。
	* 树的带权路径长度 ( #WPL)：

	    $$WPL = \sum_{\text{所有叶子结点 } i} w_i \times l_i$$
		其中 $w_i$ 是第 $i$ 个叶结点的权值， $l_i$ 是该叶结点到根结点的路径长度（层次数 - 1）。
	    WPL 也是所有非叶子结点的权值之和。 (在构建过程中产生的中间权值之和。)
* **构建过程 (贪心算法)：**
	 1. **初始化：** 将所有权值作为 $n$ 棵独立的树（只有根结点）构成的森林。
	2. **合并循环：** 重复以下步骤，直到森林中只剩一棵树。
	    * **选取：** 每次从森林中选出**两棵**根结点权值最小的树 $T_1$ 和 $T_2$。
	    * **构造新树：** 将它们合并成一棵新树 $T_{\text{new}}$，新树的根结点权值 $W_{\text{new}}$ 为两棵树根结点权值之和 ($W_{\text{new}} = W_1 + W_2$)。$T_1$ 和 $T_2$ 分别作为 $T_{\text{new}}$ 的左右子树（左右顺序任意）。
	    * **入列：** 将 $T_{\text{new}}$ 重新加入森林。
	* **结果：** 构建过程是一个**自底向上**的过程，总是将权值最小的结点放在距离根最远的位置，从而确保 WPL 最小。
	* **非唯一性：** 哈夫曼树**不唯一**（合并时，左右子树的选择顺序或权值相同时的选取顺序不同），但**WPL 总是唯一的**。
* 1.3. 性质 (关键考点)
	1. **权值与深度：** 权值越小的叶子结点，其路径长度 $l_i$ **越大**（离根越远）。
	2. **树形：** 哈夫曼树中，没有度为 1 的结点（它必定是严格二叉树）。
	3. **叶结点：** 初始给定的 $n$ 个权值，最终都是哈夫曼树的**叶子结点**。
	4. **最优性：** 哈夫曼树的 WPL **最小**。
*  **1.4. 哈夫曼编码**
	* **概念：** 基于哈夫曼树生成的一种**变长编码**，用于数据压缩。
	* **生成规则：**
	    * 规定哈夫曼树中**左分支**编码为 **0**，**右分支**编码为 **1**。
	    * 从根结点到**叶子结点**的路径上所有分支码的序列即为该叶子结点（字符）的编码。
	* **核心特点：** 是一种**前缀码 (Prefix Code)**。
	    * **前缀码定义：** 任何一个字符的编码都不是另一个字符编码的**前缀**。
	    * **保证：** 保证了在译码时，**编码的唯一性**，避免歧义。
* **1.5. 广义哈夫曼树 (k 叉哈夫曼树)**
	* **概念：** 将每次合并 $k$ 棵权值最小的子树，生成一棵 $k$ 叉最优树。
	* **应用：** 主要用于解决 $k$ 叉最优树问题（如**问题 4**）。
	* 必要条件 (关键)： 为了保证最终能合并成一棵树，叶子结点的总数 $n$ 必须满足：
	    $$n = k + m(k-1) \quad (\text{其中 } m \ge 0 \text{ 为合并次数})$$
	    * 当 $n$ 不满足此条件时，需要添加 $d$ 个**权值为 0 的虚结点**。
	    * 所需的虚结点数 $d$ 使得 $(n+d-1) \pmod {k-1} = 0$，且 $d$ 最小。
	    * **对于三叉树 ($k=3$)：** $n$ 必须是 $2m+1$ 的形式（奇数）。若 $n=6$ (偶数)，则需要添加 $d=1$ 个虚结点，使 $n'=7$。
### 2. 并查集 (Disjoint Set Union / DSU)
* **概念：** 一种用于处理不相交集合（或称并查集）的数据结构(逻辑结构) #并查集 ，支持两种操作：
    * **Union (合并)：** 合并两个不相交的集合。 #Union
    * **Find (查找)：** 查找某个元素所在的集合的代表元素（根）。 #Find （根一样就是一个集合）
* **实现：** 通常用**树形结构**（数组表示）来实现，#双亲表示法 每个元素存储其父结点的下标。
* **优化：**
    * **路径压缩：** 在Find操作时，将路径上的所有结点直接指向根结点。
    * **按秩合并（或按大小合并）：** 合并时，将较小的树连接到较大的树的根上，以保持树的平衡。
* **应用：** 解决连通性问题（如判断图中是否有环）、最小生成树（Kruskal算法）。
* **考点：** **并查集的基本概念、Union和Find操作的原理、路径压缩和按秩合并的优化。**

---
