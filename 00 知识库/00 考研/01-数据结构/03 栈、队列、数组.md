---
科目: "408"
课程名称: 数据结构
tags: ["#栈", 队列, 数组]
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 03 栈、队列、数组

## 03-1 栈
### 1. 栈(stack)的基本概念
**线性表**是具有相同数据类型的n(n≥0)个数据的有限序列，其中n为表长，当n=0时，线性表是一个空表，若用L命名线性表，则一般表示为：$$L=(a_1,a_2,…,a_i,a_{i+1},…,a_n)$$

> [!info] 定义
> **栈**是只允许在一端进行插入或删除操作的线性表 #栈

**栈顶**: 允许插入和删除的一端
**栈底**: 不允许插入和删除的一端
**空栈**: no元素的空表

> [!note] 线性表的基本操作
> **initlist(&L)** : 初始化表 (构造一个空的线性表L,分配内存空间.)
> **DestoryList(&L)** : 销毁操作 (销毁线性表,并释放线性表L所占用的内存空间)
>
> **Listinsert(&L,i,e)** : 插入操作 (在表L中的第i个位置上插入指定元素e)
> **ListDelet(&L,i,&e)** : 删除操作 (删除表L中第i个位置的元素,并用e返回删除元素的值)
>
> **LocateElem(L,e)** : 按值查找操作 (在表L中查找具有给定关键字值的元素)
> **GetElem(L,i)** : 按位查找操作 (获取表L中第i个位置的元素的值)
>
> 其他常用操作：
> **Length(L)** : 求表长 (返回线性表L的长度，即L中数据元素的个数)
> **PrintList(L)** : 输出操作 (按前后顺序输出线性表L的所有元素值)
> **Empty(L)** : 判空操作 (若L为空表，则返回true，否则返回false)

> [!note] 栈的基本操作
> **InitStack(&S)**：初始化栈。构造一个空栈 S，分配内存空间。
> **DestroyStack(&S**)：销毁栈。销毁并释放栈 S 所占用的内存空间。
>
> **Push(&S,x)**：进栈，若栈S未满，则将x加入使之成为新栈顶。
> **Pop(&S,&x)**：出栈，若栈S非空，则弹出栈顶元素，并用x返回。
>
> **GetTop(S, &x)**：读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素
>
> 其他常用操作：
> **StackEmpty(S)**：判断一个栈 S 是否为空。若S为空，则返回true，否则返回false。

> [!question]  常考题型
> 有哪些合法的出栈顺序？
>
> n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C^n_{2n}$。
> **↑卡特兰(Catalan)数**，可采用数学归纳法证明

****
### 2. 栈的顺序存储结构
采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底栈顶的数据元素，同时附设一个指针(top)指示当前栈的元素
![[3.1.2 栈的顺序存储实现 .pdf#page=3&rect=70,228,720,461|3.1.2_栈的顺序存储实现_已解密, p.3]]

**初始化**：

```c 
	void InitStack(SqStack &S){  
	    S.top=-1;  //初始化栈顶指针  
	}  
	void teststack() {  
	    SqStack S; //声明一个顺序栈（分配空间）  
	}  
	```  

**判断空**  ：
```c
bool stackempty(Sqstack S){
	if(S.top==-1)  //栈空
		return true;
	else  //不空
		return false;
}
```

**入栈**：

```c
	bool Push(SqStack &S,ElemType x){  
		if(S.top==MaxSize-1) //栈满，报错  
			return false;  

		S.top = S.top +1;  
		S.data[S.top] = x;  
		return true  
	}  
	```  

**出栈**  ：
```c
bool Pop(Sqtack &S,elemtype &x) {
	if(S.top==-1)
		return false;
	x=S.data[S.top--];
	return true;
}
```

**读栈顶元素**：

```c
bool gettop(SqStack S,Elemtype &x){
	if(S.top==-1) //栈空
		return false;
	x=S.data[S.top]; //x 记录栈顶元素
	return true；
}
```

**共享栈**：两个栈共享同一片空间

---
### 3. 栈的链式存储结构
**链栈**：便于多个栈共享存储空间和提高效率

![[3.1.3_栈的链式存储实现_已解密.pdf#page=3&rect=64,43,845,307|3.1.3_栈的链式存储实现_已解密, p.3]]

---
## 03-2 队列
### 基本概念
队列Queue 是只允许在一端进行插入，在另一端删除的线性表

![[3.2.1 队列的基本概念.pdf#page=5&rect=82,114,736,331|3.2.1_队列的基本概念_已解密, p.5]]
特点：先进先出

基本操作：
**InitQueue(&Q)**: 初始化队列，构造一个空队列Q。
**DestroyQueue(&Q)**: 销毁队列。销毁并释放队列Q所占用的内存空间。

**EnQueue(&Q,x)**:入队，若队列Q未满，将x加入，使之成为新的队尾
**DeQueue(&Q,&x)**:出队，若队列Q非空，删除对头元素，并用x返回。

**GetHead(Q,&x)**: 读对头元素，若队列Q非空，则将对头元素赋值给x。

**QueueEmpty(Q)**:判断队空，若队列Q为空返回true，否则返回false。

### 队列顺序存储结构
**队首指针**：front
**队尾指针**：rear 指向队尾的下一个位置

```c
#define Maxsize
typedef struct{
ElemType data[MaxSize];
int front,rear;
} SqQueue;

//初始化队列
void testQueue(){
SqQueue Q; 声明一个队列
//后续操作

void InitQueue(SqQueue &Q){
//初始时 队头、队尾指针指向0
Q.rear=Q.front =0;
}

void testQueue(){
	//声明一个队列（顺序存储）
	SqQueue Q;
	InitQueue(Q);
}

//判断队列是否为空
bool QueueEmpty(SqQueue Q){
	if(Q.rear==Q.front) //队空
		return true;
	else
		return false;
}

//入队
bool EnQueue(SqQueue &Q,ElemType x){
	if(队列已满)
		return false;
	Q.data[Q.rear]=x;
	Q.rear=(Q.rear+1)%Maxsize;   
	return true;
}

//循环队列
//入队
bool EnQueue(SqQueue &Q,ElemType x){
	if((Q.rear+1)%MaxSize==Q.front)
		return false;
	Q.data[Q.rear]=x;
	q.rezr=(Q.rear+1)%MaxSize;
	return true;
}

//出队（删除一个对头元素，并用x返回）
bool DeQueue(Sequeue &Q,ElemType &x){
	if(Q.rear==Q.front)
			return false;//队空则报错
	x=Q.data[Q.front];
	Q.front=(Q.front+1)%MaxSize;
	return true;
	}

//获得对头元素的值，用x返回
bool GetHead(SqQueue Q,EleType &x){
	if(Q.rear==Q.front)
		return false;
	x=Q.data[Q.front];
	return true;
}
```

### 队列链式存储

```c
typedef struct LinkNode{ //链式队列结点
	ElemType data;
	struct LinkNode *next;
}LinkNode;

typedef struct{ //链式队列
	LinkNode *front,*rear; //队列的队头和队尾指针
}LinkQueue;

//初始化队列（带头节点）
void InitQueue(LinkQueue &Q){
	//初始时 front、rear 都指向头结点
	Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
	Q.front->next=NULL;
}

void testLinkQueue(){
	LinkQueue Q; //声明一个队列
	InitQueue(Q); //初始化队列
}

//判断队列是否为空
bool IsEmpty(LinkQueue Q){
	if(Q.front==Q.rear)
		return true;
	else
		return false;
}

//初始化队列(不带头结点)
void InitQueue(LinkQueue &Q){
	//初始时 front、rear 都指向NULL
	Q.front=NULL;
	Q.rear=NULL;
}
//判断队列是否为空（不带头结点）
bool IsEmpty(LinkQueue Q){
	if(Q.front==NULL)
		return true;
	else
		return false;
}

//入队（带头结点）
void EnQueue(LinkQueue &Q,ElemType x){
	LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;
	s->next=NuLL;
	Q.rear->next=s;
	Q.rear=s;
}
//入队（不带头结点）

//出队（带头结点）

//出队（不带头结点）

```

### 双端队列

### 考点：判断输出序列合法性

> [!question|] [[3.2.4 双端队列.pdf#page=4&selection=4,0,7,20&color=yellow|3.2.4 双端队列, p.4]]
>
> > 若数据元素输入序列为 1,2,3,4，则哪些输出序列是合法的，哪些是非法的？

---

## 03-3 栈和队列的应用 #常考
### **1. 栈的括号匹配**
**问题描述：**
给定一个字符串，判断其中的括号（如圆括号 `()`、方括号 `[]`、花括号 `{}`）是否匹配。

**算法思路：**
1. 使用一个栈来存储左括号。
2. 遍历字符串：
   - 如果遇到左括号，将其压入栈中。
   - 如果遇到右括号，检查栈顶元素是否是对应的左括号。如果是，则弹出栈顶元素；否则，返回不匹配。
3. 最后，如果栈为空，说明所有括号都匹配；否则，返回不匹配。

```c
void test(){
	int a[10][10];
	int x=10*(20*(1+1)-(3-2))
	printf("加油！");
}
```

> [!PDF|yellow] [[3.3.1 栈在括号匹配中的应用.pdf#page=3&selection=33,0,35,1&color=yellow|3.3.1_栈在括号匹配中的应用_已解密, p.3]]
>
> > 最后出现的左括号最先被匹配（LIFO）
> > 每出现一个右括号，就 "消耗"一个左括号

> [!PDF] [[3.3.1 栈在括号匹配中的应用.pdf#page=4&selection=34,0,35,17&color=yellow|3.3.1_栈在括号匹配中的应用_已解密, p.4]]
>
> > 遇到左括号就入栈
> > 遇到右括号，就 "消耗"一个左括号
> > ![[3.3.1 栈在括号匹配中的应用.pdf#page=9&rect=14,1,524,460&color=yellow|3.3.1_栈在括号匹配中的应用_已解密, p.9]]![[3.3.1 栈在括号匹配中的应用.pdf#page=9&rect=513,83,950,459&color=yellow|3.3.1_栈在括号匹配中的应用_已解密, p.9]]

> [!PDF] [[3.3.1 栈在括号匹配中的应用.pdf#page=10&selection=7,0,8,20&color=yellow|3.3.1_栈在括号匹配中的应用_已解密, p.10]]
> 匹配失败情况：①左括号单身②右括号单身③左右括号不匹配

**示例代码：**

```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

bool isMatching(char *str) {
    int top = -1;
    char stack[100];  // 假设字符串长度不超过100

    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == '(' || str[i] == '[' || str[i] == '{') {
            stack[++top] = str[i];
        } else if (str[i] == ')' || str[i] == ']' || str[i] == '}') {
            if (top == -1) return false;

            char topChar = stack[top--];
            if ((str[i] == ')' && topChar != '(') ||
                (str[i] == ']' && topChar != '[') ||
                (str[i] == '}' && topChar != '{')) {
                return false;
            }
        }
    }

    return top == -1;
}

int main() {
    char str1[] = "(([]))";
    char str2[] = "([)]";

    printf("String 1: %s, Matching? %s\n", str1, isMatching(str1) ? "Yes" : "No");
    printf("String 2: %s, Matching? %s\n", str2, isMatching(str2) ? "Yes" : "No");

    return 0;
}
```

### **2. 栈在表达式求值中的应用**
**表达式求值问题：**
将一个中缀表达式转换为后缀表达式（逆波兰表达式），然后计算其值。

**三种算术表达式：**
- #中缀表达式 ：操作符在操作数之间，如 `A + B * C`。（常说的算术表达式）
- #前缀表达式 ：操作符在操作数之前，如 `+ A * B C`。
- #后缀表达式 ：操作符在操作数之后，如 `A B C * +`。

**中缀表达式转后缀表达式：**
手算：
1. 按照运算符的运算顺序对所有运算单位加括号
2. 将运算符号移至对应括号的后面
3. 去除所有的括号

计算器：
1. 使用两个栈，一个用于存储操作数，另一个用于存储操作符。
2. 遍历中缀表达式：
   - 如果是操作数，直接输出。
   - 如果是操作符，与栈顶的操作符比较优先级，将优先级高的操作符弹出并输出，直到栈顶操作符的优先级低于当前操作符，然后将当前操作符压入栈中。
   - 如果是左括号，直接压入栈中。
   - 如果是右括号，弹出栈顶操作符并输出，直到遇到左括号。
3. 最后，将栈中剩余的操作符依次弹出并输出。

**后缀表达式 求值：**
1. 使用一个栈。
2. 遍历后缀表达式：
   - 如果是操作数，压入栈中。
   - 如果是操作符，从栈中弹出两个操作数，进行运算，将结果压入栈中。
3. 最后，栈中剩下的唯一元素即为表达式的值。

**示例代码：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#define MAX_SIZE 100

typedef struct {
    char data[MAX_SIZE];
    int top;
} Stack;

void initStack(Stack *s) {
    s->top = -1;
}

bool isEmpty(Stack *s) {
    return s->top == -1;
}

bool isFull(Stack *s) {
    return s->top == MAX_SIZE - 1;
}

void push(Stack *s, char c) {
    if (!isFull(s)) {
        s->data[++(s->top)] = c;
    }
}

char pop(Stack *s) {
    if (!isEmpty(s)) {
        return s->data[(s->top)--];
    }
    return '\0';
}

char top(Stack *s) {
    if (!isEmpty(s)) {
        return s->data[s->top];
    }
    return '\0';
}

int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

void infixToPostfix(char *infix, char *postfix) {
    Stack s;
    initStack(&s);
    int i = 0, j = 0;

    while (infix[i] != '\0') {
        if (isalnum(infix[i])) {
            postfix[j++] = infix[i++];
        } else if (infix[i] == '(') {
            push(&s, infix[i++]);
        } else if (infix[i] == ')') {
            while (top(&s) != '(') {
                postfix[j++] = pop(&s);
            }
            pop(&s);  // Pop the '('
            i++;
        } else {
            while (!isEmpty(&s) && precedence(infix[i]) <= precedence(top(&s))) {
                postfix[j++] = pop(&s);
            }
            push(&s, infix[i++]);
        }
    }

    while (!isEmpty(&s)) {
        postfix[j++] = pop(&s);
    }
    postfix[j] = '\0';
}

int evaluatePostfix(char *postfix) {
    Stack s;
    initStack(&s);

    for (int i = 0; postfix[i] != '\0'; i++) {
        if (isdigit(postfix[i])) {
            push(&s, postfix[i] - '0');
        } else {
            int val2 = pop(&s);
            int val1 = pop(&s);
            switch (postfix[i]) {
                case '+': push(&s, val1 + val2); break;
                case '-': push(&s, val1 - val2); break;
                case '*': push(&s, val1 * val2); break;
                case '/': push(&s, val1 / val2); break;
            }
        }
    }

    return pop(&s);
}

int main() {
    char infix[100], postfix[100];
    printf("Enter an infix expression: ");
    scanf("%s", infix);

    infixToPostfix(infix, postfix);
    printf("Postfix expression: %s\n", postfix);

    int result = evaluatePostfix(postfix);
    printf("Result: %d\n", result);

    return 0;
}
```

### **3. 栈在递归中的应用**

递归调用可以使用栈来模拟。每次函数调用时，将参数和局部变量压入栈中；函数返回时，从栈中弹出这些信息。

**示例：使用栈模拟递归计算阶乘**

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

void initStack(Stack *s) {
    s->top = -1;
}

bool isEmpty(Stack *s) {
    return s->top == -1;
}

bool isFull(Stack *s) {
    return s->top == MAX_SIZE - 1;
}

void push(Stack *s, int n) {
    if (!isFull(s)) {
        s->data[++(s->top)] = n;
    }
}

int pop(Stack *s) {
    if (!isEmpty(s)) {
        return s->data[(s->top)--];
    }
    return -1;
}

int factorial(int n) {
    Stack s;
    initStack(&s);
    int result = 1;

    push(&s, n);

    while (!isEmpty(&s)) {
        int current = pop(&s);
        if (current == 0) {
            continue;
        } else {
            result *= current;
            push(&s, current - 1);
        }
    }

    return result;
}

int main() {
    int n;
    printf("Enter a number: ");
    scanf("%d", &n);

    int result = factorial(n);
    printf("Factorial of %d is %d\n", n, result);

    return 0;
}
```

### **4. 栈在计算机系统中的应用**

- **函数调用栈**：用于管理函数调用的上下文。
- **浏览器的前进/后退功能**：使用两个栈来管理历史记录。
- **表达式求值**：如前面提到的括号匹配和表达式求值。
- **操作系统中的任务调度**：某些调度算法可能使用栈来管理任务。

## 03-4 数组和特殊矩阵

### 1. 数组的定义

数组是一种线性数据结构，它由相同类型的元素组成，这些元素在内存中连续存储。数组的每个元素可以通过索引访问。

### 2. 数组的存储结构
- **一维数组**：在内存中连续存储。
- **二维数组**：有两种存储方式：
  - **行优先顺序**：先存储第一行的所有元素，再存储第二行的所有元素，依此类推。
  - **列优先顺序**：先存储第一列的所有元素，再存储第二列的所有元素，依此类推。

### 3. 特殊矩阵的压缩存储
#压缩存储
- **对称矩阵**：只存储下三角或上三角部分。
- **三角矩阵**：只存储上三角或下三角部分。
- **稀疏矩阵**：只存储非零元素及其位置。

**对称矩阵**是指一个矩阵，其元素满足 `a[i][j] = a[j][i]` 的性质。也就是说，矩阵关于主对角线对称。
![[6.2.1 邻接矩阵法.pdf#page=9&rect=57,28,930,454|6.2.1 邻接矩阵法, p.9]]
1. **存储下三角部分**
我们可以将对称矩阵的下三角部分（包括主对角线）存储在一个一维数组中。具体来说，对于一个 `n x n` 的对称矩阵 `A`，我们可以将其下三角部分存储在一维数组 `B` 中。

假设 `A` 是一个 `n x n` 的对称矩阵，`B` 是一个一维数组，那么 `A[i][j]` 在 `B` 中的位置可以通过以下公式计算：
- 如果 `i >= j`，则 `B[k]` 对应 `A[i][j]`，其中 `k = i * (i + 1) / 2 + j`。
- 如果 `i < j`，则 `B[k]` 对应 `A[j][i]`，其中 `k = j * (j + 1) / 2 + i`。

2. **存储上三角部分****
类似地，我们也可以将对称矩阵的上三角部分（包括主对角线）存储在一个一维数组中。假设 `A` 是一个 `n x n` 的对称矩阵，`B` 是一个一维数组，那么 `A[i][j]` 在 `B` 中的位置可以通过以下公式计算：
- 如果 `i <= j`，则 `B[k]` 对应 `A[i][j]`，其中 `k = j * (j + 1) / 2 + i`。
- 如果 `i > j`，则 `B[k]` 对应 `A[j][i]`，其中 `k = i * (i + 1) / 2 + j`。

```c
#include <stdio.h>

#define N 3  // 矩阵的大小

// 计算下三角部分的索引
int get_index(int i, int j) {
    if (i >= j) {
        return i * (i + 1) / 2 + j;
    } else {
        return j * (j + 1) / 2 + i;
    }
}

//1. 定义矩阵和一维数组
int main() {
    // 原始对称矩阵  
    int A[N][N] = {
        {1, 2, 3},
        {2, 4, 5},
        {3, 5, 6}
    };

    // 一维数组用于存储下三角部分
    int B[N * (N + 1) / 2];

// 2. 计算索引：
    // 将对称矩阵的下三角部分存储到一维数组中
    for (int i = 0; i < N; i++) {
        for (int j = 0; j <= i; j++) {
            B[get_index(i, j)] = A[i][j];
//`get_index` 函数用于计算 `A[i][j]` 在 `B` 中的索引。
        }
    }

    // 打印一维数组
    //使用双重循环遍历矩阵的下三角部分，并将元素存储到 `B` 中。
    printf("Compressed array B: ");
    for (int i = 0; i < N * (N + 1) / 2; i++) {
        printf("%d ", B[i]);
    }
    printf("\n");

    // 从一维数组中读取并打印原始矩阵
    printf("Original matrix A:\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", B[get_index(i, j)]);
        }
        printf("\n");
    }

    return 0;
}
```

### 4. 稀疏矩阵

稀疏矩阵是指矩阵中大部分元素为0的矩阵。为了节省存储空间，可以只存储非零元素及其位置。

**三元组表示法**：
- 每个非零元素用一个三元组 `(i, j, value)` 表示，其中 `i` 和 `j` 是元素的位置，`value` 是元素的值。
- 三元组按行优先顺序存储。

**示例代码：**

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int row;
    int col;
    int value;
} Triple;

typedef struct {
    Triple data[MAX_SIZE];
    int rows;
    int cols;
    int nums;
} SparseMatrix;

void createSparseMatrix(SparseMatrix *sm, int rows, int cols) {
    sm->rows = rows;
    sm->cols = cols;
    sm->nums = 0;
}

void insertElement(SparseMatrix *sm, int row, int col, int value) {
    if (sm->nums < MAX_SIZE) {
        sm->data[sm->nums].row = row;
        sm->data[sm->nums].col = col;
        sm->data[sm->nums].value = value;
        sm->nums++;
    }
}

void printSparseMatrix(SparseMatrix *sm) {
    printf("Sparse Matrix:\n");
    for (int i = 0; i < sm->nums; i++) {
        printf("(%d, %d, %d)\n", sm->data[i].row, sm->data[i].col, sm->data[i].value);
    }
}

int main() {
    SparseMatrix sm;
    createSparseMatrix(&sm, 3, 3);

    insertElement(&sm, 0, 0, 1);
    insertElement(&sm, 1, 1, 2);
    insertElement(&sm, 2, 2, 3);

    printSparseMatrix(&sm);

    return 0;
}
```
