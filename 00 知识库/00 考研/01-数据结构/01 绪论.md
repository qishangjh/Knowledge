---
科目: "408"
课程名称: 数据结构
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度: 4
考频: -39
备注:
---

# 01 绪论
## 1.1 数据结构的基本概念

### 1. 数据结构在学什么？
#### 核心目标
- **信息化**：将现实世界问题转化为计算机可处理的信息
- **高效处理**：通过优化数据组织方式提升计算效率

```mermaid
graph LR
A[现实问题] --> B[数据结构设计]
B --> C[信息化表示]
C --> D[算法处理]
D --> E[价值创造]
```

#### 信息化案例
| 场景       | 信息化手段                | 数据结构应用          |
| :--------- | :------------------------ | :-------------------- |
| 排队系统   | 队列(Queue)               | 顺序存储/链式存储     |
| 社交网络   | 图(Graph)                 | 邻接表/邻接矩阵       |
| 文件系统   | 树(Tree)                  | 多叉树/B+树           |

---

### 2. 基本概念
#### 核心术语对比
| 概念         | 定义                          | 示例                          |
| :----------- | :---------------------------- | :---------------------------- |
| **数据**     | 信息的载体（数字/字符等）     | `int a = 10;`                 |
| **数据元素** | 数据的基本单位                | 结构体`Student{name, age}`    |
| **数据项**   | 数据元素的不可分割最小单位    | `name`或`age`                 |
| **数据对象** | 相同性质数据元素的集合        | 所有`Student`实例的集合       |

#### 数据类型

##### 1. 数据类型定义
**数据类型 = 值的集合 + 值的操作集合**
描述数据在内存中的存储格式与可进行的运算规则

##### 2. 数据类型层次体系

###### 2.1 原子类型（基本类型）
| 类型       | 存储空间 | 取值范围               | 典型操作             |
| :--------- | :------- | :--------------------- | :------------------- |
| **int**    | 4字节    | -2³¹ ~ 2³¹-1          | `+ - * / %`          |
| **float**  | 4字节    | ±3.4e-38 ~ ±3.4e38    | 浮点运算             |
| **char**   | 1字节    | ASCII字符（0-255）     | 字符处理             |
| **bool**   | 1字节    | true/false             | 逻辑运算             |

###### 2.2 结构类型（复合类型）
| 类型          | 内存布局                     | 特点                       | 典型应用场景       |
| :------------ | :--------------------------- | :------------------------- | :----------------- |
| **数组**      | 连续内存空间                 | 同类型元素集合             | 矩阵存储           |
| **结构体**    | 按成员声明顺序存储           | 异构数据聚合               | 学生信息记录       |
| **联合体**    | 共享内存空间                 | 同一时间只存储一个成员     | 类型转换           |
| **枚举**      | 整型常量集合                 | 增强可读性                 | 状态机定义         |

---

#### 3. 抽象数据类型（ADT）

##### 3.1 ADT三要素
$$
ADT = \text{逻辑结构} + \text{数据关系} + \text{基本操作}
$$
或
$$
ADT = \text{逻辑结构} + \text{数据运算}
$$
- **逻辑结构**：数据元素间的关系（集合/线性/树/图）
- **数据运算**：插入、删除、查找等操作

##### 3.2 ADT实现示例
**栈（Stack）的ADT定义**：

```c
ADT Stack {
    数据对象：D = { a_i | a_i ∈ ElemType, i=1,2,…,n }
    数据关系：R = { <a_{i-1},a_i> | a_{i-1},a_i ∈ D } // 后进先出关系
    基本操作：
        InitStack(&S)    // 初始化栈
        Push(&S, e)      // 入栈
        Pop(&S, &e)      // 出栈
        GetTop(S, &e)    // 获取栈顶元素
        StackEmpty(S)    // 判空
}
```

---

### 3. 数据结构三要素 🧩
#### 数据的逻辑结构
指数据元素之间的逻辑关系。

| 类型   | 特点        | 应用场景          |
| :----- | :---------- | :---------------- |
| 集合   | 元素间无特定关系  | 哈希表           |
| 线性结构 | 一对一（前驱后继） | 数组/链表/队列/栈 |
| 树形结构 | 一对多（层次关系） | 文件系统/组织结构图 |
| 图结构  | 多对多（复杂关系） | 社交网络/交通路线   |

#### 数据的存储结构
指数据结构在计算机中的表示，包括数据元素的表示和关系。

| 存储方式 | 特点           | 典型操作及时间复杂度 |
| :------- | :------------- | :----------------- |
| 顺序存储 | 物理位置连续（数组）   | 随机访问$O(1)$      |
| 链式存储 | 指针链接（链表）     | 插入/删除$O(1)$     |
| 索引存储 | 索引表+数据块（数据库） | 查找$O(\log n)$     |
| 散列存储 | 哈希函数映射（哈希表）  | 理想情况$O(1)$      |

> 后三种统称非顺序存储

> [!tip] 存储结构影响
> 1. 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上可以是离散的。
> 2. 数据的存储结构会影响存储空间分配的方便程度。
> 3. 数据的存储结构会影响对数据运算的速度。

#### 数据的运算
对数据结构进行的操作，如插入、删除、查找、遍历等。

---
## 1.2 算法和算法评价

### 1. 算法的基本概念
程序 = 数据结构 + 算法
算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。

#### 算法的特性
1.  **有穷性**：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2.  **确定性**：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
3.  **可行性**：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
4.  **输入/输出**：至少0个输入，至少1个输出。

#### 好算法特质
| 特质    | 说明           | 示例                 |
| :------ | :------------- | :------------------- |
| **正确性** | 解决问题无错误    | 排序算法输出有序       |
| **可读性** | 代码清晰易理解    | 添加注释/模块化设计     |
| **健壮性** | 处理非法输入     | 输入校验机制         |
| **高效低存储** | 时间/空间复杂度优化 | 快速排序 vs 冒泡排序 |

---

### 2. 算法的时间复杂度与空间复杂度 #必考

#### 核心思想：衡量算法效率的"双刃剑"
- **时间复杂度 (Time Complexity)**：衡量算法**执行时间**随着输入规模增长的趋势。
- **空间复杂度 (Space Complexity)**：衡量算法**额外占用存储空间**随着输入规模增长的趋势。

> [!important] 大 O 符号 (Big O Notation)
> 统一的表示方法，只关注增长趋势，忽略常数项和低阶项。
> - **记作**：$O(f(n))$
> - **含义**：当 `n` 足够大时，算法的执行时间/额外空间不会超过 `f(n)` 的某个倍数。它是一个 "上限" 的描述。

#### 时间复杂度分析
##### 计算步骤
1.  **找到基本操作 (Basic Operation)**：算法中最核心的、执行次数最多的那条语句（通常在最深层循环/递归中）。
2.  **计算基本操作的执行次数**：分析基本操作执行次数与输入规模 $n$ 之间的函数关系 $T(n)$。
3.  **使用大 O 符号简化 $T(n)$**：
    -   **忽略常数项**：如 $3n+2 \Rightarrow O(n)$。
    -   **忽略低阶项**：如 $2n^2+5n+100 \Rightarrow O(n^2)$。
    -   **只保留最高阶项的系数为 1**：如 $5n^3 \Rightarrow O(n^3)$。

##### 常见时间复杂度对比 (从慢到快)
#时间复杂度

| 复杂度        | 示例算法           | 增长趋势         |
| :------------ | :----------------- | :--------------- |
| $O(n^n)$      |                  | 超多项式爆炸     |
| $O(n!)$       |                  | 阶乘爆炸         |
| $O(2^n)$      | #汉诺塔问题/斐波那契递归 | 指数爆炸         |
| $O(n^3)$      | 三个嵌套循环       | 立方增长         |
| $O(n^2)$      | #冒泡排序/两个嵌套循环 | 平方增长         |
| $O(n \log n)$ | #快速排序/#归并排序 | 线性对数增长     |
| $O(n)$        | #线性遍历          | 线性增长         |
| $O(\log n)$   | #二分查找          | 对数增长         |
| $O(1)$        | 数组随机访问/#哈希表查找 | 常数时间         |
$$O(1) < O(\log_2n) < O(n) < O(n\log_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$$
加法规则：$O(f(n))+O(g(n))=O(max(f(x),g(n)))$
乘法规则：$O(f(n))×O(g(n))=O(f(n)×g(n))$

##### 结论与技巧
1.  **顺序执行的代码**：只会影响常数项，可以忽略，不影响大 O 复杂度。
2.  **循环分析**：只需挑循环中的一个基本操作分析它的执行次数与 $n$ 的关系。
3.  **嵌套循环**：关注**最深层循环**的执行次数，其乘积通常就是最高阶项。
4.  **最高阶原则**：只取最高阶项，并移除常数系数。

##### 复杂度类型
- **最坏时间复杂度**：最坏情况下算法的执行时间，最常用。
- **平均时间复杂度**：所有输入示例等概率出现的情况下，算法的期望运行时间。
- **最好时间复杂度**：最好情况下算法的执行时间。

---
### 空间复杂度分析
#### 核心要点
- **关注点**：算法运行过程中**额外**申请的存储空间，不包括输入数据本身。
- **忽略常数空间**：即使申请了少量固定大小的变量，只要数量不随 $n$ 变化，都算 $O(1)$。

#### 常见空间复杂度
- **$O(n)$**：线性空间，如创建与输入规模 $n$ 等大的数组。
- **$O(\log n)$**：对数空间，如递归深度为 $\log n$ 的递归调用栈。
- **$O(1)$**：常数空间，只使用了少量固定大小的变量。

---
## 题型总结：计算时间复杂度和空间复杂度

### 一、循环主体中变量参与条件判断的时间复杂度分析
这类题型的关键在于**找出基本操作的执行次数与问题规模 $n$ 的关系式**，然后根据该式子的最高次幂确定时间复杂度。

#### 例1：对数时间复杂度 $O(\log n)$
```c
int i = 1;
while (i <= n)
    i = i * 2; // 基本操作
```
-   **分析**：`i` 的值呈指数增长 $1, 2, 4, \dots, 2^x$。当 $2^x > n$ 时循环停止。
-   **执行次数**：设执行 $x$ 次，则 $2^x \approx n \Rightarrow x = \log_2 n$。
-   **时间复杂度**：$O(\log n)$。

---
#### 例2：根号时间复杂度 $O(\sqrt{n})$
```c
int y = 5;
while ((y + 1) * (y + 1) < n) // 条件判断中y参与
    y = y + 1; // 基本操作
```
-   **分析**：条件是 $(y+1)^2 < n$。初始 $y=5$，每次 $y+=1$。
-   **执行次数**：当 $(y+1)^2 \geq n$ 时停止，即 $y+1 \approx \sqrt{n} \Rightarrow y \approx \sqrt{n} - 1$。
-   **时间复杂度**：$O(\sqrt{n})$ (忽略常数项 $-6$ 等)。

---
### 二、多层循环与递归程序的时间复杂度分析

#### 1. 非递归程序（多层嵌套循环）
-   **分析方法**：**从内到外**，找出最内层操作的执行次数。
-   **例1：平方时间复杂度 $O(n^2)$**
```c
for (i = 1; i <= n; i++)        // 外层循环执行 n 次
    for (j = 1; j <= i; j++)    // 内层循环执行 i 次
        x++; // 基本操作
```
-   **总执行次数**：$\sum_{i=1}^{n} i = \frac{n(n+1)}{2} = \frac{1}{2}n^2 + \frac{1}{2}n$。
-   **时间复杂度**：$O(n^2)$ (保留最高阶项)。

---
#### 2. 递归程序
-   通常使用**递推公式**或**递归树**来分析时间复杂度。
-   **例1：线性时间复杂度 $O(n)$**
```c
// 假设T(0)为常数操作
T(n) = T(n - 1) + 1
```
-   **展开得**：$T(n) = 1 + T(n - 1) = 1 + 1 + T(n - 2) = \dots = n + T(0)$。
-   **时间复杂度**：$O(n)$。

---
## 三、思维拓展：斐波那契数列的两种算法时间复杂度分析

### 1. 递归算法（直接递归）
```c
int fib(int n) {
    if (n == 0 || n == 1)
        return n;
    return fib(n - 1) + fib(n - 2);
}
```
#### 分析
-   **时间复杂度**：
    -   每次调用 `fib(n)` 会调用 `fib(n-1)` 和 `fib(n-2)`。
    -   递归树是一棵二叉树，深度为 $n$。
    -   每层节点数呈指数增长，总节点数近似于 $2^n$。
    -   所以时间复杂度为：**$O(2^n)$**。
    -   > ⚠️ **说明**：虽然每次递归调用的子树不完全对称，但总体增长趋势是指数级的。
-   **空间复杂度**：
    -   递归调用栈的最大深度为 $n$。
    -   所以空间复杂度为：**$O(n)$**。

---

### 2. 非递归算法（迭代实现）
```c
int fib_opt(int n) {
    if (n == 0) return 0;
    int a = 0, b = 1;
    for (int i = 2; i <= n; i++) { // 循环从 2 到 n，共执行 n - 1 次
        int temp = a + b;           // 常数次操作
        a = b;
        b = temp;
    }
    return b;
}
```
#### 分析
-   **时间复杂度**：
    -   循环从 2 到 $n$，共执行 $n-1$ 次。
    -   每次循环执行常数次操作。
    -   所以时间复杂度为：**$O(n)$**。
-   **空间复杂度**：
    -   只使用了几个固定大小的变量 `a, b, temp`。
    -   所以空间复杂度为：**$O(1)$**。

---
