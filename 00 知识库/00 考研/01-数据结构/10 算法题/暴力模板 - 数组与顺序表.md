---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---
# 暴力解法模板 - 数组与顺序表

## 核心思想

暴力解法的核心思想基于**穷举搜索 (Exhaustive Search)**，通过遍历问题的解空间 (Solution Space) 来保证找到最优解。

### 理论基础

*   **完备性原理**：遍历所有可能的候选解，确保不遗漏最优解。
*   **单调性假设**：通过局部比较维护全局最优值。
*   **可行性验证**：对每个候选解进行约束条件检查。

### 时间-空间权衡 (Time-Space Trade-off)

暴力解法通常采用以下两种策略：

*   **空间换时间**：使用辅助数据结构（如临时数组、哈希表）加速计算。
*   **时间换空间**：通过重复计算避免额外存储开销。

## 通用算法模板

```c
ReturnType bruteForceSolution(InputType input[], int n, Parameters…) {
    // 第一阶段：输入验证与边界处理
    if (input == nullptr || n <= 0) {
        return handleEdgeCase();
    }

    // 第二阶段：初始化最优解
    OptimalType bestSolution = initializeOptimal();

    // 第三阶段：解空间遍历
    for (int i = 0; i < searchSpaceSize; i++) {
        CandidateType candidate = generateCandidate(i);

        // 第四阶段：可行性检查
        if (isValidCandidate(candidate)) {
            EvaluationType evaluation = evaluateCandidate(candidate);

            // 第五阶段：最优解更新
            if (isBetterSolution(evaluation, bestSolution)) {
                bestSolution = updateOptimal(evaluation, candidate);
            }
        }
        // 第六阶段：剪枝优化（可选）
        if (canPruneEarly(bestSolution)) {
            break;
        }
    }
    return bestSolution;
}
```

**模板阶段说明：**

1.  **输入验证与边界处理**：检查输入是否合法，处理空数组、小规模数组等特殊情况。
2.  **初始化最优解**：根据问题类型，初始化一个初始的最优解或边界值。
3.  **解空间遍历**：设计循环结构，系统地遍历所有可能的候选解。
4.  **可行性检查**：对生成的每个候选解，判断其是否满足问题的所有约束条件。
5.  **最优解更新**：如果当前候选解比已知的最优解更好，则更新最优解。
6.  **剪枝优化 (可选)**：在遍历过程中，如果能确定当前路径无法导出更优解，则提前终止搜索。

## 枚举策略

根据问题特征选择合适的枚举策略：

*   **线性枚举**：适用于序列搜索问题（如主元素查找）。
*   **组合枚举**：适用于子集划分问题（利用位掩码技术）。
*   **笛卡尔积枚举**：适用于多维优化问题（如三元组距离最小化）。

---

## 模板使用实例 - 数组与顺序表

### 题目 1：寻找数组中的最大子数组和

```c
int findMaxSubarraySum(int arr[], int n) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n <= 0) {
        return 0;
    }

    // 第二阶段：初始化最优解
    int bestSum = arr[0];

    // 第三阶段：解空间遍历（所有可能的子数组）
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            // 第四阶段：生成候选解（子数组[i,j]）
            int currentSum = 0;
            for (int k = i; k <= j; k++) {
                currentSum += arr[k];
            }
            // 第五阶段：最优解更新
            if (currentSum > bestSum) {
                bestSum = currentSum;
            }
        }
    }
    return bestSum;
}
```

### 题目 2：查找数组中两个数的和等于目标值

```c
bool findTwoSum(int arr[], int n, int target, int result[2]) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n < 2 || result == nullptr) {
        return false;
    }

    // 第二阶段：初始化最优解
    bool found = false;

    // 第三阶段：解空间遍历
    for (int i = 0; i < n - 1 && !found; i++) {
        for (int j = i + 1; j < n; j++) {
            // 第四阶段：可行性检查
            if (arr[i] + arr[j] == target) {
                // 第五阶段：最优解更新
                result[0] = i;
                result[1] = j;
                found = true;
                // 第六阶段：剪枝优化
                break;
            }
        }
    }
    return found;
}
```

### 题目 3：寻找数组中的最长递增子序列

```c
int findLongestIncreasingSubsequence(int arr[], int n) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n <= 0) {
        return 0;
    }

    // 第二阶段：初始化最优解
    int maxLength = 1;

    // 第三阶段：解空间遍历
    for (int i = 0; i < n; i++) {
        int currentLength = 1;
        int lastElement = arr[i];
        for (int j = i + 1; j < n; j++) {
            // 第四阶段：可行性检查
            if (arr[j] > lastElement) {
                currentLength++;
                lastElement = arr[j];
            }
        }
        // 第五阶段：最优解更新
        if (currentLength > maxLength) {
            maxLength = currentLength;
        }
    }
    return maxLength;
}
```

### 题目 4：数组中第 K 大元素

```c
int findKthLargest(int arr[], int n, int k) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n <= 0 || k <= 0 || k > n) {
        return -1;
    }

    // 第二阶段：初始化最优解
    int kthLargest = arr[0]; // 可以随意初始化，因为最终会被正确的值覆盖

    // 第三阶段：解空间遍历
    for (int targetIdx = 0; targetIdx < n; targetIdx++) {
        int rank = 1; // 假设当前元素是第1大
        // 第四阶段：计算当前元素的排名
        for (int i = 0; i < n; i++) {
            if (arr[i] > arr[targetIdx]) {
                rank++;
            }
        }
        // 第五阶段：最优解更新
        if (rank == k) {
            kthLargest = arr[targetIdx];
            break; // 第六阶段：剪枝优化，找到即停止
        }
    }
    return kthLargest;
}
```

### 题目 5：寻找数组中的最小缺失正整数

```c
int findFirstMissingPositive(int arr[], int n) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n <= 0) {
        return 1;
    }

    // 第二阶段：初始化最优解
    int firstMissing = 1; // 从1开始检查

    // 第三阶段：解空间遍历（检查从 1 开始的正整数）
    // 缺失的正整数最大可能为 n+1 (如果1到n都在数组中)
    for (int candidate = 1; candidate <= n + 1; candidate++) {
        bool found = false;
        // 第四阶段：可行性检查：在数组中查找当前候选数
        for (int i = 0; i < n; i++) {
            if (arr[i] == candidate) {
                found = true;
                break;
            }
        }
        // 第五阶段：最优解更新
        if (!found) {
            firstMissing = candidate;
            // 第六阶段：剪枝优化：找到第一个缺失的就停止
            break;
        }
    }
    return firstMissing;
}
```

### 题目 6：数组中所有三元组的最小距离和

```c
int findMinTripletSum(int arr[], int n, int target) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n < 3) {
        return -1; // 表示无效输入
    }

    // 第二阶段：初始化最优解
    // 使用前三个元素的和作为初始最佳和，计算其与target的初始差值
    int minDifference = abs(arr[0] + arr[1] + arr[2] - target);
    int bestSum = arr[0] + arr[1] + arr[2];

    // 第三阶段：解空间遍历 (三层循环遍历所有不同的三元组)
    for (int i = 0; i < n - 2; i++) {
        for (int j = i + 1; j < n - 1; j++) {
            for (int k = j + 1; k < n; k++) {
                // 第四阶段：计算候选解（当前三元组的和）
                int currentSum = arr[i] + arr[j] + arr[k];
                int currentDifference = abs(currentSum - target);

                // 第五阶段：最优解更新
                if (currentDifference < minDifference) {
                    minDifference = currentDifference;
                    bestSum = currentSum;
                }
                // 第六阶段：剪枝优化
                // 如果已经找到差值为0的三元组，说明已经是最优解，可以直接返回
                if (minDifference == 0) {
                    return bestSum;
                }
            }
        }
    }
    return bestSum;
}
```

### 题目 7：寻找数组中最长的连续序列

```c
int findLongestConsecutive(int arr[], int n) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n <= 0) {
        return 0;
    }

    // 第二阶段：初始化最优解
    int maxLength = 1; // 至少有一个元素，所以最小长度是1

    // 第三阶段：解空间遍历 (以每个元素作为可能的连续序列起点)
    for (int i = 0; i < n; i++) {
        int currentLength = 1;
        int currentNum = arr[i]; // 当前序列的起始数字

        // 向上查找连续数字
        while (true) {
            bool foundNext = false;
            // 第四阶段：可行性检查：在数组中查找 currentNum + 1
            for (int j = 0; j < n; j++) {
                if (arr[j] == currentNum + 1) {
                    currentNum++;
                    currentLength++;
                    foundNext = true;
                    break; // 找到后跳出内层循环，继续查找下一个连续数字
                }
            }
            if (!foundNext) {
                break; // 如果没找到下一个连续数字，则当前序列结束
            }
        }
        // 第五阶段：最优解更新
        if (currentLength > maxLength) {
            maxLength = currentLength;
        }
    }
    return maxLength;
}
```

### 题目 8：数组重新排列使相邻元素差的绝对值最小

**注意：** 题目描述为“数组重新排列使相邻元素差的绝对值最小”，但提供的暴力解法只尝试了交换 *两个* 元素，这并不等同于遍历所有 *排列*。遍历所有排列通常需要回溯法或`std::next_permutation`。这里按原始代码理解为“通过一次交换寻找最小相邻差和”。

```c
#include <limits.h> // For INT_MAX
#include <stdlib.h> // For abs

int findMinAdjacentDifference(int arr[], int n) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n <= 1) {
        return 0; // 0 或 1 个元素，没有相邻差，约定返回0
    }

    // 第二阶段：初始化最优解
    int minTotalDiff = INT_MAX;

    // 为了不修改原数组，我们可以在函数内部创建一个副本，或者在交换后恢复
    // 这里采用交换后恢复的方式

    // 第三阶段：解空间遍历（简化版：尝试所有单次交换）
    // 外层循环选择第一个待交换的元素
    for (int i = 0; i < n - 1; i++) {
        // 内层循环选择第二个待交换的元素 (从 i+1 开始，避免重复和自身交换)
        for (int j = i + 1; j < n; j++) {
            // 交换元素
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;

            // 第四阶段：计算当前排列的相邻差和
            int totalDiff = 0;
            for (int k = 0; k < n - 1; k++) {
                totalDiff += abs(arr[k] - arr[k + 1]);
            }

            // 第五阶段：最优解更新
            if (totalDiff < minTotalDiff) {
                minTotalDiff = totalDiff;
            }

            // 恢复原状，以便下一次循环尝试不同的交换
            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    return minTotalDiff;
}
```

### 题目 9：寻找数组中和为零的三元组个数

```c
int countZeroSumTriplets(int arr[], int n) {
    // 第一阶段：输入验证与边界处理
    if (arr == nullptr || n < 3) {
        return 0;
    }

    // 第二阶段：初始化最优解 (这里是计数器)
    int count = 0;

    // 第三阶段：解空间遍历 (三层循环遍历所有不同的三元组)
    for (int i = 0; i < n - 2; i++) {
        for (int j = i + 1; j < n - 1; j++) {
            for (int k = j + 1; k < n; k++) {
                // 第四阶段：可行性检查
                if (arr[i] + arr[j] + arr[k] == 0) {
                    // 第五阶段：最优解更新 (增加计数)
                    count++;
                }
            }
        }
    }
    return count;
}
```

### 题目 10：寻找数组中最大的矩形面积（直方图）

```c
#include <algorithm> // For std::min and std::max

int findLargestRectangleArea(int heights[], int n) {
    // 第一阶段：输入验证与边界处理
    if (heights == nullptr || n <= 0) {
        return 0;
    }

    // 第二阶段：初始化最优解
    int maxArea = 0;

    // 第三阶段：解空间遍历 (遍历所有可能的子区间 [i, j])
    for (int i = 0; i < n; i++) {
        int minHeight = heights[i]; // 初始化当前区间的最小高度为起点高度
        for (int j = i; j < n; j++) {
            // 第四阶段：计算当前区间的最小高度
            // 随着 j 的增加，更新 minHeight 为 [i, j] 区间内的最小值
            minHeight = std::min(minHeight, heights[j]);

            // 计算当前矩形面积：最小高度 * 宽度
            int currentArea = minHeight * (j - i + 1);

            // 第五阶段：最优解更新
            maxArea = std::max(maxArea, currentArea);
        }
    }
    return maxArea;
}
```

---

## 模板使用练习 - 数组与顺序表

### 题目 1：数组中所有元素的乘积除以自身

```c
void productExceptSelf(int nums[], int n, int result[]) {
    // 第一阶段：输入验证与边界处理
    if (nums == nullptr || result == nullptr || n <= 0) {
        return;
    }

    // 第二阶段：初始化
    for (int i = 0; i < n; i++) {
        result[i] = 1; // 每个结果元素初始化为1，用于乘法累积
    }

    // 第三阶段：解空间遍历 (遍历每个位置 i)
    for (int i = 0; i < n; i++) {
        // 第四阶段：计算除了当前元素外所有元素的乘积
        for (int j = 0; j < n; j++) {
            if (i != j) { // 如果不是当前元素本身
                result[i] *= nums[j]; // 累乘到 result[i]
            }
        }
    }
}
```

### 题目 2：寻找数组中的重复元素

```c
int findDuplicate(int nums[], int n) {
    // 第一阶段：输入验证与边界处理
    if (nums == nullptr || n <= 1) {
        return -1; // 表示无重复或无效输入
    }

    // 第二阶段：初始化最优解
    int duplicate = -1;

    // 第三阶段：解空间遍历 (遍历所有不同的元素对)
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            // 第四阶段：可行性检查
            if (nums[i] == nums[j]) {
                // 第五阶段：最优解更新
                duplicate = nums[i];
                // 第六阶段：剪枝优化：找到第一个重复元素即可返回
                return duplicate;
            }
        }
    }
    return duplicate;
}
```

### 3. 题目 3：数组旋转后的最小值

```c
int findMinInRotatedArray(int nums[], int n) {
    // 第一阶段：输入验证与边界处理
    if (nums == nullptr || n <= 0) {
        return -1; // 表示无效输入
    }

    // 第二阶段：初始化最优解
    int minVal = nums[0]; // 假设第一个元素是最小值

    // 第三阶段：解空间遍历 (从第二个元素开始遍历，与当前最小值比较)
    for (int i = 1; i < n; i++) {
        // 第五阶段：最优解更新
        if (nums[i] < minVal) {
            minVal = nums[i];
        }
    }
    return minVal;
}
```

### 题目 4：数组中的多数元素（出现次数超过 n/2）

```c
int majorityElement(int nums[], int n) {
    // 第一阶段：输入验证与边界处理
    if (nums == nullptr || n <= 0)
        return -1; // 表示无效输入

    // 第二阶段：初始化最优解
    int majority = nums[0]; // 假设第一个元素是多数元素
    int maxCount = 0;       // 记录目前找到的多数元素的最大出现次数

    // 第三阶段：解空间遍历 (遍历数组中的每个元素，检查它是否为多数元素)
    for (int i = 0; i < n; i++) {
        int count = 0;
        // 第四阶段：计算当前元素 nums[i] 的出现次数
        for (int j = 0; j < n; j++) {
            if (nums[j] == nums[i]) {
                count++;
            }
        }
        // 第五阶段：最优解更新
        if (count > maxCount) {
            maxCount = count;
            majority = nums[i];
        }
        // 第六阶段：剪枝优化
        // 如果当前元素的出现次数已经超过 n/2，那么它一定是多数元素，可以直接返回
        if (maxCount > n / 2) {
            break;
        }
    }
    return majority;
}
```

### 题目 5：寻找数组中缺失的最小正整数

```c
int firstMissingPositive(int nums[], int n) {
    // 第一阶段：输入验证与边界处理
    if (nums == nullptr || n <= 0) {
        return 1; // 空数组或无效数组，缺失的最小正整数是1
    }

    // 第二阶段：初始化最优解
    int missing = 1; // 从最小正整数 1 开始查找

    // 第三阶段：解空间遍历 (检查从 1 到 n+1 的所有正整数)
    // 缺失的最小正整数最大可能为 n+1 (如果 1 到 n 都在数组中)
    for (int candidate = 1; candidate <= n + 1; candidate++) {
        bool found = false;
        // 第四阶段：可行性检查：在数组中查找当前候选数
        for (int i = 0; i < n; i++) {
            if (nums[i] == candidate) {
                found = true;
                break; // 找到了，跳出内层循环
            }
        }
        // 第五阶段：最优解更新
        if (!found) { // 如果当前候选数在数组中没找到
            missing = candidate;
            // 第六阶段：剪枝优化：找到第一个缺失的正整数后即可停止并返回
            break;
        }
    }
    return missing;
}
```

### 题目 6：数组中所有子数组的最大乘积

### 题目 7：寻找数组中的峰值元素

### 题目 8：数组中所有长度为 k 的子数组的最大值

### 题目 9：寻找数组中和为目标值的四元组

### 题目 10：数组中最长的等差子序列

### 题目 11：数组元素按频率排序

### 题目 12：寻找数组中第二大的元素

### 题目 13：数组中所有元素右侧比它大的元素个数

### 题目 14：寻找数组中最长的回文子序列

### 题目 15：合并两个有序数组

