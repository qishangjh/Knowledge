---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 排序算法题模板

排序算法是 408 数据结构的核心考点。以下模板涵盖基础排序和高效排序算法的实现、考点、易错点，并配有详细的图文过程分析，适配真题解题需求。

---

## 一、基础排序算法（O(n²)，适合小规模数据）

基础排序算法实现简单，核心是“逐元素比较与调整”，408 常考其稳定性、优化逻辑及与高效排序的对比。

### 1. 直接插入排序（稳定，O(n²)）

**场景**：小规模数据、接近有序数据（如部分有序的成绩表），适合静态数据（插入少、查询多）。

```c
#include <stdbool.h> // For bool type
#include <stdlib.h>  // For malloc, free, qsort
#include <string.h>  // For memset

// 直接插入排序：升序，稳定
void InsertSort(int arr[], int n) {
    if (n <= 1) return; // 空数组或单元素数组无需排序

    int i, j, temp;
    for (i = 1; i < n; i++) { // 从第 2 个元素开始（索引 1），因为它与前面的元素构成有序子序列
        temp = arr[i]; // 暂存当前待插入元素（避免后移覆盖）
        // 找插入位置：从 arr[i-1] 向前遍历，比 temp 大的元素后移
        for (j = i - 1; j >= 0 && arr[j] > temp; j--) {
            arr[j + 1] = arr[j]; // 元素后移
        }
        arr[j + 1] = temp; // 插入 temp 到正确位置
    }
}
```

**考点**：
*   **稳定性**：**稳定**（相等元素不交换位置，在 `arr[j] > temp` 条件下，`arr[j] == temp` 时不会发生移动，左侧的相等元素会保留在左侧）。
*   **优化场景**：接近有序数据时，比较次数大幅减少（最好时间复杂度 O(n)）。
*   **408 选择题**常考“插入排序的适用场景”“稳定性判断”。

**易错点**：
*   后移元素时索引错误（需 `arr[j+1] = arr[j]`，而非 `arr[j] = arr[j+1]`）。
*   内层循环未加 `j >= 0`（导致数组越界）。

### 2. 冒泡排序（稳定，O(n²)）

**场景**：小规模数据、需“原地排序”且关注稳定性（如带序号的成绩排序，序号需随成绩同步移动）。

```c
// 冒泡排序（优化版）：升序，稳定（相邻相等元素不交换）
void BubbleSort(int arr[], int n) {
    if (n <= 1) return;
    bool hasSwap; // 标记某趟是否发生交换，无交换则已有序

    for (int i = 0; i < n - 1; i++) { // 最多 n-1 趟（每趟沉底一个最大值）
        hasSwap = false;
        // 每趟遍历范围： 0~n-1-i（已沉底的元素无需再比较）
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) { // 相邻元素逆序，交换
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                hasSwap = true;
            }
        }
        if (!hasSwap) break; // 无交换，提前终止（优化关键）
    }
}
```

**考点**：
*   **优化逻辑**：通过 `hasSwap` 避免无效遍历（最好时间复杂度 O(n)）。
*   **稳定性**：**稳定**（仅相邻逆序交换，相等元素位置不变）。
*   **408 选择题**常考“冒泡排序的优化效果”“原地排序的空间复杂度（O(1)）”。

**易错点**：
*   内层循环范围错误（未减去 `i`，导致重复比较已沉底的元素）。
*   遗漏 `hasSwap` 优化（导致最坏情况仍遍历 n-1 趟）。

### 3. 简单选择排序（不稳定，O(n²)）

**场景**：小规模数据、交换成本高的场景（如元素体积大，移动成本高于比较成本，如结构体数组）。

```c
// 简单选择排序：升序，不稳定
void SelectSort(int arr[], int n) {
    if (n <= 1) return;
    int minIdx, temp;
    // 每趟选最小元素，放到当前未排序区间的开头
    for (int i = 0; i < n - 1; i++) { // 未排序区间： [i, n-1]
        minIdx = i; // 初始最小元素索引为 i
        // 找未排序区间的最小元素索引
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        // 交换最小元素与未排序区间的第一个元素
        if (minIdx != i) { // 避免自身交换（优化）
            temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
        }
    }
}
```

**考点**：
*   **不稳定性**：**不稳定**。因“跨位置交换”导致。例如 `[4, 3(a), 3(b), 2]`，第一趟选择 `2`（索引 3），与 `4`（索引 0）交换，得到 `[2, 3(a), 3(b), 4]`。此时 `3(a)` 和 `3(b)` 的相对顺序不变。但若遇到 `[2(a), 2(b), 1]`，第一趟选择 `1` 与 `2(a)` 交换，得到 `[1, 2(b), 2(a)]`，则 `2(a)` 和 `2(b)` 的相对顺序发生了改变，故不稳定。
*   **交换次数少**：仅 n-1 次交换（每趟最多 1 次），适合交换成本高的场景。
*   **408 选择题**常考“选择排序的不稳定性”“交换次数与比较次数的区别（比较 O(n²)，交换 O(n)）”。

**易错点**：
*   找最小元素后未判断 `minIdx != i`（导致不必要的自身交换）。
*   未理解“不稳定性”的本质（跨位置交换破坏相等元素的相对顺序）。

---

## 二、高效排序算法（O(nlogn)，408 高频核心）

高效排序算法基于“分治”或“堆结构”，是大规模数据排序的首选，408 应用题必考其代码实现，选择题常考复杂度与稳定性。

### 1. 快速排序（不稳定，O(nlogn)）

**场景**：大规模无序数据（如海量日志排序），平均效率最高，适合内存可容纳的数据集。

```c
// 辅助函数：分区（以 arr[low]为枢轴，小于枢轴放左，大于放右）
int Partition(int arr[], int low, int high) {
    int pivot = arr[low]; // 选左端点为枢轴（408 常用，也可选随机/中间元素优化）
    while (low < high) {
        // 从右向左找小于枢轴的元素
        while (low < high && arr[high] >= pivot) high--; // 等号确保当 arr[high] == pivot 时，high 继续左移
        arr[low] = arr[high]; // 移到左半区
        // 从左向右找大于枢轴的元素
        while (low < high && arr[low] <= pivot) low++; // 等号确保当 arr[low] == pivot 时，low 继续右移
        arr[high] = arr[low]; // 移到右半区
    }
    arr[low] = pivot; // 枢轴放到最终位置（low=high）
    return low;       // 返回枢轴索引
}

// 快速排序（递归版）：升序，不稳定
void QuickSort(int arr[], int low, int high) {
    if (low >= high) return; // 递归终止条件：区间长度≤1
    int pivotIdx = Partition(arr, low, high); // 分区，得到枢轴位置
    QuickSort(arr, low, pivotIdx - 1); // 递归排序左半区
    QuickSort(arr, pivotIdx + 1, high); // 递归排序右半区
}

// 调用入口（简化接口）
void QuickSortMain(int arr[], int n) {
    QuickSort(arr, 0, n - 1);
}
```

**考点**：
*   **核心逻辑**：分治思想（分区→递归排序左右），平均时间复杂度 O(nlogn)，最坏 O(n²)（如有序数据选端点为枢轴）。
*   **优化方向**：随机选枢轴、三数取中（避免最坏情况），小规模子数组用插入排序（减少递归开销）。
*   **408 应用题**必考“Partition 函数实现”，**选择题**常考“快速排序的最坏情况触发条件”“不稳定性（枢轴交换破坏相对顺序）”。

**易错点**：
*   `Partition` 函数中 `arr[high] >= pivot` 和 `arr[low] <= pivot` 的**等号**（避免枢轴元素被重复移动，导致死循环）。
*   递归终止条件用 `low > high`（遗漏 `low == high`，导致递归次数增加）。
*   枢轴选择导致的最坏情况（如对有序数组排序，需提醒优化方案）。

**快速排序模拟过程**：
1.  **选择基准元素**：通常选择第一个元素。
2.  **分区**：通过一趟排序将待排序的记录分割成独立的两部分。一部分记录的元素值均比基准元素值小，另一部分记录的元素值比基准值大。
3.  **基准归位**：此时基准元素在其排好序后的正确位置。
4.  **递归**：然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

**示例**：原始序列： `9 11 5* 22 18 7 5 36` 按非递减顺序排列

-   **初始**： `9 11 5* 22 18 7 5 36` (基准 `X=9`， `i` 指向 `9`， `j` 指向 `36`)
    `i`
    `j`
-   **右移 `j`**： `36 > 9`， `j` 左移一位。遇到 `5`， `5 < 9`， `j` 停止左移。
    `9 11 5* 22 18 7 5 36`
    `i`
    `j`
-   **`arr[low] = arr[high]`**：将 `arr[j]` (`5`) 赋值到 `arr[i]` (`9`) 的位置。`i` 右移一位。
    `5 11 5* 22 18 7 5 36`
    `i` `j`
-   **左移 `i`**： `arr[i]` (`11`) `> 9`， `i` 停止右移。将 `11` 赋值到 `arr[j]` (`5`) 的位置。`j` 左移一位。
    `5 11 5* 22 18 7 11 36`
    `i`
    `j`
-   **右移 `j`**： `arr[j]` (`7`) `< 9`， `j` 停止左移。将 `7` 赋值到 `arr[i]` (`11`) 的位置。`i` 右移一位。
    `5 7 5* 22 18 7 11 36`
    `i` `j`
-   **左移 `i`**： `arr[i]` (`5*`) `< 9`， `i` 右移。 `arr[i]` (`22`) `> 9`， `i` 停止右移。将 `22` 赋值到 `arr[j]` (`7`) 的位置。`j` 左移一位。
    `5 7 5* 22 18 22 11 36`
    `i`
    `j`
-   **右移 `j`**： `arr[j]` (`18`) `> 9`， `j` 左移。此时 `i` 和 `j` 指向同一个位置。第一趟排序结束。
    `5 7 5* 22 18 22 11 36`
    `i,j`
-   **基准归位**：将基准 `X=9` 放到 `i` (`j`) 相遇的位置。
    `5 7 5* 9 18 22 11 36`
    `子序列 1` `子序列 2`

**总结**：先在左端选基准，从右端开始检测，遇见小于等于基准的数字，将其赋值到左端；再从左端开始检测，遇见大于基准的数字，将其赋值到右端。如此交替进行，直至左右两端重合。

**复杂度**：
*   **不稳定排序**。
*   **时间复杂度**：O(nlog₂n) （平均），O(n²) （最坏，如待排序列已经有序，且每次选择端点为枢轴）。
*   **空间复杂度**：O(log₂n) （递归栈空间）。

### 2. 归并排序（稳定，O(nlogn)）

**场景**：大规模数据、需稳定性（如多关键字排序：先按成绩排序，再按学号排序，学号需保持相对顺序），或外部排序（数据无法全部装入内存，需分块排序后合并）。

```c
// 辅助函数：合并两个有序子数组（arr[low..mid]和 arr[mid+1..high]）
void Merge(int arr[], int low, int mid, int high, int temp[]) {
    int i = low, j = mid + 1, k = low; // i：左子数组指针， j：右子数组指针， k： temp 指针
    // 合并两个有序子数组到 temp
    while (i <= mid && j <= high) {
        if (arr[i] <= arr[j]) { // 等号保证稳定性（左子数组元素优先）
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    // 复制左子数组剩余元素
    while (i <= mid) temp[k++] = arr[i++];
    // 复制右子数组剩余元素
    while (j <= high) temp[k++] = arr[j++];
    // 将 temp 复制回原数组（使 arr[low..high]有序）
    for (k = low; k <= high; k++) {
        arr[k] = temp[k];
    }
}

// 归并排序（递归版）：升序，稳定
void MergeSort(int arr[], int low, int high, int temp[]) {
    if (low >= high) return; // 递归终止条件：区间长度≤1
    int mid = low + (high - low) / 2; // 避免溢出（替代(low+high)/2）
    MergeSort(arr, low, mid, temp); // 递归排序左子数组
    MergeSort(arr, mid + 1, high, temp); // 递归排序右子数组
    Merge(arr, low, mid, high, temp); // 合并左右有序子数组
}

// 调用入口（简化接口，分配临时数组）
void MergeSortMain(int arr[], int n) {
    int *temp = (int*)malloc(n * sizeof(int)); // 临时数组（空间复杂度 O(n)）
    if (temp == NULL) { /* handle malloc error */ return; }
    MergeSort(arr, 0, n - 1, temp);
    free(temp); // 释放临时数组，避免内存泄漏
}
```

**考点**：
*   **稳定性**：**稳定**（合并时左子数组相等元素优先，不破坏相对顺序）。
*   **空间复杂度**：O(n)（需临时数组存储合并结果），是唯一稳定的 O(nlogn) 排序。
*   **408 常考**“Merge 函数实现”，“归并排序的稳定性”“外部排序的适用性”。

**归并排序模拟过程**：
将含有 N 个记录的序列看成 N 个有序的子序列，每个子序列的长度为一。然后两两归并，得到 ⌈N/2⌉ 个长度为 2 或者 1 的有序子序列；再两两归并，如此重复，直到得到一个长度为 N 的有序子序列为止，称为 2 路归并排序(Merge Sort)。

**示例**：给定序列： `51 36* 70 88 74 21 36` 按非递减顺序排列

-   **初始状态**：每个数字都看成一个子序列。
    `[51] [36*] [70] [88] [74] [21] [36]`
-   **第一次归并**：两两合并。
    `[36* 51] [70 88] [21 74] [36]`
-   **第二次归并**：
    `[36* 51 70 88] [21 36 74]`
-   **第三次归并**：
    `[21 36 36* 51 70 74 88]`

**复杂度**：
*   **稳定排序**。
*   **时间复杂度**：O(nlog₂n) （与初始序列无关）。
*   **空间复杂度**：O(n)。

### 3. 堆排序（不稳定，O(nlogn)）

**场景**：大规模数据、需“原地排序”且关注最坏效率（如实时数据排序，需保证最坏情况下仍高效），或 TopK 问题（如找前 100 大的元素）。

```c
// 辅助函数：大根堆堆化（自上而下，调整以 i 为根的子树为大根堆）
void HeapifyMax(int arr[], int n, int i) {
    int largest = i;      // 初始最大元素索引为 i（根）
    int left = 2 * i + 1; // 左孩子索引
    int right = 2 * i + 2; // 右孩子索引
    // 找根、左、右中的最大值
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    // 若最大值不是根，交换并递归堆化子树
    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        HeapifyMax(arr, n, largest); // 递归调整被破坏的子树
    }
}

// 堆排序：升序（基于大根堆，每次取堆顶最大值放到数组末尾）
void HeapSort(int arr[], int n) {
    if (n <= 1) return;
    // 1. 构建大根堆（从最后一个非叶子节点开始，自下而上堆化）
    // 最后一个非叶子节点索引为 n/2 - 1
    for (int i = n / 2 - 1; i >= 0; i--) {
        HeapifyMax(arr, n, i);
    }
    // 2. 堆排序：依次将堆顶（最大值）交换到数组末尾，再堆化剩余元素
    for (int i = n - 1; i > 0; i--) {
        // 交换堆顶（arr[0]）和当前末尾元素（arr[i]）
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        // 对剩余 i 个元素（堆大小变为 i）进行堆化，根节点从 0 开始
        HeapifyMax(arr, i, 0);
    }
}
```

**考点**：
*   **核心逻辑**：大根堆特性（根是最大值），排序过程 =“建堆→交换堆顶与尾元素→堆化”循环。
*   **稳定性**：**不稳定**（交换堆顶与尾元素时，跨位置交换破坏相等元素相对顺序，例如 `[3(a), 2, 3(b)]`，构建大根堆后，交换 `3(a)` 和 `3(b)`，其相对位置改变）。
*   **408 常考**“建堆过程”和“Heapify 函数”，“堆排序的空间复杂度（O(1)，原地排序）”“建堆的时间复杂度（O(n)）”。

**堆排序模拟过程**：

**关键点 1. 如何将初始的完全二叉树调整为堆？**
-   将待排序列构建一个完全二叉树，再将每个节点编号。
-   从最后一个**非叶子节点**（索引 `n/2 - 1`）开始，从右至左，从下至上，对“以该节点为根节点的子树”进行挨个调整，使之成为大顶堆，直至整个二叉树都成为大顶堆。

**示例**：给定序列： `37 16* 56 29 12 16 3 84` 构建大顶堆

-   **初始完全二叉树**：
    `37`
    `/  \`
    `16*  56`
    `/ \ / \`
    `29 12 16 3`
    `/`
    `84` (这里假设 84 是一个元素，不是一个新节点)
    正确的构建应该是：
    `37`
    `/  \`
    `16*  56`
    `/ \ / \`
    `29 12 16 3`

    假设原始序列是 `[37, 16, 56, 29, 12, 16, 3, 84]` (共 8 个元素)。
    
    `37 (0)`
    `/      \`
    `16 (1)  56 (2)`
    `/  \    /  \`
    `29(3) 12(4) 16(5) 3(6)`
    `/`
    `84(7)`

-   **从最后一个非叶子节点开始调整 (索引 `n/2 - 1`，即 `8/2 - 1 = 3`)**：
    -   **节点 3 (值 `29`)**：其左孩子 `84`。 `84 > 29`，交换。
        `37`
        `/      \`
        `16     56`
        `/  \    /  \`
        `84   12 16   3`
        `/`
        `29`
    -   **节点 2 (值 `56`)**：其孩子 `16, 3`。 `56` 最大，无需调整。
    -   **节点 1 (值 `16`)**：其孩子 `84, 12`。 `84 > 16`，交换。
        `37`
        `/      \`
        `84     56`
        `/  \    /  \`
        `16   12 16   3`
        `/`
        `29`
    -   **节点 0 (值 `37`)**：其孩子 `84, 56`。 `84 > 37`，交换。
        `84`
        `/      \`
        `37     56`
        `/  \    /  \`
        `16   12 16   3`
        `/`
        `29`
        递归调整 `37` 的子树（原 `16` 位置）。 `37` 的孩子 `16, 12`。 `37` 最大，无需调整。
        最终堆：
        `84`
        `/      \`
        `37     56`
        `/  \    /  \`
        `29   12 16   3`
        `/`
        `16` (注意这里的 16 是原数组中另一个 16)

**关键点 2. 输出根节点数字后，如何将剩余节点上的数字调整为堆？**
-   输出根节点数字之后，原先的位置会留下一个空位。
-   将最下层、最右侧的叶子节点移到空出来的根节点位置处。
-   再按照“关键点 1”中的方法调整剩余的数字，使其成为一个新的大顶堆。

**示例**：继续 `[84, 37, 56, 29, 12, 16, 3, 16_]` 进行堆排序 (排序为升序)。

1.  **初始大顶堆** (上面构建好的)： `[84, 37, 56, 29, 12, 16, 3, 16_]`
2.  **交换根 (`84`) 与末尾 (`16_`)**： `[16_, 37, 56, 29, 12, 16, 3, 84]`
    -   此时 `84` 已归位到排序数组的末尾。
    -   对 `[16_, 37, 56, 29, 12, 16, 3]` (大小为 7 的堆) 进行堆化。
    -   堆化后： `[56, 37, 16, 29, 12, 16_, 3]`
3.  **交换根 (`56`) 与末尾 (`3`)**： `[3, 37, 16, 29, 12, 16_, 56]`
    -   对 `[3, 37, 16, 29, 12, 16_]` (大小为 6 的堆) 进行堆化。
    -   堆化后： `[37, 29, 16, 3, 12, 16_]`
4.  … 依此循环，直到堆中只剩一个元素。

**复杂度**：
*   **不稳定排序**。
*   **时间复杂度**：O(nlog₂n) （最坏、平均）。建堆 O(n)，排序 O(nlog₂n)。
*   **空间复杂度**：O(1) （原地排序）。

### 4. 基数排序（稳定，O(d(n+r)))

**场景**：整数排序、字符串排序（固定长度），关键字位数 `d` 较少，取值范围 `r` 不大。

-   **核心思想**：按照低位先排序，然后收集；再按照高位排序，然后再收集；以此类推，直到最高位。每一趟的排序都是基于上一趟的排序结果。
-   **桶**：使用一组桶（通常为 0-9）来存储每一位上的数字。

**示例**：原始序列 ： `125 70 63* 9 108 7 8 68 3 63 309` 按非递减顺序

1.  **第一趟排序（按个位排）**：
    -   `桶0`: `70`, `108`
    -   `桶3`: `63*`, `3`
    -   `桶5`: `125`
    -   `桶7`: `7`
    -   `桶8`: `8`, `68`
    -   `桶9`: `9`, `309`
    -   **收集结果**：`70 108 63* 3 125 7 8 68 9 309` (此处示例的收集顺序可能与桶内入队顺序有关)

    **更准确的收集过程（队头到队尾）**：
    -   `桶0`: `70`, `108`
    -   `桶3`: `63*`, `3`
    -   `桶5`: `125`
    -   `桶7`: `7`
    -   `桶8`: `8`, `68`
    -   `桶9`: `9`, `309`
    -   **收集结果**：`70 108 3 63* 125 7 8 68 9 309` (桶0的元素先出，再桶1，依此类推)
2.  **第二趟排序（按十位排）**：
    -   `桶0`: `3`, `7`, `8`, `9`, `108`, `309`
    -   `桶6`: `63*`, `63`, `68`
    -   `桶7`: `70`
    -   `桶2`: `125`
    -   **收集结果**：`3 7 8 9 108 309 125 63* 63 68 70` (按新的序列重新分配到桶，再收集)
3.  **第三趟排序（按百位排）**：
    -   `桶0`: `3`, `7`, `8`, `9`, `63*`, `63`, `68`, `70`
    -   `桶1`: `108`, `125`
    -   `桶3`: `309`
    -   **收集结果**：`3 7 8 9 63* 63 68 70 108 125 309`

**复杂度**：
*   **稳定排序**。
*   **时间复杂度**：O(d(n+r))，其中 `d` 为关键字位数，`n` 为关键字个数，`r` 为关键字取值范围。
*   **空间复杂度**：O(r)，即需要桶的个数。

### 5. 希尔排序（不稳定，O(nlog₂n) ~ O(n²))

**场景**：直接插入排序的优化版，适合中等规模数据，当数据接近有序时效率高。

-   **核心思想**：又叫缩小增量排序。先将整个待排序的记录序列分割成为若干子序列，分割方法是将相距某个增量的记录提取出来，组成一个子序列，分别进行直接插入排序。待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。
-   **增量序列**：增量序列的选择是影响希尔排序效率的关键。好的增量序列的共同特征：最后一个增量必须为 1；应该尽量避免序列中的值（尤其是相邻的值）互为倍数的情况。

**示例**：原始序列： `21 36 18* 6 52 10 9 16 35 18` 按非递减顺序排列

1.  **第一步：选取增量 `gap=5`**，分割序列并进行插入排序。
    -   **子序列**：
        -   ① `21, 10`
        -   ② `36, 9`
        -   ③ `18*, 16`
        -   ④ `6, 35`
        -   ⑤ `52, 18`
    -   **子序列排序后**：
        -   ① `10, 21`
        -   ② `9, 36`
        -   ③ `16, 18*`
        -   ④ `6, 35`
        -   ⑤ `18, 52`
    -   **第一趟排序结果**：`10 9 16 6 18 21 36 18* 35 52`
2.  **第二步：选取增量 `gap=3`**，分割序列并进行插入排序。
    -   **子序列**：
        -   ① `10, 6, 36, 52`
        -   ② `9, 18, 18*`
        -   ③ `16, 21, 35`
    -   **子序列排序后**：
        -   ① `6, 10, 36, 52`
        -   ② `9, 18, 18*`
        -   ③ `16, 21, 35`
    -   **第二趟排序结果**：`6 9 16 10 18 21 36 18* 35 52`
3.  **第三步：选取增量为 `gap=1`**，进行直接插入排序（此时序列已基本有序）。
    -   **排序结果**：`6 9 10 16 18 18* 21 35 36 52`

**复杂度**：
*   **不稳定排序**。
*   **时间复杂度**：取决于增量序列，O(nlog₂n) （最好，元素已经排序好顺序）~ O(n²) （最差）。
*   **空间复杂度**：O(1)。

---

## 三、该章节题型主要出选择题+应用

### 一、排序算法的特点总结

| 算法          | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性   | 适用场景                                                              |
| :------------ | :------------- | :------------- | :------------- | :--------- | :------- | :-------------------------------------------------------------------- |
| **直接插入**  | O(n²)          | O(n²)          | O(n)           | O(1)       | 稳定     | 小规模，接近有序                                                      |
| **冒泡排序**  | O(n²)          | O(n²)          | O(n)           | O(1)       | 稳定     | 小规模，需稳定性                                                      |
| **简单选择**  | O(n²)          | O(n²)          | O(n²)          | O(1)       | 不稳定   | 小规模，交换成本高                                                    |
| **快速排序**  | O(nlog₂n)      | O(n²)          | O(nlog₂n)      | O(log₂n)   | 不稳定   | 大规模无序数据，平均效率高                                            |
| **归并排序**  | O(nlog₂n)      | O(nlog₂n)      | O(nlog₂n)      | O(n)       | 稳定     | 大规模，需稳定性，或外部排序                                          |
| **堆排序**    | O(nlog₂n)      | O(nlog₂n)      | O(nlog₂n)      | O(1)       | 不稳定   | 大规模，原地排序，最坏效率保证，TopK                                  |
| **希尔排序**  | O(nlog₂n)      | O(n²)          | O(nlog₂n)      | O(1)       | 不稳定   | 中等规模，插入排序优化                                                |
| **基数排序**  | O(d(n+r))      | O(d(n+r))      | O(d(n+r))      | O(r)       | 稳定     | 整数/字符串排序，位数少，范围小                                       |

---

### 二、选择题高频考点

1.  **稳定性判断**：理解稳定性的定义（相等元素的相对顺序不变），并记住每个算法的稳定性。
    *   **稳定**：直接插入、冒泡、归并、基数。
    *   **不稳定**：简单选择、快速、堆、希尔。
2.  **时间复杂度分析**：区分平均、最好、最坏情况下的时间复杂度，尤其是 O(n²) 和 O(nlogn) 算法的对比。
    *   **O(n) 的最好情况**：直接插入、冒泡。
    *   **O(n²) 的最坏情况**：直接插入、冒泡、简单选择、快速、希尔。
    *   **始终 O(nlogn)**：归并、堆（最坏、最好都一样）。
3.  **空间复杂度分析**：区分原地排序（O(1)）和非原地排序（O(n) 或 O(logn)）。
    *   **O(1) 空间**：直接插入、冒泡、简单选择、堆、希尔。
    *   **O(n) 空间**：归并、基数。
    *   **O(logn) 空间**：快速（递归栈）。
4.  **适用场景对比**：根据数据规模、有序性、稳定性要求选择合适的排序算法。
    *   **小规模数据**：插入、冒泡、选择。
    *   **大规模数据**：快速、归并、堆、希尔。
    *   **外部排序**：归并。
    *   **TopK 问题**：堆。
    *   **整数/字符串**：基数。
5.  **特定算法细节**：
    *   **冒泡排序**的 `hasSwap` 优化。
    *   **快速排序**的最坏情况（有序数据选端点枢轴）和优化策略。
    *   **归并排序**的 `Merge` 函数实现。
    *   **堆排序**的建堆过程（O(n)）和 `Heapify` 函数。
    *   **希尔排序**的增量序列选择和优化原因。

---

### 三、应用题高频考点

1.  **代码实现**：要求能手写 O(nlogn) 级别的排序算法（快速、归并、堆）。
2.  **模拟过程**：给定初始序列，要求画图或详细描述某算法的排序过程，尤其是快速排序和堆排序的每一趟变化。
3.  **变种与优化**：对经典算法进行修改，如：
    *   对部分有序数组使用特定排序。
    *   对链表进行排序（归并排序适合链表）。
    *   查找第 K 大/小元素（快速选择、堆）。
    *   多关键字排序。
4.  **复杂度分析**：给定排序算法的伪代码或代码，要求分析其时间、空间复杂度。
