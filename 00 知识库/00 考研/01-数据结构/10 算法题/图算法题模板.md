---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---
# 图算法题模板

图算法是 408 数据结构的核心考点。以下模板涵盖图的存储、遍历、最短路径、最小生成树、拓扑排序五大类高频场景，均以 C 语言实现，并标注核心逻辑、考点及易错点，适配真题解题需求。

---

## 一、图基础模板（核心）

### 1. 图的存储结构

#### （1）邻接矩阵（适合稠密图，O(n²) 空间）

**场景**：顶点数 `n` 较小（≤1000），边数多，需快速判断两顶点是否相连。

```c
#define MAXV 1001    // 最大顶点数
#define INF 0x3f3f3f3f // 表示无穷大（不可达），C语言中常用较大整数表示

typedef struct {
    int edges[MAXV][MAXV]; // 邻接矩阵，存储边权值
    int n, e;             // 顶点数、边数
    // int vexs[MAXV];     // 顶点信息（可省略，直接用索引）
} MGraph;

// 初始化邻接矩阵
void InitMGraph(MGraph *G, int n) {
    G->n = n;
    G->e = 0;
    // 初始化边为 INF（不可达）
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            G->edges[i][j] = (i == j) ? 0 : INF; // 自身到自身距离为 0
        }
    }
}

// 添加边（有向图）
void AddEdgeDir(MGraph *G, int u, int v, int w) {
    // 检查是否存在重复边，避免重复计数 `G->e`
    if (G->edges[u][v] == INF) G->e++;
    G->edges[u][v] = w; // 有向图： u→v 的权值为 w
}

// 添加边（无向图，对称存储）
void AddEdgeUndir(MGraph *G, int u, int v, int w) {
    // 检查是否存在重复边
    if (G->edges[u][v] == INF) G->e++;
    G->edges[u][v] = w;
    G->edges[v][u] = w; // 无向图： u↔v 权值相同
}
```

**考点**：邻接矩阵的对称性（无向图）、自身环（`i==j`）处理，408 常考“基于邻接矩阵的度计算”（无向图：行/列和；有向图：行和 = 出度，列和 = 入度）。

#### （2）邻接表（适合稀疏图，O(n+e) 空间）

**场景**：顶点数 `n` 大（>1000），边数少，需高效遍历某顶点的所有邻接边。

```c
#define MAXV 10001 // 最大顶点数（支持更大规模）

// 边节点
typedef struct ArcNode {
    int adjvex;         // 邻接顶点索引
    int weight;         // 边的权值
    struct ArcNode *next; // 指向下一条邻接边
} ArcNode;

// 顶点节点
typedef struct VNode {
    ArcNode *firstarc; // 第一条邻接边
    // 可添加顶点信息（如 char data）
} VNode, AdjList[MAXV]; // AdjList 是 VNode 类型的数组

// 邻接表表示的图
typedef struct {
    AdjList vertices; // 顶点数组
    int n, e;         // 顶点数、边数
} ALGraph;

// 初始化邻接表
void InitALGraph(ALGraph *G, int n) {
    G->n = n;
    G->e = 0;
    for (int i = 0; i < n; i++) {
        G->vertices[i].firstarc = NULL; // 初始无邻接边
    }
}

// 添加边（有向图）
void AddEdgeDirAL(ALGraph *G, int u, int v, int w) {
    ArcNode *p = (ArcNode*)malloc(sizeof(ArcNode));
    if (p == NULL) { /* handle malloc error */ return; }
    p->adjvex = v;
    p->weight = w;
    // 头插法（效率高，顺序无关）
    p->next = G->vertices[u].firstarc;
    G->vertices[u].firstarc = p;
    G->e++;
}

// 添加边（无向图，需添加两条有向边）
void AddEdgeUndirAL(ALGraph *G, int u, int v, int w) {
    AddEdgeDirAL(G, u, v, w); // u→v
    AddEdgeDirAL(G, v, u, w); // v→u（无向图对称）
}
```

**考点**：邻接表的头插法实现、无向图的边存储次数（每条边存两次），408 常考“基于邻接表的遍历”和“边数统计”。

### 2. 图的遍历（DFS 与 BFS）

`#include <stdbool.h>` // 用于 `bool` 类型
`#include <string.h>`  // 用于 `memset`

#### （1）深度优先搜索（DFS，递归版，O(n+e)）

**场景**：连通性判断、路径查找、拓扑排序前驱判断。

```c
bool visited[MAXV]; // 全局访问标记数组

// 邻接表的 DFS
void DFS_AL(ALGraph *G, int v) {
    visited[v] = true;
    printf("%d ", v); // 访问顶点 v（可替换为具体操作）
    ArcNode *p = G->vertices[v].firstarc;
    while (p != NULL) {
        int w = p->adjvex;
        if (!visited[w]) { // 未访问过的邻接顶点
            DFS_AL(G, w);  // 递归访问
        }
        p = p->next;
    }
}

// 邻接矩阵的 DFS
void DFS_MG(MGraph *G, int v) {
    visited[v] = true;
    printf("%d ", v);
    for (int w = 0; w < G->n; w++) {
        // 存在边（权值不为 INF 且不为 0）且未访问
        if (G->edges[v][w] != INF && G->edges[v][w] != 0 && !visited[w]) {
            DFS_MG(G, w);
        }
    }
}

// 遍历全图（处理非连通图）
void DFSTraverse(ALGraph *G) {
    memset(visited, false, sizeof(visited)); // 初始化访问标记
    for (int v = 0; v < G->n; v++) {
        if (!visited[v]) { // 未访问的连通分量
            DFS_AL(G, v);
        }
    }
}
```

**核心逻辑**：递归访问未 `visited` 的邻接顶点，本质是“一条路走到底，不通则回溯”。
**考点**：非连通图的遍历（需多次调用 DFS）、访问顺序与递归栈的关系，408 常考“DFS 生成树”的结构。

#### （2）广度优先搜索（BFS，队列版，O(n+e)）

**场景**：最短路径（无权图）、层序遍历、连通分量统计。

```c
// 邻接表的 BFS
void BFS_AL(ALGraph *G, int v) {
    memset(visited, false, sizeof(visited));
    int queue[MAXV], front = 0, rear = 0; // 数组模拟循环队列
    // 起点入队并标记
    queue[rear++] = v;
    visited[v] = true;
    while (front < rear) {
        int u = queue[front++]; // 出队
        printf("%d ", u);       // 访问顶点 u
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int w = p->adjvex;
            if (!visited[w]) { // 未访问的邻接顶点
                visited[w] = true;
                queue[rear++] = w; // 入队
            }
            p = p->next;
        }
    }
}

// 无权图单源最短路径（基于 BFS，记录距离）
void UnweightedShortestPath(ALGraph *G, int v, int dist[]) {
    // 初始化距离为-1（不可达）
    for (int i = 0; i < G->n; i++) dist[i] = -1;
    int queue[MAXV], front = 0, rear = 0; // 数组模拟循环队列
    queue[rear++] = v;
    dist[v] = 0; // 起点距离为 0
    while (front < rear) {
        int u = queue[front++];
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int w = p->adjvex;
            if (dist[w] == -1) { // 未访问过（或未确定最短距离）
                dist[w] = dist[u] + 1; // 距离=父节点+1
                queue[rear++] = w;
            }
            p = p->next;
        }
    }
}
```

### 3. 最短路径算法

#### （1）Dijkstra 算法（单源，权值非负，O(n²)）

**场景**：求从源点到其他所有顶点的最短路径，边权非负（如公路网距离）。

**核心逻辑**：贪心策略，每次选“当前最短距离的未确定顶点”，松弛其邻接顶点，直至所有顶点确定。
**考点**：权值非负的限制（否则无法保证贪心正确性）、路径前驱数组的应用，408 常考手动模拟算法步骤。
**易错点**：松弛条件需同时满足“未确定”“存在边”“新路径更短”，缺一不可。

```c
// Dijkstra 算法（邻接矩阵，返回源点 s 到所有顶点的最短距离）
// dist 数组存储最短距离， path 数组记录前驱顶点
void Dijkstra(MGraph *G, int s, int dist[], int path[]) {
    int n = G->n;
    bool finalized[MAXV]; // finalized[i] 为 true 表示 i 的最短路径已确定

    // 初始化
    for (int i = 0; i < n; i++) {
        dist[i] = G->edges[s][i]; // 从源点 s 到 i 的直达距离
        path[i] = (dist[i] != INF) ? s : -1; // 如果可达，s 是前驱
        finalized[i] = false;
    }

    dist[s] = 0;        // 源点到自身距离为 0
    finalized[s] = true; // 源点的最短路径已确定

    // 迭代 n-1 次，每次确定一个顶点的最短路径
    for (int i = 1; i < n; i++) {
        // 1. 找当前最短距离的未确定顶点 u
        int min = INF, u = -1;
        for (int j = 0; j < n; j++) {
            if (!finalized[j] && dist[j] < min) {
                min = dist[j];
                u = j;
            }
        }

        if (u == -1) break; // 若找不到未确定顶点（图不连通），提前终止
        finalized[u] = true; // 顶点 u 的最短路径已确定

        // 2. 松弛顶点 u 的所有邻接顶点
        for (int v = 0; v < n; v++) {
            // 如果 v 未确定，且 u→v 有边，且通过 u 到 v 的路径更短
            if (!finalized[v] && G->edges[u][v] != INF &&
                (dist[u] + G->edges[u][v] < dist[v])) {
                dist[v] = dist[u] + G->edges[u][v]; // 更新最短距离
                path[v] = u; // 更新前驱
            }
        }
    }
}
```

#### （2）Floyd 算法（多源，O(n³)）

**场景**：求所有顶点对之间的最短路径，支持负权边（无负环）。

**核心逻辑**：动态规划，`dist[i][j]` 通过“是否经过中间顶点 k”更新，三重循环覆盖所有可能路径。
**考点**：多源最短路径的简洁实现、负权边处理（但不能有负环），408 常考时间复杂度分析（O(n³）。
**易错点**：中间顶点 `k` 的循环必须在最外层，确保每次迭代都考虑所有可能的中间顶点。

```c
// Floyd 算法（邻接矩阵存储距离，dist[i][j]为 i 到 j 的最短距离）
// path[i][j] 存储 i 到 j 的最短路径中，从 k 到 j 的前驱顶点
void Floyd(MGraph *G, int dist[][MAXV], int path[][MAXV]) {
    int n = G->n;

    // 初始化：dist 矩阵为图的邻接矩阵，path 记录直达前驱
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = G->edges[i][j];
            // 如果 i 到 j 可达 (且不是自身)，则前驱为 i，否则为 -1
            path[i][j] = (dist[i][j] != INF && i != j) ? i : -1;
        }
    }

    // k 为中间顶点 (必须在最外层循环)
    for (int k = 0; k < n; k++) {
        // i 为起点
        for (int i = 0; i < n; i++) {
            // j 为终点
            for (int j = 0; j < n; j++) {
                // 若 i→k→j 比 i→j 更短，更新
                // 确保 dist[i][k] 和 dist[k][j] 不为无穷大，避免溢出
                if (dist[i][k] != INF && dist[k][j] != INF &&
                    dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = path[k][j]; // 前驱更新为 k→j 的前驱
                }
            }
        }
    }
}
```

### 4. 最小生成树（MST）

`#include <stdlib.h>` // For `qsort`

#### （1）Prim 算法（适合稠密图，O(n²)）

**场景**：稠密图（边多）的最小生成树，从顶点出发构建。

**核心逻辑**：从起点开始，每次选“与 MST 最近的非树顶点”加入，更新其他顶点到 MST 的距离。
**考点**：稠密图的效率优势（O(n²) 优于 Kruskal 的 O(eloge)）、MST 的总权值计算，408 常考与 Kruskal 的适用场景对比。
**易错点**：松弛条件需同时满足“未确定”“存在边”“新路径更短”，缺一不可。

```c
// Prim 算法（邻接矩阵，返回 MST 的总权值）
int Prim(MGraph *G, int start) {
    int lowcost[MAXV];    // 记录顶点到 MST 的最小权值（dist[i] = cost(i, MST)）
    int adjvex[MAXV];     // 记录 lowcost[i] 对应的 MST 顶点（MST 边的另一端）
    bool inMST[MAXV];     // 标记顶点是否已在 MST 中

    // 初始化（从 start 顶点开始构建 MST）
    for (int i = 0; i < G->n; i++) {
        lowcost[i] = G->edges[start][i]; // 所有顶点到起始点的距离
        adjvex[i] = start;                // 它们通过起始点连接到 MST
        inMST[i] = false;                 // 初始都不在 MST 中
    }

    inMST[start] = true; // 起点加入 MST
    lowcost[start] = 0;  // 起点到 MST 的距离为 0
    int totalMSTWeight = 0; // MST 总权值

    // 迭代 n-1 次（加入剩余 n-1 个顶点）
    for (int i = 1; i < G->n; i++) {
        // 1. 找 lowcost 最小的非 MST 顶点 u
        int minCost = INF, u = -1;
        for (int j = 0; j < G->n; j++) {
            if (!inMST[j] && lowcost[j] < minCost) {
                minCost = lowcost[j];
                u = j;
            }
        }

        if (u == -1) return -1; // 图不连通，无法生成 MST
        
        inMST[u] = true; // 将顶点 u 加入 MST
        totalMSTWeight += minCost; // 累加这条边的权值

        // 2. 更新 lowcost（ u 加入后，其他非 MST 顶点到 MST 的距离可能缩短）
        for (int v = 0; v < G->n; v++) {
            // 如果 v 不在 MST 中，且 (u,v) 边的权值小于 lowcost[v]
            if (!inMST[v] && G->edges[u][v] < lowcost[v]) {
                lowcost[v] = G->edges[u][v]; // 更新 lowcost[v]
                adjvex[v] = u;                // v 现在通过 u 连接到 MST
            }
        }
    }
    return totalMSTWeight;
}
```

#### （2）Kruskal 算法（适合稀疏图，O(eloge)）

**场景**：稀疏图（边少）的最小生成树，从边出发构建，依赖并查集。

**核心逻辑**：边按权值升序排序，依次选“不构成环的边”，用并查集高效检测环，直至选够 `n-1` 条边。
**考点**：并查集的应用（路径压缩 + 合并优化）、稀疏图的效率优势，408 常考“边的选择过程”模拟。
**易错点**：排序后需判断是否选够 `n-1` 条边（否则图不连通，无 MST）。

```c
// 边的结构体（ u→v，权值 w）
typedef struct {
    int u, v, w;
} Edge;

// 并查集（用于检测环）
int parent[MAXV];

int find(int x) { // 查找根节点，路径压缩优化
    if (parent[x] != x) {
        parent[x] = find(parent[x]); // 递归地将路径上的所有节点指向根
    }
    return parent[x];
}

void unionSet(int x, int y) { // 合并两个集合
    int rootX = find(x);
    int rootY = find(y);
    if (rootX != rootY) { // 如果不在同一个集合，则合并
        parent[rootX] = rootY;
    }
}

// 比较函数（用于边排序）
int cmp(const void *a, const void *b) {
    Edge *e1 = (Edge*)a;
    Edge *e2 = (Edge*)b;
    return e1->w - e2->w; // 按权值升序排序
}

// Kruskal 算法（返回 MST 总权值，edges 为所有边，e 为边数，n 为顶点数）
int Kruskal(Edge edges[], int e, int n) {
    // 1. 初始化并查集：每个顶点都是一个独立的集合
    for (int i = 0; i < n; i++) parent[i] = i;

    // 2. 边按权值升序排序
    qsort(edges, e, sizeof(Edge), cmp);

    int totalMSTWeight = 0; // MST 总权值
    int edgeCount = 0;       // 已选入 MST 的边数

    // 3. 遍历排序后的边
    for (int i = 0; i < e; i++) {
        int u = edges[i].u;
        int v = edges[i].v;
        int w = edges[i].w;

        // 如果边的两个顶点不在同一个连通分量中（即加入此边不会形成环）
        if (find(u) != find(v)) {
            unionSet(u, v);          // 合并这两个连通分量
            totalMSTWeight += w;     // 累加边权值
            edgeCount++;             // 已选边数加 1

            // 如果已选够 n-1 条边，MST 完成
            if (edgeCount == n - 1) break;
        }
    }
    // 如果最终选够 n-1 条边，返回总权值，否则图不连通，返回 -1
    return (edgeCount == n - 1) ? totalMSTWeight : -1;
}
```

### 5. 拓扑排序与关键路径

#### （1）拓扑排序（有向无环图 DAG，O(n+e)）

**场景**：任务调度、课程安排等依赖关系排序，检测有向环。

**核心逻辑**：反复选入度为 0 的顶点，减少其邻接顶点入度，若最终序列长度≠`n` 则有环。
**考点**：有向环的检测（返回 0）、拓扑序列的不唯一性，408 常考“给定 DAG，写出拓扑序列”。

```c
// 基于邻接表的拓扑排序（返回拓扑序列长度，成功返回 count，失败返回 0）
int TopologicalSort(ALGraph *G, int topo[]) {
    int inDegree[MAXV] = {0}; // 入度数组
    int queue[MAXV], front = 0, rear = 0; // 数组模拟循环队列
    int count = 0; // 记录拓扑序列长度

    // 1. 计算所有顶点的入度
    for (int v = 0; v < G->n; v++) {
        ArcNode *p = G->vertices[v].firstarc;
        while (p != NULL) {
            inDegree[p->adjvex]++; // 邻接顶点 p->adjvex 的入度加 1
            p = p->next;
        }
    }

    // 2. 将所有入度为 0 的顶点入队
    for (int v = 0; v < G->n; v++) {
        if (inDegree[v] == 0) {
            queue[rear++] = v;
        }
    }

    // 3. 执行拓扑排序
    while (front < rear) {
        int u = queue[front++]; // 出队一个入度为 0 的顶点 u
        topo[count++] = u;     // 将 u 加入拓扑序列

        // 4. 减少 u 的所有邻接顶点的入度
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            inDegree[v]--; // 邻接顶点 v 的入度减 1
            if (inDegree[v] == 0) { // 如果 v 的入度变为 0，则入队
                queue[rear++] = v;
            }
            p = p->next;
        }
    }
    // 如果拓扑序列长度等于顶点数，说明无环，成功完成排序
    return (count == G->n) ? count : 0; // 否则有环
}
```

#### （2）关键路径（DAG，O(n+e)）

**场景**：项目计划中，确定影响总工期的关键活动（最早开始 = 最晚开始）。

**核心逻辑**：通过拓扑序算最早时间 `ve`，逆拓扑序算最晚时间 `vl`，关键活动满足 `ve[u]+w=ve[v]` 且 `vl[v]-w=vl[u]`。
**考点**：最早/最晚时间的计算逻辑、关键活动的判定，408 常考“手动计算关键路径”。

```c
// 关键路径算法（基于拓扑排序，返回总工期）
int CriticalPath(ALGraph *G) {
    int n = G->n;
    int ve[MAXV], vl[MAXV]; // 最早发生时间 (Vertex Earliest), 最晚发生时间 (Vertex Latest)
    int topo[MAXV];         // 拓扑序列

    // 先进行拓扑排序，若有环则无法计算关键路径
    int topoCount = TopologicalSort(G, topo);
    if (topoCount != n) {
        printf("图有环，无法计算关键路径。\n");
        return -1; // 有环，无关键路径
    }

    // 1. 计算所有事件（顶点）的最早发生时间 `ve` (按拓扑序)
    memset(ve, 0, sizeof(ve)); // 初始化所有 ve 为 0
    for (int i = 0; i < n; i++) { // 按拓扑序列遍历顶点 u
        int u = topo[i];
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;    // u 的邻接顶点 v (活动 u->v 的终点)
            int weight = p->weight; // 活动 u->v 的持续时间
            // 更新事件 v 的最早发生时间
            if (ve[u] + weight > ve[v]) {
                ve[v] = ve[u] + weight;
            }
            p = p->next;
        }
    }

    // 2. 计算所有事件（顶点）的最晚发生时间 `vl` (按逆拓扑序)
    // 初始化所有 vl 为总工期（这里假设总工期为汇点（拓扑序的最后一个顶点）的 ve）
    // 或者用 INF，然后从汇点开始反向计算
    int totalProjectDuration = ve[topo[n - 1]]; // 总工期
    for (int i = 0; i < n; i++) {
        vl[i] = totalProjectDuration; // 初始所有 vl 为总工期
    }

    for (int i = n - 1; i >= 0; i--) { // 按逆拓扑序列遍历顶点 u
        int u = topo[i];
        // 需要遍历 u 的所有**入边**，或者遍历 u 的**出边**并反向推导
        // 这里采用遍历 u 的出边来更新其邻接顶点（v）的 vl
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;    // u 的邻接顶点 v (活动 u->v 的终点)
            int weight = p->weight; // 活动 u->v 的持续时间
            // 更新事件 u 的最晚发生时间
            if (vl[v] - weight < vl[u]) { // 从 v 反推 u，并确保 vl[u] 不会变大
                vl[u] = vl[v] - weight;
            }
            p = p->next;
        }
    }

    // 3. 输出关键活动（活动 (u,v) 是关键活动，当且仅当其最早开始时间等于最晚开始时间）
    printf("关键路径（活动）: ");
    int foundCritical = 0;
    for (int u = 0; u < n; u++) {
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            int weight = p->weight;
            // 活动 (u,v) 的最早开始时间 = ve[u]
            // 活动 (u,v) 的最晚开始时间 = vl[v] - weight
            if (ve[u] == vl[v] - weight) { // 如果最早开始时间等于最晚开始时间
                printf("%d->%d ", u, v);
                foundCritical = 1;
            }
            p = p->next;
        }
    }
    if (!foundCritical) {
        printf("无");
    }
    printf("\n");

    return totalProjectDuration; // 返回总工期
}
```

---

## 二、高频应用场景模板（图）

### 1. 邻接表删除指定有向边（u→v）

**场景**：给定顶点 `u`、`v`，删除邻接表中 `u` 指向 `v` 的边（如社交网络删除关注关系）。

```c
// 邻接表删除 u→v 的边
bool DeleteEdgeDirAL(ALGraph *G, int u, int v) {
    if (u < 0 || u >= G->n || v < 0 || v >= G->n) return false; // 顶点越界

    ArcNode *p = G->vertices[u].firstarc;
    ArcNode *prev = NULL; // 前驱边节点

    while (p != NULL) {
        if (p->adjvex == v) { // 找到目标边
            if (prev == NULL) { // 目标边是当前顶点的第一条边
                G->vertices[u].firstarc = p->next;
            } else { // 目标边在中间或末尾
                prev->next = p->next;
            }
            free(p); // 释放边节点内存
            G->e--;  // 边数减 1
            return true;
        }
        prev = p;    // 更新前驱
        p = p->next; // 移动到下一条边
    }
    return false; // 未找到边
}
```

### 2. 邻接矩阵计算有向图顶点的入度与出度

**场景**：统计每个顶点的入度（收到的边数）和出度（发出的边数），如网络流量分析。

```c
// 计算有向图各顶点的入度和出度
void CalcInOutDegree(MGraph *G, int in[], int out[]) {
    memset(in, 0, G->n * sizeof(int));  // 初始化入度数组为 0
    memset(out, 0, G->n * sizeof(int)); // 初始化出度数组为 0

    for (int u = 0; u < G->n; u++) {
        for (int v = 0; v < G->n; v++) {
            // 如果存在 u 到 v 的边（且不是自环，自环在后面单独处理）
            if (G->edges[u][v] != INF && G->edges[u][v] != 0 && u != v) {
                out[u]++; // u 的出度+1
                in[v]++;  // v 的入度+1
            }
        }
    }
    // 特殊处理自环：自环会同时增加自身的入度和出度
    for (int i = 0; i < G->n; i++) {
        if (G->edges[i][i] != INF && G->edges[i][i] != 0) {
            in[i]++;
            out[i]++;
        }
    }

    // 打印结果
    for (int i = 0; i < G->n; i++) {
        printf("顶点%d：入度=%d，出度=%d\n", i, in[i], out[i]);
    }
}
```

### 3. 邻接表构建逆图（有向图）

**场景**：将原图的所有边反向（`u→v` 变为 `v→u`），用于强连通分量（Kosaraju 算法）。

```c
// 构建有向图的逆图（邻接表）
void BuildReverseGraph(ALGraph *G, ALGraph *reverseG) {
    InitALGraph(reverseG, G->n); // 初始化逆图，顶点数相同
    for (int u = 0; u < G->n; u++) {
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            int w = p->weight;
            // 原边 u→v，逆边 v→u
            AddEdgeDirAL(reverseG, v, u, w); // 添加反向边
            p = p->next;
        }
    }
}
```

### 4. 图的深拷贝（邻接表）

**场景**：复制一个图的结构和边权，避免修改原图，如算法的多实例测试。

```c
// 深拷贝邻接表表示的图
ALGraph* CopyGraph(ALGraph *G) {
    ALGraph *newG = (ALGraph*)malloc(sizeof(ALGraph));
    if (newG == NULL) { /* handle malloc error */ return NULL; }

    InitALGraph(newG, G->n); // 初始化新图，顶点数相同
    newG->e = G->e;          // 边数相同

    for (int u = 0; u < G->n; u++) { // 遍历每个顶点
        ArcNode *p = G->vertices[u].firstarc; // 原图的邻接边
        ArcNode *newPrev = NULL;               // 新图当前顶点的前驱边节点

        while (p != NULL) {
            // 复制边节点
            ArcNode *newP = (ArcNode*)malloc(sizeof(ArcNode));
            if (newP == NULL) { /* handle malloc error and cleanup newG */ return NULL; }
            newP->adjvex = p->adjvex;
            newP->weight = p->weight;
            newP->next = NULL;

            if (newPrev == NULL) { // 如果是新图当前顶点的第一条边
                newG->vertices[u].firstarc = newP;
            } else { // 后续边，尾插法（保持原边顺序）
                newPrev->next = newP;
            }
            newPrev = newP; // 更新新图的前驱边节点
            p = p->next;    // 移动到原图的下一条边
        }
    }
    return newG;
}
```

### 5. 无向图连通分量统计（DFS）

**场景**：求无向图的连通分量个数（如岛屿数量的图版），408 基础考点。

```c
// 辅助函数：DFS 遍历并标记访问（这里复用前面的 DFS_AL，确保 visited 数组全局可用）
// void DFS_AL(ALGraph *G, int v); // 假设已定义

int CountConnectedComponents(ALGraph *G) {
    bool visited[MAXV];
    memset(visited, false, sizeof(visited)); // 初始化所有顶点未访问
    int count = 0; // 连通分量个数

    for (int v = 0; v < G->n; v++) {
        if (!visited[v]) { // 如果顶点 v 未被访问，说明它属于一个新的连通分量
            count++;       // 连通分量数加 1
            DFS_AL(G, v);  // 从 v 开始 DFS，标记该连通分量所有顶点为已访问
        }
    }
    return count;
}
```

### 6. 判断两顶点是否连通（BFS）

**场景**：给定源点 `s` 和目标点 `t`，判断是否存在路径（如社交网络好友关系判断）。

```c
bool IsConnected(ALGraph *G, int s, int t) {
    if (s < 0 || s >= G->n || t < 0 || t >= G->n) return false; // 顶点越界
    if (s == t) return true; // 同一顶点视为连通

    bool visited[MAXV];
    memset(visited, false, sizeof(visited));
    int queue[MAXV], front = 0, rear = 0; // 数组模拟循环队列

    queue[rear++] = s;      // 源点入队
    visited[s] = true;      // 标记源点已访问

    while (front < rear) {
        int u = queue[front++]; // 出队
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            if (v == t) return true; // 找到目标顶点 t，返回 true

            if (!visited[v]) { // 如果邻接顶点 v 未访问
                visited[v] = true;
                queue[rear++] = v; // 入队
            }
            p = p->next;
        }
    }
    return false; // BFS 结束后仍未找到目标，说明无路径
}
```

### 7. 无向图的层次遍历（按层输出）

**场景**：按距离源点的层次输出顶点（如网络节点的跳数分层）。

```c
void LevelOrderByLayer(ALGraph *G, int start) {
    if (start < 0 || start >= G->n) return; // 顶点越界

    bool visited[MAXV];
    memset(visited, false, sizeof(visited));
    int queue[MAXV], front = 0, rear = 0;

    queue[rear++] = start;
    visited[start] = true;
    int level = 0; // 记录当前层次

    while (front < rear) {
        int levelSize = rear - front; // 当前层的节点数
        printf("层次%d： ", level++);   // 打印当前层次

        for (int i = 0; i < levelSize; i++) { // 遍历当前层的所有节点
            int u = queue[front++];
            printf("%d ", u);

            ArcNode *p = G->vertices[u].firstarc;
            while (p != NULL) {
                int v = p->adjvex;
                if (!visited[v]) {
                    visited[v] = true;
                    queue[rear++] = v;
                }
                p = p->next;
            }
        }
        printf("\n"); // 一层遍历结束后换行
    }
}
```

### 8. DFS 遍历输出所有简单路径（s→t）

**场景**：输出从 `s` 到 `t` 的所有简单路径（无重复顶点），如路径规划的所有方案。

```c
// 辅助变量： path 存储当前路径， len 为路径长度
int path[MAXV];
int currentPathLen = 0; // 使用不同的变量名以避免与全局 len 冲突

void DFSAllPaths(ALGraph *G, int s, int t, bool visited[]) {
    visited[s] = true;             // 标记当前顶点已访问（当前路径中）
    path[currentPathLen++] = s;    // 当前顶点加入路径

    if (s == t) { // 到达目标，输出路径
        printf("路径： ");
        for (int i = 0; i < currentPathLen; i++) {
            printf("%d%s", path[i], (i == currentPathLen - 1) ? "\n" : "→");
        }
    } else {
        ArcNode *p = G->vertices[s].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            if (!visited[v]) { // 未访问过的邻接顶点才继续深搜
                DFSAllPaths(G, v, t, visited);
            }
            p = p->next;
        }
    }
    // 回溯：移除当前顶点，取消访问标记
    currentPathLen--;
    visited[s] = false;
}

// 调用入口
void PrintAllPaths(ALGraph *G, int s, int t) {
    if (s < 0 || s >= G->n || t < 0 || t >= G->n) return; // 顶点越界
    
    bool visited_for_paths[MAXV]; // 独立的 visited 数组，避免干扰
    memset(visited_for_paths, false, sizeof(visited_for_paths));
    currentPathLen = 0; // 重置路径长度
    
    DFSAllPaths(G, s, t, visited_for_paths);
}
```

### 9. Dijkstra 算法（邻接表 + 优先队列优化，O(elogn)）

**场景**：稀疏图的单源最短路径（如城市间的最短公路距离），408 高频优化考点。

```c
// 优先队列节点（距离+顶点）
typedef struct {
    int dist; // 距离
    int vex;  // 顶点索引
} PQNode;

// 小根堆调整（向下堆化）
void HeapAdjust(PQNode heap[], int size, int i) {
    int minIdx = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < size && heap[left].dist < heap[minIdx].dist) minIdx = left;
    if (right < size && heap[right].dist < heap[minIdx].dist) minIdx = right;

    if (minIdx != i) { // 如果父节点不是最小，则交换并递归
        PQNode temp = heap[i];
        heap[i] = heap[minIdx];
        heap[minIdx] = temp;
        HeapAdjust(heap, size, minIdx);
    }
}

// Dijkstra 邻接表优化（优先队列）
void DijkstraPQ(ALGraph *G, int s, int dist[], int path[]) {
    int n = G->n;
    memset(dist, 0x3f, n * sizeof(int)); // 初始化距离为无穷大
    memset(path, -1, n * sizeof(int));    // 初始化路径前驱为 -1
    dist[s] = 0; // 源点到自身距离为 0

    bool visited_pq[MAXV] = {false}; // 标记顶点是否已确定最短路径

    // 初始化优先队列（小根堆）
    PQNode heap[MAXV];
    int heapSize = 0;
    
    // 将源点及距离 0 插入堆
    heap[heapSize++] = (PQNode){0, s};

    // 向上调整堆（将刚插入的元素放到正确位置，这里是从底部向上调整一次）
    int i = heapSize - 1;
    while (i > 0 && heap[i].dist < heap[(i - 1) / 2].dist) {
        PQNode temp = heap[i];
        heap[i] = heap[(i - 1) / 2];
        heap[(i - 1) / 2] = temp;
        i = (i - 1) / 2;
    }

    while (heapSize > 0) {
        // 取出堆顶（距离最小的顶点）
        PQNode top = heap[0];
        heap[0] = heap[--heapSize]; // 移除堆顶
        HeapAdjust(heap, heapSize, 0); // 重新堆化
        
        int u = top.vex;
        
        // 如果 u 的最短路径已经确定过，跳过（防止重复处理）
        if (visited_pq[u]) continue; 
        visited_pq[u] = true; // 标记 u 的最短路径已确定

        // 松弛顶点 u 的所有邻接顶点
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            int weight = p->weight;
            
            // 如果 v 未确定最短路径，且通过 u 到 v 的路径更短
            if (!visited_pq[v] && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight; // 更新最短距离
                path[v] = u;                // 更新前驱
                
                // 新路径 (dist[v], v) 入堆
                heap[heapSize++] = (PQNode){dist[v], v};
                // 向上调整堆（将新元素放到正确位置）
                int current = heapSize - 1;
                while (current > 0 && heap[current].dist < heap[(current - 1) / 2].dist) {
                    PQNode temp_up = heap[current];
                    heap[current] = heap[(current - 1) / 2];
                    heap[(current - 1) / 2] = temp_up;
                    current = (current - 1) / 2;
                }
            }
            p = p->next;
        }
    }
}
```

### 10. Floyd 算法输出所有顶点对的最短路径

**场景**：打印任意两顶点间的最短路径（如交通网络的多城市路线规划）。

```c
// 输出 i 到 j 的最短路径（基于 Floyd 的 path 矩阵）
void PrintFloydPath(int path[][MAXV], int i, int j) {
    if (path[i][j] == -1 || path[i][j] == i) { // -1 表示无前驱，path[i][j]==i 表示 i 是 j 的直接前驱
        printf("%d", i); // 打印起始顶点
        if (i != j) printf(" %d", j); // 如果起点不是终点，打印终点
        return;
    }
    PrintFloydPath(path, i, path[i][j]); // 递归打印 i 到 path[i][j] 的路径
    printf(" %d", j); // 打印 j
}

// Floyd 算法+路径输出
void FloydWithPath(MGraph *G) {
    int n = G->n;
    int dist[MAXV][MAXV], path[MAXV][MAXV];

    // 初始化（与标准 Floyd 算法相同）
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = G->edges[i][j];
            path[i][j] = (dist[i][j] != INF && i != j) ? i : -1; // 如果 i!=j且可达，前驱为i
        }
    }

    // Floyd 核心 (与标准 Floyd 算法相同)
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = path[k][j];
                }
            }
        }
    }

    // 输出所有路径
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) continue; // 不打印自身到自身的路径

            printf("%d 到%d：", i, j);
            if (dist[i][j] == INF) {
                printf("不可达\n");
            } else {
                printf("距离%d，路径：", dist[i][j]);
                // 需要一个包装函数或在 PrintFloydPath 中处理起点
                PrintFloydPath(path, i, j);
                printf("\n");
            }
        }
    }
}
```

### 11. Bellman-Ford 算法检测负环

**场景**：判断图是否存在负权环（如金融网络的套利检测），408 低频。

```c
bool BellmanFordDetectNegativeCycle(ALGraph *G, int s) {
    int n = G->n;
    int dist[MAXV];
    
    // 初始化距离为无穷大
    memset(dist, 0x3f, n * sizeof(int));
    dist[s] = 0; // 源点到自身距离为 0

    // 松弛 n-1 次
    for (int i = 0; i < n - 1; i++) {
        bool updated = false; // 标记本轮是否有距离更新
        for (int u = 0; u < n; u++) {
            // 只对可达顶点进行松弛
            if (dist[u] == INF) continue; 

            ArcNode *p = G->vertices[u].firstarc;
            while (p != NULL) {
                int v = p->adjvex;
                int w = p->weight;
                if (dist[u] + w < dist[v]) { // 松弛条件
                    dist[v] = dist[u] + w;
                    updated = true;
                }
                p = p->next;
            }
        }
        if (!updated) break; // 本轮无更新，提前终止
    }

    // 第 n 次松弛：若仍能更新，则存在负环
    for (int u = 0; u < n; u++) {
        // 只对可达顶点进行检查
        if (dist[u] == INF) continue; 
        
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            int w = p->weight;
            if (dist[u] + w < dist[v]) {
                return true; // 存在负环
            }
            p = p->next;
        }
    }
    return false; // 无负环
}
```

### 12. 有权图的最短路径条数统计

**场景**：统计从 `s` 到 `t` 的最短路径数量（如网络路由的冗余路径统计）。

```c
// 假设 PQNode 和 HeapAdjust 已定义

int CountShortestPaths(ALGraph *G, int s, int t) {
    int n = G->n;
    int dist[MAXV], count[MAXV]; // dist: 最短距离，count: 最短路径条数

    memset(dist, 0x3f, n * sizeof(int)); // 初始化距离为无穷大
    memset(count, 0, n * sizeof(int));   // 初始化路径数为 0

    dist[s] = 0;
    count[s] = 1; // 起点到自身路径数为 1

    // 优先队列（小根堆）
    PQNode heap[MAXV];
    int heapSize = 0;
    heap[heapSize++] = (PQNode){0, s}; // 源点入堆

    // 向上调整堆（将源点放到正确位置）
    int current = heapSize - 1;
    while (current > 0 && heap[current].dist < heap[(current - 1) / 2].dist) {
        PQNode temp = heap[current];
        heap[current] = heap[(current - 1) / 2];
        heap[(current - 1) / 2] = temp;
        current = (current - 1) / 2;
    }

    while (heapSize > 0) {
        PQNode top = heap[0];
        heap[0] = heap[--heapSize];
        HeapAdjust(heap, heapSize, 0); // 重新堆化
        
        int u = top.vex;
        
        // 如果从堆中取出的距离 top.dist 已经大于已知的 dist[u]，则跳过
        // 这表示此路径不是最短的，或者已经处理过更短的路径
        if (top.dist > dist[u]) continue; 
        
        // 如果 u 已经是目标 t，可以提前跳出，因为最短路径已经找到并计数
        // 但为了完整性，通常会继续处理直到堆空
        // if (u == t) break; 

        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            int w = p->weight;

            if (dist[u] + w < dist[v]) {
                // 发现更短路径：更新距离，重置路径数
                dist[v] = dist[u] + w;
                count[v] = count[u];
                
                // 新路径入堆
                heap[heapSize++] = (PQNode){dist[v], v};
                // 向上调整堆
                current = heapSize - 1;
                while (current > 0 && heap[current].dist < heap[(current - 1) / 2].dist) {
                    PQNode temp = heap[current];
                    heap[current] = heap[(current - 1) / 2];
                    heap[(current - 1) / 2] = temp;
                    current = (current - 1) / 2;
                }
            } else if (dist[u] + w == dist[v]) {
                // 发现相同长度路径：累加路径数
                count[v] += count[u];
            }
            p = p->next;
        }
    }
    return (dist[t] == INF) ? 0 : count[t]; // 如果目标不可达，返回 0 条
}
```

### 13. Prim 算法（邻接表 + 优先队列，O(elogn)）

**场景**：稀疏图的最小生成树（如通信网络的最小布线成本）。

```c
// 假设 PQNode 和 HeapAdjust 已定义

int PrimPQ(ALGraph *G, int start) {
    int n = G->n;
    int lowcost[MAXV];    // lowcost[i] 存储顶点 i 到 MST 的最短边权
    int adjvex[MAXV];     // adjvex[i] 存储与顶点 i 形成 lowcost[i] 的 MST 中的顶点
    bool inMST[MAXV] = {false}; // 标记顶点是否已在 MST 中

    memset(lowcost, 0x3f, n * sizeof(int)); // 初始化 lowcost 为无穷大
    memset(adjvex, -1, n * sizeof(int));    // 初始化 adjvex 为 -1

    lowcost[start] = 0; // 起点到 MST (自身) 的距离为 0

    // 优先队列（小根堆），存储 (lowcost[i], i)
    PQNode heap[MAXV];
    int heapSize = 0;

    // 将所有顶点及其到 MST (初始只有 start) 的距离入堆
    for (int i = 0; i < n; i++) {
        // 如果不是起点，且从起点可达，则入堆
        // 初始时，lowcost[i] 对应 G->edges[start][i]
        // 这里简化为直接入堆，后续更新时会再次入堆，通过 inMST 过滤
        heap[heapSize++] = (PQNode){lowcost[i], i}; 
        // 向上调整堆
        int j = heapSize - 1;
        while (j > 0 && heap[j].dist < heap[(j-1)/2].dist) {
            PQNode temp = heap[j];
            heap[j] = heap[(j-1)/2];
            heap[(j-1)/2] = temp;
            j = (j-1)/2;
        }
    }

    int totalMSTWeight = 0;
    int edgesInMST = 0;

    while (heapSize > 0) {
        // 取出 lowcost 最小的顶点
        PQNode top = heap[0];
        heap[0] = heap[--heapSize];
        HeapAdjust(heap, heapSize, 0); // 重新堆化
        
        int u = top.vex;
        int cost = top.dist;

        // 如果 u 已经加入 MST，或者 cost 不是最新的 lowcost[u]，则跳过
        if (inMST[u] || cost > lowcost[u]) continue; 

        inMST[u] = true; // 将顶点 u 加入 MST
        totalMSTWeight += cost; // 累加这条边的权值
        edgesInMST++;

        // 如果已经添加了 n-1 条边，MST 已完成
        if (edgesInMST == n - 1) break;

        // 更新 u 的邻接顶点的 lowcost
        ArcNode *p = G->vertices[u].firstarc;
        while (p != NULL) {
            int v = p->adjvex;
            int w = p->weight;
            if (!inMST[v] && w < lowcost[v]) { // 如果 v 不在 MST 中，且 (u,v) 边更短
                lowcost[v] = w; // 更新 lowcost[v]
                adjvex[v] = u;  // v 现在通过 u 连接到 MST
                
                // 将新的 (lowcost[v], v) 入堆
                heap[heapSize++] = (PQNode){lowcost[v], v};
                // 向上调整堆
                int j = heapSize - 1;
                while (j > 0 && heap[j].dist < heap[(j-1)/2].dist) {
                    PQNode temp = heap[j];
                    heap[j] = heap[(j-1)/2];
                    heap[(j-1)/2] = temp;
                    j = (j-1)/2;
                }
            }
            p = p->next;
        }
    }
    // 检查是否连通（是否成功添加了 n-1 条边）
    return (edgesInMST == n - 1) ? totalMSTWeight : -1;
}
```

### 14. Kruskal 算法判断 MST 唯一性

**场景**：给定图，判断最小生成树是否唯一（如工程布线的方案唯一性）。

```c
// 假设 Edge 结构体，parent 数组，find/unionSet 函数，cmp 函数已定义

// Kruskal 判断 MST 唯一性（返回 true 表示唯一）
bool IsMSTUnique(Edge edges[], int e, int n) {
    int parent_unique[MAXV]; // 独立的并查集数组
    for (int i = 0; i < n; i++) parent_unique[i] = i;
    
    // 边按权值升序排序
    qsort(edges, e, sizeof(Edge), cmp); 

    int totalMSTWeight = 0;
    int edgeCount = 0; // 已选入 MST 的边数

    for (int i = 0; i < e; i++) {
        int u = edges[i].u, v = edges[i].v, w = edges[i].w;
        
        // 关键逻辑：检查当前权值 w 的边中，有多少条可以加入 MST
        int sameWCount = 0; // 记录与当前边权值相同且可加入 MST 的边数
        for (int j = i; j < e && edges[j].w == w; j++) {
            int ju = edges[j].u, jv = edges[j].v;
            // 如果 edges[j] 不构成环，则可以加入 MST
            if (find(ju) != find(jv)) { 
                sameWCount++;
            }
        }
        // 如果当前权值 `w` 的边中，有 2 条或更多可以加入 MST，
        // 且这些边中至少有一条最终会被选择（即当前边 `edges[i]` 会被选），
        // 那么 MST 不唯一。
        // 简化判断：只要当前权值有多个选择，就认为不唯一
        if (sameWCount > 1 && find(u) != find(v)) { 
            return false;
        }

        if (find(u) != find(v)) { // 如果当前边不构成环
            unionSet(u, v);          // 合并
            totalMSTWeight += w;     // 累加权值
            edgeCount++;             // 计数
            if (edgeCount == n - 1) break; // 选够 n-1 条边
        }
    }
    // 如果最终选够 n-1 条边，则判断唯一性（之前已检查过）
    // 否则图不连通，无唯一 MST
    return (edgeCount == n - 1) ? true : false;
}
```

### 15. MST 的边输出（Kruskal）

**场景**：输出最小生成树的所有边（如工程布线的具体路线）。

```c
// 假设 Edge 结构体，parent 数组，find/unionSet 函数，cmp 函数已定义

void PrintMSTEdges(Edge edges[], int e, int n) {
    int parent_print[MAXV]; // 独立的并查集数组
    for (int i = 0; i < n; i++) parent_print[i] = i;
    
    // 边按权值升序排序
    qsort(edges, e, sizeof(Edge), cmp);

    printf("MST 的边： \n");
    int edgeCount = 0; // 已选边数

    for (int i = 0; i < e && edgeCount < n - 1; i++) {
        int u = edges[i].u, v = edges[i].v, w = edges[i].w;
        if (find(u) != find(v)) { // 如果不构成环
            unionSet(u, v);          // 合并
            printf("%d--%d (权值%d) \n", u, v, w); // 打印边
            edgeCount++;             // 计数
        }
    }
    if (edgeCount != n - 1) {
        printf("图不连通，无 MST\n");
    }
}
```

### 16. 课程安排问题（拓扑排序）

**场景**：给定课程依赖关系（如 `A→B` 表示 `A` 是 `B` 的先修课），判断是否能完成所有课程。

```c
// 假设 ALGraph 结构体，InitALGraph，AddEdgeDirAL，TopologicalSort 函数已定义

bool CanFinishCourses(int numCourses, int prerequisites[][2], int prereqNum) {
    ALGraph G;
    InitALGraph(&G, numCourses); // 初始化图，顶点数即课程数

    // 构建图：prerequisites[i][0] 是当前课程，prerequisites[i][1] 是先修课
    // 即先修课 -> 当前课程
    for (int i = 0; i < prereqNum; i++) {
        int currentCourse = prerequisites[i][0]; // 课程 a
        int prerequisite = prerequisites[i][1];  // 先修课 b
        AddEdgeDirAL(&G, prerequisite, currentCourse, 1); // b→a：修 b 才能修 a
    }

    // 拓扑排序
    int topo[MAXV]; // 存储拓扑序列
    int count = TopologicalSort(&G, topo); // count 为拓扑序列长度

    // 释放图内存（此处简化，实际需遍历邻接表释放 ArcNode 内存）
    // For (int i=0; i<G.n; i++) { ArcNode *p = G.vertices[i].firstarc; while(p){ ArcNode *temp = p; p = p->next; free(temp); } }

    return count == numCourses; // 如果拓扑序列长度等于课程总数，则可以完成所有课程（无环）
}
```

### 17. 关键路径的工期压缩

**场景**：缩短某关键活动的工期，计算新的项目总工期（如工程进度优化）。

```c
// 假设 ALGraph 结构体，CriticalPath 函数已定义

// 缩短活动 u→v 的工期 delta，返回新总工期
int CompressCriticalActivity(ALGraph *G, int u, int v, int delta) {
    if (delta <= 0) {
        printf("无效的工期缩短量。\n");
        return CriticalPath(G); // 不缩短或无效缩短
    }
    if (u < 0 || u >= G->n || v < 0 || v >= G->n) {
        printf("活动顶点越界。\n");
        return CriticalPath(G);
    }

    // 1. 找到并缩短活动 u→v 的工期
    ArcNode *p = G->vertices[u].firstarc;
    bool found = false;
    while (p != NULL) {
        if (p->adjvex == v) {
            p->weight -= delta; // 缩短工期
            if (p->weight < 0) p->weight = 0; // 工期不能为负
            found = true;
            break;
        }
        p = p->next;
    }

    if (!found) {
        printf("未找到活动 %d->%d，无法压缩。\n", u, v);
        return CriticalPath(G); // 未找到此活动
    }

    // 2. 重新计算关键路径
    return CriticalPath(G);
}
```

### 18. 任务调度的拓扑序列数量

**场景**：计算所有可能的拓扑序列数量（如任务安排的方案数）。

```c
// 辅助变量：记录入度（避免修改原数组）
int tempInDegree[MAXV];

// 回溯法计算拓扑序列数量
int BacktrackTopoCount(ALGraph *G, int currentCount, int totalVertices) {
    if (currentCount == totalVertices) {
        return 1; // 生成一个完整的拓扑序列
    }
    
    int res = 0;
    // 遍历所有入度为 0 的顶点
    for (int v = 0; v < G->n; v++) {
        if (tempInDegree[v] == 0) {
            // 1. 选择 v 加入序列
            tempInDegree[v] = -1; // 标记为已选（入度不再为 0）
            
            // 2. 减少其邻接顶点入度
            ArcNode *p = G->vertices[v].firstarc;
            while (p != NULL) {
                tempInDegree[p->adjvex]--;
                p = p->next;
            }
            
            // 3. 递归：继续生成下一个序列
            res += BacktrackTopoCount(G, currentCount + 1, totalVertices);
            
            // 4. 回溯：恢复入度，取消标记
            p = G->vertices[v].firstarc;
            while (p != NULL) {
                tempInDegree[p->adjvex]++;
                p = p->next;
            }
            tempInDegree[v] = 0; // 恢复为未选状态
        }
    }
    return res;
}

// 调用入口
int CountTopoSequences(ALGraph *G) {
    // 初始化临时入度
    memset(tempInDegree, 0, G->n * sizeof(int));
    for (int v = 0; v < G->n; v++) {
        ArcNode *p = G->vertices[v].firstarc;
        while (p != NULL) {
            tempInDegree[p->adjvex]++;
            p = p->next;
        }
    }
    return BacktrackTopoCount(G, 0, G->n);
}
```

### 19. 无向图的桥检测（Tarjan 算法）

**场景**：找出无向图中的所有桥（删除后图连通分量增加的边），如网络故障点定位。

```c
// 辅助变量： disc（发现时间）、 low（能到达的最早发现时间）、 time
int disc[MAXV], low[MAXV];
int tarjanTime = 0; // 使用 tarjanTime 避免与全局变量 time 冲突

// 辅助函数：Tarjan 算法核心
void TarjanBridge(ALGraph *G, int u, int parent) {
    disc[u] = low[u] = ++tarjanTime; // 发现时间 & 最早可回溯时间
    
    ArcNode *p = G->vertices[u].firstarc;
    while (p != NULL) {
        int v = p->adjvex;
        if (v == parent) { // 避免遍历到父节点（即来时边）
            p = p->next; 
            continue; 
        }

        if (disc[v] == 0) { // 未访问过 v
            TarjanBridge(G, v, u); // 递归访问 v
            // 更新 u 的最早可回溯时间
            low[u] = (low[u] < low[v]) ? low[u] : low[v];
            
            // 如果 low[v] > disc[u]，说明 v 无法通过回边到达 u 及其祖先，u-v 是桥
            if (low[v] > disc[u]) { 
                printf("桥： %d--%d\n", u, v);
            }
        } else { // v 已访问过 (回边或横叉边)
            // 更新 u 的最早可回溯时间（通过回边可以到达 v）
            low[u] = (low[u] < disc[v]) ? low[u] : disc[v];
        }
        p = p->next;
    }
}

// 调用入口
void FindBridges(ALGraph *G) {
    memset(disc, 0, G->n * sizeof(int)); // 初始化发现时间为 0 (未访问)
    memset(low, 0, G->n * sizeof(int));  // 初始化最早可回溯时间
    tarjanTime = 0; // 重置时间戳

    for (int v = 0; v < G->n; v++) {
        if (disc[v] == 0) { // 如果 v 未被访问，开始 DFS
            TarjanBridge(G, v, -1); // -1 表示无父节点 (根节点)
        }
    }
}
```

### 20. 网络流最大流（Ford-Fulkerson 算法，DFS 实现）

**场景**：求源点 `s` 到汇点 `t` 的最大流（如水管网络的最大输水能力），408 低频。

```c
// 残留网络（邻接矩阵， 0 表示无残留容量）
int residual[MAXV][MAXV];
bool visited_flow[MAXV]; // 独立的访问标记数组

// DFS 找增广路径，返回可增广的流量
int DFSFlow(int s, int t, int currentMinFlow) {
    if (s == t) return currentMinFlow; // 到达汇点，返回当前路径的最小流量
    visited_flow[s] = true; // 标记 s 已访问

    for (int v = 0; v < MAXV; v++) { // 遍历所有可能的邻接点 v
        // 如果 v 未访问，且 s 到 v 在残留网络中有容量
        if (!visited_flow[v] && residual[s][v] > 0) {
            // 计算当前路径可增广的流量
            int augFlow = DFSFlow(v, t, (currentMinFlow < residual[s][v]) ? currentMinFlow : residual[s][v]);
            if (augFlow > 0) {
                // 更新残留网络：正向边减少，反向边增加
                residual[s][v] -= augFlow; // 正向边减少
                residual[v][s] += augFlow; // 反向边增加（用于回溯流量）
                return augFlow;
            }
        }
    }
    return 0; // 无增广路径
}

// Ford-Fulkerson 算法求最大流
int MaxFlow(int s, int t, MGraph *G) {
    // 初始化残留网络（残留容量=原边权）
    memset(residual, 0, sizeof(residual));
    for (int i = 0; i < G->n; i++) {
        for (int j = 0; j < G->n; j++) {
            if (G->edges[i][j] != INF && G->edges[i][j] != 0) {
                residual[i][j] = G->edges[i][j]; // 正向边容量
                // residual[j][i] = 0; // 反向边初始容量为 0 (已由 memset 保证)
            }
        }
    }

    int maxFlow = 0;
    while (1) {
        memset(visited_flow, false, sizeof(visited_flow)); // 每轮 DFS 重新初始化访问标记
        int augFlow = DFSFlow(s, t, INF); // 寻找增广路径，INF 表示无穷大初始流量
        if (augFlow == 0) break;           // 无增广路径，终止
        maxFlow += augFlow;                // 累加最大流
    }
    return maxFlow;
}
```

---

## 三、图模板使用技巧

### 一、存储结构的科学选择

图的存储结构直接影响算法效率，需根据图的稠密程度与操作需求精准匹配。

*   **邻接矩阵**：以二维数组存储边信息，空间复杂度为 O(n²)。
    *   **优势**：判断两顶点是否相连、获取边权值仅需 O(1) 时间（“随机访问”）。
    *   **适用场景**：适合**稠密图**（边数 `e` 接近 `n²`），如电路连接图、完全图等。尤其适配 **Floyd 算法**（需频繁访问任意 `i`、`j` 间的权值）和 **Prim 算法**（需快速获取顶点到 MST 的最小边权）。
    *   **局限性**：对于稀疏图会造成大量空间浪费。
*   **邻接表**：以“顶点数组 + 链表”存储，空间复杂度为 O(n+e)。
    *   **优势**：能高效存储稀疏图。遍历某顶点的所有邻接边仅需 O(k) 时间（`k` 为该顶点的度，即“批量访问邻接顶点”）。
    *   **适用场景**：适合**稀疏图**（`e` 远小于 `n²`）。是**遍历（DFS/BFS）、拓扑排序、Kruskal 算法**的理想选择——这些操作均需频繁访问顶点的邻接边，而非随机查询任意边。

### 二、算法适用场景的精准匹配

不同图算法有明确的适用边界，需结合问题场景选择最优解。

*   **最短路径问题**：
    *   **Dijkstra 算法**：单源最短路径，时间复杂度 O(n²)（邻接矩阵版），仅适用于**非负权图**。
    *   **Floyd 算法**：多源最短路径，时间复杂度 O(n³)，支持**负权边但无法处理负环**。
    *   **Bellman-Ford 算法**：单源最短路径，可处理**含负权边**的问题，甚至能**检测负环**，但时间复杂度 O(ne) 较高。
*   **最小生成树（MST）**：
    *   **Prim 算法**：从顶点出发，每次扩展最短边，时间复杂度 O(n²)，在**稠密图**中效率更高。
    *   **Kruskal 算法**：从边出发，需先排序边（O(eloge)），再用并查集检测环，在**稀疏图**中效率更高。
*   **拓扑排序**：
    *   **拓扑排序**是**有向无环图（DAG）**的专属工具，既能生成依赖关系序列，也能通过序列长度是否等于顶点数来**检测环**。
    *   **关键路径**：作为拓扑排序的延伸，通过计算最早/最晚发生时间，定位影响项目总工期的**关键活动**。

### 三、易错点的深度规避

图算法的错误多源于对细节和边界的忽视，需重点关注三类问题。

1.  **边界处理**：
    *   **空图**：需特殊初始化（邻接矩阵全为 `INF`，邻接表指针为空）。
    *   **非连通图**：遍历需多次调用 DFS/BFS（每次处理一个连通分量），否则会遗漏顶点。
    *   **自环（`i==j`）**：需在邻接矩阵中特殊标记（权值非 0），邻接表则正常添加。
    *   **重边**：通常保留最小权值（避免冗余计算），或根据题目要求处理。
2.  **算法限制条件不可突破**：
    *   **Dijkstra**：处理负权边会得到错误结果。
    *   **Floyd**：遇到负环会陷入无限更新（需额外检测）。
    *   **拓扑排序**：在有环图中无法生成完整序列（可用于环检测）。
3.  **辅助结构的正确使用**：
    *   **BFS 的队列**：需初始化空，且是循环队列实现。
    *   **Kruskal 的并查集**：必须实现**路径压缩（`find` 函数）**和**按秩合并**，否则会退化为 O(n) 查询，导致总复杂度变高。
    *   **拓扑排序的入度计算**：需遍历所有边（邻接表中需逐个顶点扫描其邻接边），漏算会导致入度不为 0 的顶点被错误入队。
    *   **访问标记数组 `visited`**：通常是全局变量，在每次新的遍历或算法调用前**必须重置**（`memset(visited, false, sizeof(visited))`），避免上一次访问状态干扰。

掌握存储结构的选择逻辑、算法适用场景及易错点，可覆盖 408 图算法 95% 以上考点。备考时需通过手动模拟（如 Dijkstra 的松弛过程、拓扑排序的入度变化）深化理解，结合真题强化时间复杂度分析与场景匹配能力，方能高效解题。
```
