---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---
<center>🚀 链表算法题模板：核心操作与高频考点速查 🚀</center>
#### **引言**

链表作为数据结构的基础，其灵活性和指针操作的复杂性使其成为 408 考研的重中之重。掌握单链表、双链表、循环链表的基础结构定义、初始化及各项基本操作，是解决复杂链表算法题的关键。本模板旨在提供一份全面、规范的代码实现与考点分析，助你攻克链表难题！

---

### **一、链表基础结构与操作模板**

#### **1.1 单链表 (Singly Linked List)**

**特点:** 每个结点只包含指向其后继结点的指针，只能单向遍历。

##### **1.1.1 单链表节点定义**

```c
typedef struct LNode {
    int data;            // 数据域（根据题意可改为 char, float 或自定义结构体）
    struct LNode *next;  // 指针域，指向下一个节点
} LNode, *LinkList; // LNode 为结点类型，LinkList 为指向结点的指针类型（常用于头指针）
```

> [!NOTE] 考点
> 节点定义是所有链表操作的基础。408 真题中数据域可能为 `int`、`char` 或自定义结构体（如学生信息）。理解 `typedef` 的作用。

##### **1.1.2 链表初始化（带头节点）**

```c
// 初始化空链表（带头节点，避免插入删除时处理头节点特殊情况）
LinkList InitList() {
    LNode *head = (LNode*)malloc(sizeof(LNode)); // 分配头节点空间
    if (head == NULL) { // 考点：内存分配失败检查（易忽略）
        // 可以根据实际情况选择返回 NULL 或进行错误处理
        return NULL;
    }
    head->next = NULL; // 头节点指针域为空，表示链表为空
    return head;
}
```

> [!TIP] 优势
> 带头节点的链表可统一插入/删除逻辑（无需单独处理首元节点），408 考题优先采用此结构，强烈推荐！

##### **1.1.3 插入节点（后插法）**

在给定节点 `p` 之后插入一个值为 `e` 的新节点 `s`。

```c
// 在 p 节点之后插入值为 e 的节点
bool InsertNextNode(LNode *p, int e) {
    if (p == NULL) return false; // p 为 NULL 时插入失败（无插入位置）

    LNode *s = (LNode*)malloc(sizeof(LNode)); // 创建新节点
    if (s == NULL) return false; // 内存分配失败

    s->data = e;      // 赋值数据
    s->next = p->next; // 新节点 s 指向 p 的原后继节点
    p->next = s;      // p 的 next 指向新节点 s

    return true;
}
```

> [!WARNING] 易错点
> *   `p == NULL` 判断：插入前必须检查 `p` 是否为空，否则会导致对空指针解引用。
> *   内存分配失败判断：`malloc` 返回 `NULL` 时需处理。
> *   指针调整顺序：先将 `s->next` 指向 `p->next`，再将 `p->next` 指向 `s`，顺序不能错。

##### **1.1.4 删除指定节点的后继节点**

场景：已知前驱节点 `p`，删除其直接后继。时间复杂度 $O(1)$。

```c
// 单链表：删除 p 节点的后继节点，并通过指针 e 存储删除值
bool LinkListDeleteNext(LNode *p, int *e) {
    // 1. 合法性检查（考点 1：p 为空或 p 无后继，无法删除）
    if (p == NULL || p->next == NULL) {
        printf("删除失败：p 为空或无后继节点\n");
        return false;
    }

    // 2. 定位待删除节点 q（p 的后继）
    LNode *q = p->next;

    // 3. 保存删除值（考点 2：按考题要求返回删除元素）
    if (e != NULL) { // 确保 e 是有效指针
        *e = q->data;
    }

    // 4. 调整指针：p 跳过 q 指向其后继（断开 q）
    p->next = q->next;

    // 5. 释放节点（考点 3：避免内存泄漏，必做步骤）
    free(q);
    q = NULL; // 避免野指针

    return true;
}
```

> [!WARNING] 易错点
> *   遗漏 `p->next == NULL` 的判断，导致访问空指针。
> *   删除后未 `free` 节点，造成内存泄漏。
> *   **单链表无法直接删除“指定节点”**：如果只知道要删除的节点 `q`，而不知道它的前驱 `p`，则需要从头遍历链表找到 `p`，时间复杂度为 $O(n)$。此操作仅适用于“已知前驱”场景。

#### **1.2 双链表 (Doubly Linked List)**

**特点:** 每个结点包含指向其前驱结点和后继结点的两个指针，支持双向遍历。

##### **1.2.1 双链表节点定义**

```c
typedef struct DNode {
    int data;           // 数据域（可改为结构体，同单链表）
    struct DNode *prev; // 前驱指针（指向前一个节点）
    struct DNode *next; // 后继指针（指向后一个节点）
} DNode, *DLinkList;
```

> [!NOTE] 考点
> 双链表的核心是“双向指针”。408 真题中若涉及“反向遍历”、“前后节点操作”（如删除指定节点无需前驱），优先考虑双链表。

##### **1.2.2 双链表初始化（带头节点）**

```c
// 初始化空双链表（带头节点，统一操作逻辑）
DLinkList DInitList() {
    DNode *head = (DNode*)malloc(sizeof(DNode));
    if (head == NULL) return NULL; // 考点：内存分配失败处理（易忽略）
    head->prev = NULL; // 头节点无前驱（若为双循环链表，需指向自身）
    head->next = NULL; // 头节点无后继
    return head;
}
```

> [!TIP] 优势
> 带头节点的双链表可避免插入/删除首元节点时的特殊判断，且双向指针支持灵活遍历。

##### **1.2.3 双链表插入节点（后插法， $O(1)$ 时间）**

在给定节点 `p` 之后插入值为 `e` 的新节点 `s`。

```c
// 在 p 节点之后插入值为 e 的节点（双链表核心操作）
bool DInsertNextNode(DNode *p, int e) {
    if (p == NULL) return false; // p 为 NULL 时插入无效

    DNode *s = (DNode*)malloc(sizeof(DNode));
    if (s == NULL) return false; // 内存分配失败

    s->data = e;

    // 2. 调整指针（考点：双链表需同时处理前驱和后继，顺序不可错）
    s->prev = p;        // 新节点 s 的前驱指向 p
    s->next = p->next;  // 新节点 s 的后继指向 p 的原后继

    if (p->next != NULL) { // 若 p 有后继节点，需要更新其前驱指针
        p->next->prev = s; // p 的原后继节点的前驱指针指向新节点 s
    }
    p->next = s;         // p 的后继指针指向新节点 s

    return true;
}
```

> [!WARNING] 易错点
> *   若 `p->next != NULL`，必须更新 `p->next->prev = s`，否则会破坏双链表的双向关联。
> *   指针调整顺序：先连新节点 `s` 的前驱和后继指针，再修改原节点 `p` 和 `p->next` 的指针，避免在调整过程中“断链”。

##### **1.2.4 双链表：删除指定节点 p（非头节点， $O(1)$ 操作）**

场景：双链表因有前驱指针，可直接删除指定节点 `p`（无需遍历找前驱）。需确保 `p` 非头节点。

```c
// 双链表：删除指定节点 p（p 非头节点），e 存储删除值
bool DLinkListDeleteNode(DLinkList L, DNode *p, int *e) {
    // 1. 合法性检查（p 为空、p 是头节点、链表空）
    if (p == NULL || p == L || L->next == NULL) {
        printf("删除失败：p 非法或链表空\n");
        return false;
    }

    // 2. 保存删除值
    if (e != NULL) {
        *e = p->data;
    }

    // 3. 调整指针（考点 1：双链表需同步处理前驱和后继）
    p->prev->next = p->next; // p 的前驱指向 p 的后继
    // 注意：如果 p 是最后一个数据节点，p->next 会是 NULL，需要判断！
    if (p->next != NULL) {
        p->next->prev = p->prev; // p 的后继指向 p 的前驱
    }

    // 4. 释放节点
    free(p);
    p = NULL; // 避免野指针
    return true;
}
```

> [!TIP] 优势
> 对比单链表，双链表删除指定节点无需遍历 (时间复杂度 $O(1)$ vs $O(n)$)，是 408 “优化时间复杂度”的典型场景。

> [!WARNING] 易错点
> *   遗漏 `p->next != NULL` 的判断，尤其是当 `p` 是最后一个数据节点时，`p->next` 为 `NULL`，直接访问 `p->next->prev` 会出错。
> *   只处理前驱指针，而未处理后继指针（`p->next->prev = p->prev`），会破坏双链表的双向关联。

#### **1.3 循环链表 (Circular Linked List)**

**特点:** 尾节点的指针域不为空，而是指向头节点或首元结点，形成一个环形结构。适合环形数据场景（如约瑟夫问题）。

##### **1.3.1 单循环链表 (Singly Circular Linked List)**

仅需修改单链表的尾节点指针，使其指向头节点，形成环形结构。

**1.3.1.1 单循环链表节点定义（复用单链表节点）**

```c
// 直接复用单链表节点定义（仅需修改指针关联逻辑）
typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList, *CirLinkList; // CirLinkList 为单循环链表类型别名
```

**1.3.1.2 单循环链表初始化（带头节点）**

```c
// 初始化空单循环链表（头节点 next 指向自身，形成循环）
CirLinkList CirInitList() {
    LNode *head = (LNode*)malloc(sizeof(LNode));
    if (head == NULL) return NULL;
    head->next = head; // 考点：循环标志——头节点后继指向自身（区别于单链表）
    return head;
}
```

> [!NOTE] 判空条件
> 单循环链表为空时，`head->next == head`（而非 `head->next == NULL`，这是易错点）。

**1.3.1.3 单循环链表插入节点（后插法）**

在给定节点 `p` 之后插入值为 `e` 的新节点 `s`，同时保持循环结构。

```c
// 在 p 节点之后插入值为 e 的节点（保持循环结构）
bool CirInsertNextNode(LNode *p, int e) {
    if (p == NULL) return false;

    LNode *s = (LNode*)malloc(sizeof(LNode));
    if (s == NULL) return false;
    s->data = e;

    // 2. 调整指针（保证插入后仍为循环）
    s->next = p->next; // 新节点 s 的后继指向 p 的原后继
    p->next = s;       // p 的后继指向新节点 s

    return true;
}
```

> [!KEY] 关键
> 无论插入位置是否为尾节点，因为原链表是循环的（尾节点 `next` 会指向头节点），插入后新节点的 `next` 会自然指向正确节点，无需额外处理循环性。

**1.3.1.4 单循环链表：删除指定节点 p 的后继节点（保持循环性）**

场景：单循环链表删除节点后需维持“尾节点指向头节点”的循环结构（408 循环链表高频考点，如约瑟夫问题预处理）。时间复杂度 $O(1)$。

```c
// 单循环链表：删除 p 节点的后继节点，e 存储删除值
bool CirLinkListDeleteNext(CirLinkList CL, LNode *p, int *e) {
    // 1. 合法性检查
    // 循环链表空：CL->next == CL；p 为空；p 无有效后继（p->next == CL 说明 p 是尾节点，且没有其他数据节点）
    if (CL->next == CL || p == NULL || p->next == CL) {
        printf("删除失败：链表空或 p 无有效后继\n");
        return false;
    }

    // 2. 定位待删除节点 q（p 的后继，非头节点）
    LNode *q = p->next;

    // 3. 保存删除值
    if (e != NULL) {
        *e = q->data;
    }

    // 4. 调整指针（考点 1：保持循环结构）
    p->next = q->next;

    // 5. 释放节点
    free(q);
    q = NULL;
    return true;
}
```

> [!NOTE] 考点与关键
> *   **判空条件：** 单循环链表空时 `CL->next == CL`。
> *   **循环性维持：** 若 `q` 是尾节点（即 `q->next == CL`），删除后 `p->next = CL`，仍保持新的尾节点（`p`）指向头节点，循环结构不变。

##### **1.3.2 双循环链表 (Doubly Circular Linked List)**

需同时让头节点的 `prev` 指向尾节点、尾节点的 `next` 指向头节点，实现双向循环。

**1.3.2.1 双循环链表节点定义（复用双链表节点）**

```c
// 复用双链表节点定义
typedef struct DNode {
    int data;
    struct DNode *prev;
    struct DNode *next;
} DNode, *DLinkList, *DCirLinkList; // DCirLinkList 为双循环链表类型别名
```

**1.3.2.2 双循环链表初始化（带头节点）**

```c
// 初始化空双循环链表（头节点 prev 和 next 均指向自身）
DCirLinkList DCirInitList() {
    DNode *head = (DNode*)malloc(sizeof(DNode));
    if (head == NULL) return NULL;
    // 考点：双向循环标志——头节点前驱和后继均指向自身
    head->prev = head;
    head->next = head;
    return head;
}
```

> [!NOTE] 判空条件
> `head->next == head`（同单循环），或 `head->prev == head`（双向循环特性）。

**1.3.2.3 双循环链表插入节点（后插法）**

在 `p` 节点之后插入值为 `e` 的节点，保持双向循环。

```c
// 在 p 节点之后插入值为 e 的节点（保持双向循环）
bool DCirInsertNextNode(DNode *p, int e) {
    if (p == NULL) return false;

    DNode *s = (DNode*)malloc(sizeof(DNode));
    if (s == NULL) return false;
    s->data = e;

    // 2. 调整指针（双向循环需同时处理 prev 和 next）
    s->prev = p;         // 新节点前驱指向 p
    s->next = p->next;   // 新节点后继指向 p 的原后继
    p->next->prev = s;   // p 原后继的前驱指向 s（双循环中 p->next 不会为 NULL，因循环）
    p->next = s;         // p 的后继指向 s

    return true;
}
```

> [!TIP] 优势
> 双循环链表中，`p->next` 永远不为 `NULL`（即使 `p` 是尾节点，`p->next` 也是头节点），因此无需判断 `p->next != NULL`，简化了插入逻辑（区别于普通双链表）。

---

### **二、高频应用场景模板 (链表)**

#### **2.1 单链表高频应用场景模板**

##### **2.1.1 单链表创建（尾插法）**

功能：通过数组初始化单链表（尾插法保证元素顺序与数组一致）

```c
// 用数组 arr 创建单链表，返回头节点
LinkList LinkListCreate(int arr[], int n) {
    LinkList L = InitList(); // 复用之前的初始化函数
    if (L == NULL) return NULL;

    LNode *tail = L; // 尾指针，用于快速插入
    for (int i = 0; i < n; i++) {
        InsertNextNode(tail, arr[i]); // 复用后插法
        tail = tail->next; // 尾指针后移
    }
    return L;
}
```

> [!NOTE] 考点
> 尾插法时间复杂度 $O(n)$，需维护尾指针避免每次遍历找尾；408 常考“从输入数据构建链表”场景。

##### **2.1.2 单链表遍历（打印元素）**

功能：遍历并打印链表所有元素，用于验证操作结果

```c
void LinkListTraverse(LinkList L) {
    if (L == NULL || L->next == NULL) { // 检查链表是否为空
        printf("链表为空\n");
        return;
    }
    LNode *p = L->next; // 从第一个数据结点开始
    printf("链表元素： ");
    while (p != NULL) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}
```

> [!WARNING] 易错点
> 遍历终止条件为 `p == NULL`（而非 `p->next == NULL`），避免遗漏最后一个节点。

##### **2.1.3 单链表求长度**

功能：统计链表有效元素个数（不含头节点）

```c
int LinkListLength(LinkList L) {
    if (L == NULL || L->next == NULL) return 0; // 空链表长度为0
    int len = 0;
    LNode *p = L->next;
    while (p != NULL) {
        len++;
        p = p->next;
    }
    return len;
}
```

> [!NOTE] 考点
> 基础操作，常作为其他算法的前置步骤（如找中间节点、相交判断）。

##### **2.1.4 单链表反转（迭代法）**

功能：反转链表元素顺序（如 `1→2→3→NULL` 反转为 `3→2→1→NULL`）

```c
LinkList LinkListReverse(LinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return L; // 空、单节点无需反转
    LNode *pre = NULL, *cur = L->next, *next = NULL;
    while (cur != NULL) {
        next = cur->next; // 缓存后继，防止断链
        cur->next = pre; // 反转当前节点的指针，指向前一个节点
        pre = cur;       // pre 指针后移
        cur = next;      // cur 指针后移
    }
    L->next = pre; // 头节点指向新首元节点（原尾节点）
    return L;
}
```

> [!NOTE] 考点
> 408 必考，时间 $O(n)$、空间 $O(1)$；核心是“断链 - 反转 - 移动”三步，需缓存 `next` 避免断链。

##### **2.1.5 单链表反转（递归法）**

功能：递归实现链表反转（适合理解递归逻辑，408 可能考思路）

```c
// 递归辅助函数：反转以 cur 为头的子链表，返回新头
LNode* reverseHelper(LNode *cur) {
    if (cur == NULL || cur->next == NULL) return cur; // base case：空或单节点
    LNode *newHead = reverseHelper(cur->next); // 递归反转后续节点，newHead 是原链表的尾节点
    cur->next->next = cur; // 让原后继节点（现在是新链表的倒数第二个节点）指向当前节点（反转）
    cur->next = NULL; // 断开当前节点与原后继的链接（避免形成环）
    return newHead; // 返回新链表的头节点
}

// 递归反转链表主函数
LinkList LinkListReverseRecur(LinkList L) {
    if (L == NULL) return NULL; // 处理空头节点情况
    L->next = reverseHelper(L->next);
    return L;
}
```

> [!WARNING] 易错点
> 递归终止后需将原首元节点的 `next` 设为 `NULL`，否则会形成环。

##### **2.1.6 单链表检测环（判断是否有环，并找环入口）**

功能：找到环的入口节点 (若无环则返回 `NULL`)

```c
LNode* LinkListCycleEntry(LinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return NULL; // 空、单、双节点不可能有环

    // 1. 先判断是否有环 (快慢指针法)
    LNode *slow = L->next, *fast = L->next; // 从第一个数据节点开始
    bool hasCycle = false;
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;        // 慢指针走一步
        fast = fast->next->next;  // 快指针走两步
        if (slow == fast) {       // 相遇则有环
            hasCycle = true;
            break;
        }
    }

    if (!hasCycle) return NULL; // 无环，直接返回 NULL

    // 2. 找环入口：慢指针从头开始，快慢同步移动，相遇即入口
    slow = L->next; // 慢指针回到头结点（的后继）
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow; // 返回环的入口节点
}
```

> [!NOTE] 考点
> 数学证明：头节点到环入口的距离 = 相遇点到环入口的距离（环长的整数倍）。时间 $O(n)$，空间 $O(1)$。

##### **2.1.7 单链表求环长度（有环时）**

功能：计算环的节点个数

```c
int LinkListCycleLength(LinkList L) {
    LNode *entry = LinkListCycleEntry(L); // 先找到环的入口
    if (entry == NULL) return 0; // 无环

    int len = 1;
    LNode *p = entry->next;
    while (p != entry) { // 从入口出发，绕环一周回到入口
        len++;
        p = p->next;
    }
    return len;
}
```

> [!NOTE] 原理
> 从环入口节点出发，再次回到入口的节点数即为环长。

##### **2.1.8 单链表判断相交（两链表是否有公共节点）**

功能：判断两个单链表是否相交，返回第一个交点 (若无则返回 `NULL`)

```c
LNode* LinkListGetIntersection(LinkList L1, LinkList L2) {
    if (L1 == NULL || L1->next == NULL || L2 == NULL || L2->next == NULL) return NULL; // 任意链表为空则不相交

    // 1. 计算两链表长度
    int len1 = 0, len2 = 0;
    LNode *p1 = L1->next, *p2 = L2->next;
    while (p1 != NULL) { len1++; p1 = p1->next; }
    while (p2 != NULL) { len2++; p2 = p2->next; }

    // 2. 长链表先走长度差，对齐两链表
    p1 = L1->next; p2 = L2->next; // 重置指针到第一个数据节点

    if (len1 > len2) {
        for (int i = 0; i < len1 - len2; i++) p1 = p1->next;
    } else {
        for (int i = 0; i < len2 - len1; i++) p2 = p2->next;
    }

    // 3. 同步移动，相遇即交点
    while (p1 != NULL && p2 != NULL) {
        if (p1 == p2) return p1; // 找到第一个交点
        p1 = p1->next;
        p2 = p2->next;
    }
    return NULL; // 没有交点
}
```

> [!TIP] 优势
> 空间 $O(1)$（直接调整指针，不新建节点），时间 $O(n+m)$。408 高频考点。

##### **2.1.9 单链表合并两个有序链表（升序→升序）**

功能：合并两个递增有序链表，返回新有序链表

```c
LinkList LinkListMergeTwoSorted(LinkList L1, LinkList L2) {
    LinkList L = InitList(); // 新链表头节点
    if (L == NULL) return NULL; // 内存分配失败

    LNode *p = L; // 尾指针，用于拼接
    LNode *p1 = L1->next, *p2 = L2->next; // 从第一个数据节点开始比较

    while (p1 != NULL && p2 != NULL) {
        if (p1->data <= p2->data) {
            p->next = p1;
            p1 = p1->next;
        } else {
            p->next = p2;
            p2 = p2->next;
        }
        p = p->next; // 尾指针后移
    }

    // 拼接剩余节点（其中一个链表可能还有剩余）
    p->next = (p1 != NULL) ? p1 : p2;

    // 释放原链表的头节点 (根据需求，如果原链表不再使用，可以释放)
    free(L1); L1 = NULL;
    free(L2); L2 = NULL;

    return L;
}
```

> [!TIP] 优势
> 空间 $O(1)$（直接调整指针，不新建节点），时间 $O(n+m)$。408 必考。

##### **2.1.10 单链表合并 k 个有序链表（升序→升序）**

功能：合并 k 个递增有序链表（408 拓展考点，用分治法）

```c
// 辅助函数：合并两个有序链表（复用 LinkListMergeTwoSorted 函数）
// LinkList mergeTwo(LinkList a, LinkList b) {
//     return LinkListMergeTwoSorted(a, b);
// }

// 分治法合并 k 个链表
LinkList LinkListMergeKSorted(LinkList lists[], int k) {
    if (k == 0) return InitList(); // 返回一个空链表头节点
    if (k == 1) return lists[0];   // 只有一个链表，直接返回

    // 分治：中间拆分
    int mid = k / 2;
    // 递归合并左半部分链表数组
    LinkList left = LinkListMergeKSorted(lists, mid);
    // 递归合并右半部分链表数组 (lists + mid 指向数组的中间部分)
    LinkList right = LinkListMergeKSorted(lists + mid, k - mid);

    // 合并左右两部分
    return LinkListMergeTwoSorted(left, right); // 调用合并两个有序链表的函数
}
```

> [!NOTE] 考点
> 分治法将时间复杂度从 $O(k(N+M))$ 降至 $O(N \log k)$（$N$ 为总节点数，$k$ 为链表数）。

##### **2.1.11 单链表删除所有值为 `e` 的节点**

功能：删除链表中所有值等于 `e` 的节点

```c
LinkList LinkListDeleteAllVal(LinkList L, int e) {
    if (L == NULL || L->next == NULL) return L; // 空链表或只有头节点

    LNode *prev = L;    // 前驱指针
    LNode *cur = L->next; // 当前指针

    while (cur != NULL) {
        if (cur->data == e) {
            // 删除当前节点
            prev->next = cur->next; // prev 跳过 cur
            free(cur);             // 释放 cur 节点
            cur = prev->next;      // cur 指针后移，指向 prev 的新后继
        } else {
            // 不删除，指针后移
            prev = cur;
            cur = cur->next;
        }
    }
    return L;
}
```

> [!WARNING] 易错点
> 删除后 `cur` 需指向 `prev->next`，而非 `cur->next`（避免访问已释放节点）。

##### **2.1.12 单链表删除重复节点（保留一个）**

功能：删除**有序链表**中重复的节点，仅保留一个（如 `1→1→2→3→3→3→4→4` 变为 `1→2→3→4`）

```c
LinkList LinkListDeleteDuplicates(LinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return L; // 空、单节点无重复

    LNode *cur = L->next;
    while (cur != NULL && cur->next != NULL) {
        if (cur->data == cur->next->data) {
            LNode *del = cur->next; // 找到重复节点
            cur->next = del->next; // 跳过重复节点
            free(del);             // 释放
        } else {
            cur = cur->next; // 无重复则后移
        }
    }
    return L;
}
```

> [!NOTE] 考点
> 仅适用于**有序链表**；若无序需先排序 ($O(n \log n)$)。

##### **2.1.13 单链表找中间节点（快慢指针法）**

功能：找到链表的中间节点（偶数长度返回第二个中间节点）

```c
LNode* LinkListFindMiddle(LinkList L) {
    if (L == NULL || L->next == NULL) return NULL; // 空链表或只有头节点则无中间节点

    LNode *slow = L->next, *fast = L->next; // 从第一个数据节点开始
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;        // 慢指针步长 1
        fast = fast->next->next;  // 快指针步长 2
    }
    return slow; // 快指针到尾时，慢指针恰好停在中间
}
```

> [!NOTE] 考点
> 时间 $O(n)$、空间 $O(1)$，比“先求长度再找中间”更高效。

##### **2.1.14 单链表两两交换节点（如 `1→2→3→4` 变为 `2→1→4→3`）**

功能：两两交换相邻节点，不交换值（408 指针操作高频题）

```c
LinkList LinkListSwapPairs(LinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return L; // 空、单节点无需交换

    LNode *prev = L;        // 前驱指针，初始指向头节点
    LNode *first = L->next;     // 第一节点
    LNode *second = L->next->next; // 第二节点

    while (first != NULL && second != NULL) {
        // 1. 交换节点
        prev->next = second;     // 前驱指向第二节点
        first->next = second->next; // 第一节点指向第二节点的后继
        second->next = first;    // 第二节点指向第一节点

        // 2. 指针后移，为下一次交换做准备
        prev = first;          // 新的前驱是原第一节点
        first = first->next;   // 新的第一节点是原第二节点的后继
        if (first != NULL) {   // 确保 first 不是 NULL 才能访问其 next
            second = first->next; // 新的第二节点是新第一节点的后继
        } else {
            second = NULL; // first 已经是尾部，没有第二节点了
        }
    }
    return L;
}
```

> [!WARNING] 易错点
> 指针调整顺序（先连 `prev->next = second`，再 `first->next = second->next`，最后 `second->next = first`），避免断链。

##### **2.1.15 单链表重排链表（如 `1→2→3→4→5` 变为 `1→5→2→4→3`）**

功能：将链表重排为“首→尾→次首→次尾→…”（408 复杂指针操作题）

```c
LinkList LinkListReorder(LinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return L; // 空、单节点无需重排

    // 1. 找中间节点（快慢指针）
    LNode *mid = LinkListFindMiddle(L); // 找到中间节点（这里会返回后半段的第一个节点的前一个节点）

    // 2. 拆分链表为前半段（L）和后半段（half2Head）
    LNode *half2Head = mid->next; // 后半段的头节点
    mid->next = NULL; // 断开前半段和后半段的连接

    // 3. 反转后半段
    // 为了复用 reverseHelper，需要为 half2Head 创建一个临时头节点
    LinkList tempHalf2 = InitList();
    if (tempHalf2 == NULL) return NULL; // 内存分配失败
    tempHalf2->next = reverseHelper(half2Head); // 复用第 2.1.5 题的递归反转

    // 4. 合并前半段和反转后的后半段
    LNode *p1 = L->next; // 前半段的第一个数据节点
    LNode *p2 = tempHalf2->next; // 反转后半段的第一个数据节点
    LNode *p = L; // 新链表的尾指针

    while (p1 != NULL && p2 != NULL) {
        p->next = p1; // 连接 p1
        p1 = p1->next;
        p = p->next;

        p->next = p2; // 连接 p2
        p2 = p2->next;
        p = p->next;
    }

    // 拼接剩余节点（前半段可能多一个节点，或后半段有剩余（若链表总长为奇数，前半段会多一个））
    if (p1 != NULL) { // 如果前半段有剩余，接上
        p->next = p1;
    } else { // 如果后半段有剩余，接上 (理论上不会出现，因为前半段长度 >= 后半段)
        p->next = p2;
    }

    free(tempHalf2); // 释放临时头节点
    return L;
}
```

> [!NOTE] 考点
> 综合“找中间、反转、合并”三步，是 408 复杂链表操作的典型题。

##### **2.1.16 单链表复制带随机指针的链表（如 LeetCode 138）**

功能：复制链表，每个节点含 `random` 指针（指向任意节点或 `NULL`）

```c
// 带随机指针的节点定义（假设在全局或头文件中定义）
typedef struct RandomListNode {
    int data;
    struct RandomListNode *next;
    struct RandomListNode *random; // 随机指针
} RandomListNode, *RandomLinkList;

RandomLinkList CopyRandomList(RandomLinkList head) {
    if (head == NULL) return NULL;

    // 1. 在原节点后插入复制节点（如 1→2→3 变为 1→1'→2→2'→3→3'）
    RandomListNode *p = head;
    while (p != NULL) {
        RandomListNode *copy = (RandomListNode*)malloc(sizeof(RandomListNode));
        if (copy == NULL) { /* 内存分配失败处理 */ return NULL; }
        copy->data = p->data;
        copy->next = p->next; // 复制节点的 next 指向原节点的下一个节点
        p->next = copy;       // 原节点的 next 指向复制节点
        p = copy->next;       // p 移动到下一个原节点
    }

    // 2. 复制 random 指针（copy->random = 原节点 random 的复制节点）
    p = head;
    while (p != NULL) {
        RandomListNode *copy = p->next; // copy 节点紧跟在 p 后面
        if (p->random != NULL) {
            copy->random = p->random->next; // 原 random 指向的节点的复制节点
        } else {
            copy->random = NULL; // 原 random 为 NULL
        }
        p = copy->next; // p 移动到下一个原节点
    }

    // 3. 拆分原链表和复制链表
    p = head;
    RandomListNode *copyHead = head->next; // 复制链表的头
    RandomListNode *copyP = copyHead;      // 用于遍历复制链表的指针

    while (p != NULL) {
        p->next = copyP->next; // 恢复原链表的连接
        p = p->next;           // 移动到下一个原节点

        if (p != NULL) {       // 确保 p 不是 NULL 才能访问其 next
            copyP->next = p->next; // 恢复复制链表的连接
        } else {
            copyP->next = NULL; // 复制链表也到尾部了
        }
        copyP = copyP->next;   // 移动到下一个复制节点
    }
    return copyHead;
}
```

> [!NOTE] 考点
> 空间 $O(1)$（无需哈希表），通过“插入 - 复制 - 拆分”三步实现，408 常考复杂链表复制。

##### **2.1.17 单链表排序（插入排序）**

功能：对单链表进行插入排序（稳定排序）

```c
LinkList LinkListInsertSort(LinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return L; // 空、单节点无需排序

    LinkList sorted = InitList(); // 新建一个已排序部分的头节点
    if (sorted == NULL) return NULL; // 内存分配失败

    LNode *cur = L->next; // 当前待插入节点（从原链表的第一个数据节点开始）
    L->next = NULL; // 断开原链表与第一个数据节点的连接，使原链表变空（或只剩头节点）

    while (cur != NULL) {
        LNode *p = sorted; // 遍历已排序部分找插入位置（从 sorted 的头节点开始）
        // 找第一个大于 cur 的节点的前驱 p
        while (p->next != NULL && p->next->data < cur->data) {
            p = p->next;
        }

        // 插入 cur 到 p 之后
        LNode *nextCur = cur->next; // 缓存下一个待插入节点（原链表中）
        cur->next = p->next;        // cur 的 next 指向 p 的原后继
        p->next = cur;              // p 的 next 指向 cur

        cur = nextCur; // 处理下一个节点
    }
    // 释放原链表的头节点 L (如果不需要)
    free(L); L = NULL;
    return sorted; // 返回排序好的新链表头节点
}
```

> [!NOTE] 考点
> 时间 $O(n^2)$，适合小规模链表；单链表排序无法用快速排序（需随机访问），插入排序和归并排序是主流。

##### **2.1.18 单链表排序（归并排序）**

功能：对单链表进行归并排序（高效排序，时间 $O(n \log n)$，408 拓展考点）

```c
// 辅助函数：拆分链表（找中间节点，断开为两部分）
// 返回后半段的头节点
LNode* split(LinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return NULL; // 空、单、双节点不需要拆分
    LNode *slow = L->next, *fast = L->next;
    // 快指针走到尾部或倒数第二个节点时，慢指针在中间
    while (fast->next != NULL && fast->next->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
    LNode *mid = slow->next; // mid 是后半段的头节点
    slow->next = NULL;       // 断开前半段和后半段的连接
    return mid;
}

// 辅助函数：合并两个有序链表（复用 2.1.9 题 LinkListMergeTwoSorted）
// LinkList merge(LinkList a, LinkList b) {
//     return LinkListMergeTwoSorted(a, b);
// }

// 归并排序主函数
LinkList LinkListMergeSort(LinkList L) {
    // base case：空、单节点无需排序
    if (L == NULL || L->next == NULL || L->next->next == NULL) return L;

    // 1. 拆分链表为两部分
    LNode *half2 = split(L); // half2 是后半段的第一个数据节点
    LinkList L2 = InitList(); // 创建一个临时头节点给后半段
    if (L2 == NULL) return NULL; // 内存分配失败
    L2->next = half2;

    // 2. 递归排序两部分
    LinkList sorted1 = LinkListMergeSort(L);  // 排序前半段
    LinkList sorted2 = LinkListMergeSort(L2); // 排序后半段

    // 3. 合并已排序的两部分
    LinkList merged = LinkListMergeTwoSorted(sorted1, sorted2);

    // sorted1 和 sorted2 的头节点在 LinkListMergeTwoSorted 中已被释放
    // L 和 L2 的头节点也被释放（因为它们是传入 LinkListMergeSort 的参数）
    return merged;
}
```

> [!NOTE] 考点
> 单链表最优排序算法，时间 $O(n \log n)$、空间 $O(\log n)$（递归栈）。

#### **2.2 双链表高频应用场景模板**

##### **2.2.1 双链表 $O(1)$ 删除指定节点（非头节点）**

功能：已知双链表节点 `p`，直接删除（无需遍历找前驱，$O(1)$ 时间）

```c
// 此函数为 1.2.4 的简化版，假设 e 不需要返回，且合法性检查在调用前完成
bool DLinkListDeleteNode_O1(DNode *p) {
    // p 为空、p 是头节点（假设 L 是头节点），或链表空（p->prev->next==NULL）
    if (p == NULL || p->prev == NULL) return false; // 更简单的检查 p 非头节点

    // 调整双向指针
    p->prev->next = p->next; // p 的前驱指向 p 的后继
    if (p->next != NULL) {   // 如果 p 有后继，更新后继的前驱
        p->next->prev = p->prev; // p 的后继指向 p 的前驱
    }

    free(p);
    p = NULL;
    return true;
}
```

> [!NOTE] 考点
> 双链表的核心优势，对比单链表 $O(n)$ 删除，体现双向指针价值。

##### **2.2.2 双链表反转（双向指针调整）**

功能：反转双链表（调整 `prev` 和 `next` 指针，$O(n)$ 时间）

```c
DLinkList DLinkListReverse(DLinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return L; // 空、单节点无需反转

    DNode *prev = NULL, *cur = L->next, *next = NULL;
    while (cur != NULL) {
        next = cur->next; // 缓存后继

        // 反转双向指针
        cur->next = prev; // 当前节点的 next 指向前一个节点
        cur->prev = next; // 当前节点的 prev 指向下一个节点（注意这里是原链表的下一个，反转后就成了前一个）

        // 指针后移
        prev = cur; // prev 移动到当前节点
        cur = next; // cur 移动到下一个节点
    }
    L->next = prev; // 头节点指向新首元节点（原尾节点）
    if (prev != NULL) { // 新首元节点的前驱指向头节点 (原尾节点的前驱是空，现在指向头节点 L)
        prev->prev = L;
    }
    return L;
}
```

> [!WARNING] 易错点
> 需同步反转 `prev` 指针 (`cur->prev = next`)，并让新首元节点的 `prev` 指向头节点。

##### **2.2.3 双链表删除所有重复节点（有序双链表）**

功能：删除**有序**双链表中重复的节点，仅保留一个

```c
DLinkList DLinkListDeleteDuplicates(DLinkList L) {
    if (L == NULL || L->next == NULL || L->next->next == NULL) return L;

    DNode *cur = L->next;
    while (cur != NULL && cur->next != NULL) {
        if (cur->data == cur->next->data) {
            DNode *del = cur->next; // 待删除的重复节点
            // 调整双向指针
            cur->next = del->next;
            if (del->next != NULL) { // 如果 del 有后继，更新其 prev 指针
                del->next->prev = cur;
            }
            free(del);
        } else {
            cur = cur->next; // 无重复则后移
        }
    }
    return L;
}
```

> [!TIP] 优势
> 有序双链表可通过 `cur->next` 直接判断重复，无需前驱指针回溯。

##### **2.2.4 双链表实现 LRU 缓存的“移至头部”操作**

功能：LRU 缓存中，访问节点后移至头部（双链表核心应用，$O(1)$ 时间）

```c
// LRU 缓存的双链表节点（已包含 prev/next）
typedef struct DNode LRUNode;

// 将节点 p 移至双链表头部（头节点 L 之后）
void LRU_MoveToHead(DLinkList L, LRUNode *p) {
    // 1. 合法性检查：p 为空，或 p 已经是第一个数据节点
    if (p == NULL || L == NULL || L->next == p) return;

    // 2. 先从当前位置删除 p 节点
    p->prev->next = p->next;
    if (p->next != NULL) {
        p->next->prev = p->prev;
    }

    // 3. 将 p 插入头部（L 之后）
    p->next = L->next; // p 的后继指向原第一个数据节点
    if (L->next != NULL) { // 原第一个数据节点的前驱指向 p
        L->next->prev = p;
    }
    L->next = p;       // 头节点的后继指向 p
    p->prev = L;       // p 的前驱指向头节点 L
}
```

> [!NOTE] 考点
> 双链表是 LRU 缓存的核心数据结构，“移至头部”“删除尾部”均为 $O(1)$ 操作。

##### **2.2.5 双链表双向遍历（正向 + 反向）**

功能：分别从头部和尾部遍历双链表（体现双向特性）

```c
// 正向遍历（头→尾）
void DLinkListTraverseForward(DLinkList L) {
    if (L == NULL || L->next == NULL) {
        printf("双链表为空（正向）\n");
        return;
    }
    printf("正向遍历： ");
    DNode *p = L->next;
    while (p != NULL) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

// 反向遍历（尾→头）
void DLinkListTraverseBackward(DLinkList L) {
    if (L == NULL || L->next == NULL) {
        printf("双链表为空（反向）\n");
        return;
    }
    // 1. 先找到尾节点
    DNode *p = L->next;
    while (p->next != NULL) {
        p = p->next;
    }
    // 2. 反向遍历
    printf("反向遍历： ");
    while (p != L) { // 终止条件：回到头节点的前一个（即尾节点，循环到头节点就不输出了）
        printf("%d ", p->data);
        p = p->prev;
    }
    printf("\n");
}
```

> [!TIP] 优势
> 双链表无需反转即可反向遍历，适合“双向查询”场景。

#### **2.3 循环链表高频应用场景模板**

##### **2.3.1 单循环链表解决约瑟夫问题（经典场景）**

功能：`n` 人围圈，每次数 `k` 的人出队，求最后胜利者位置 (1-based)

```c
// 注意：此函数依赖于 CirInitList 和 CirInsertNextNode, CirLinkListDeleteNext 等函数的正确实现
// 假设有一个销毁循环链表的函数
void DestroyCirLinkList(CirLinkList CL) {
    if (CL == NULL) return;
    LNode *p = CL->next;
    while (p != CL) {
        LNode *temp = p;
        p = p->next;
        free(temp);
    }
    free(CL);
}

int JosephusProblem(int n, int k) {
    if (n <= 0 || k <= 0) return -1; // 非法输入

    // 1. 创建 n 个节点的单循环链表（1~n 编号）
    CirLinkList CL = CirInitList(); // 复用之前的循环链表初始化
    if (CL == NULL) return -1;

    LNode *p = CL; // p 用于尾插法创建链表
    for (int i = 1; i <= n; i++) {
        CirInsertNextNode(p, i); // 尾插法创建
        p = p->next;
    }

    // 2. 模拟出队过程
    p = CL->next; // 从首元节点开始报数
    LNode *prev = CL; // prev 始终指向 p 的前驱，方便删除

    while (CL->next != CL) { // 剩余 1 人时停止 (链表只剩头节点)
        // 找到待出队节点的前驱 (数 k-1 步)
        // 实际上是移动到第 k-1 个人，其下一个就是第 k 个人
        for (int i = 1; i < k; i++) {
            prev = p;
            p = p->next;
            // 如果 p 跑到头节点了，跳过头节点，继续
            if (p == CL) {
                prev = p; // 更新 prev 到头节点
                p = p->next; // p 实际移动到第一个数据节点
            }
        }

        // 此时 p 指向待出队节点，prev 指向其前驱
        printf("出队： %d\n", p->data);
        int deleted_val;
        CirLinkListDeleteNext(prev, &deleted_val); // 删除 p (prev 的后继)

        // p 移动到下一个报数起点
        p = prev->next;
        if (p == CL) p = p->next; // 如果下一个节点是头节点，跳过它
    }

    // 3. 最后剩余节点
    int winner = CL->next->data;
    DestroyCirLinkList(CL); // 销毁链表，释放所有节点
    return winner;
}
```

> [!NOTE] 考点
> 循环链表的经典应用，408 常考“模拟围圈出队”逻辑。

##### **2.3.2 单循环链表判断是否对称（如 `1→2→3→2→1` 环）**

功能：判断循环链表是否对称（环形结构下的对称判断）

```c
bool CirLinkListIsSymmetric(CirLinkList CL) {
    if (CL == NULL) return false;
    if (CL->next == CL || CL->next->next == CL) return true; // 空链表或单节点链表对称

    // 1. 找中间节点（快慢指针）
    LNode *slow = CL->next, *fast = CL->next;
    // 终止条件：fast->next == CL (奇数个节点，fast 指向尾节点)
    // 或 fast->next->next == CL (偶数个节点，fast 指向倒数第二个节点)
    while (fast->next != CL && fast->next->next != CL) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // 2. 反转后半段（从 slow->next 开始）
    LNode *prev = NULL, *cur = slow->next, *next = NULL;
    // 反转直到回到 CL (头节点)
    while (cur != CL) {
        next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
    LNode *half2Head = prev; // 后半段反转后的头

    // 3. 对比前半段和反转后的后半段
    LNode *p1 = CL->next, *p2 = half2Head;
    bool isSym = true;
    while (p2 != NULL) { // 遍历反转后的后半段
        if (p1->data != p2->data) {
            isSym = false;
            break;
        }
        p1 = p1->next;
        p2 = p2->next;
    }

    // 4. 恢复后半段（可选，避免破坏原链表结构）
    // 此处省略恢复代码，考题若不要求可省略
    // 恢复思路：重新反转 half2Head 链表，然后重新连接 slow->next 和 恢复后的 half2Head

    return isSym;
}
```

> [!NOTE] 考点
> 综合“找中间、反转、对比”，体现循环链表的环形处理逻辑。

##### **2.3.3 合并两个单循环链表（升序→升序）**

功能：合并两个升序单循环链表，结果仍为升序循环链表

```c
CirLinkList CirLinkListMergeTwoSorted(CirLinkList CL1, CirLinkList CL2) {
    if (CL1 == NULL || CL1->next == CL1) return CL2; // CL1 为空，返回 CL2
    if (CL2 == NULL || CL2->next == CL2) return CL1; // CL2 为空，返回 CL1

    // 1. 合并两个链表的“数据部分”（类似单链表合并），CL 作为新的头节点
    CirLinkList CL = InitList(); // 新建一个空的循环链表头节点
    if (CL == NULL) return NULL;

    LNode *p = CL;             // 新链表的尾指针
    LNode *p1 = CL1->next, *p2 = CL2->next; // 从第一个数据节点开始比较

    while (p1 != CL1 && p2 != CL2) { // 只要两个链表的数据部分都没到头
        if (p1->data <= p2->data) {
            p->next = p1;
            p1 = p1->next;
        } else {
            p->next = p2;
            p2 = p2->next;
        }
        p = p->next; // 尾指针后移
    }

    // 拼接剩余节点 (如果其中一个链表还有剩余)
    p->next = (p1 != CL1) ? p1 : p2;

    // 2. 找到新链表的实际尾节点，并连接到 CL（保持循环）
    // p 此时指向最后一个连接上的节点，可能已经是新链表的尾部，也可能后面还有剩余部分
    LNode *newTail = p;
    // 遍历到真正的尾节点，它的 next 会指向 CL1 或 CL2 的头节点
    while (newTail->next != CL1 && newTail->next != CL2) {
        newTail = newTail->next;
    }
    newTail->next = CL; // 新的尾节点指向新的头节点 CL，形成循环

    // 3. 释放原链表头节点 (根据需求)
    free(CL1); CL1 = NULL;
    free(CL2); CL2 = NULL;

    return CL;
}
```

> [!WARNING] 易错点
> 合并后需找到新尾节点，使其指向新头节点 `CL`，维持循环性。

##### **2.3.4 单循环链表遍历与计数（环形结构）**

功能：遍历循环链表并计数节点个数（避免无限循环）

```c
int CirLinkListCount(CirLinkList CL) {
    if (CL == NULL || CL->next == CL) return 0; // 空链表

    int count = 0;
    LNode *p = CL->next; // 从第一个数据节点开始
    while (p != CL) {    // 终止条件：回到头节点
        count++;
        p = p->next;
    }
    return count;
}
```

> [!NOTE] 考点
> 循环链表遍历的终止条件是“回到头节点”（非 `p == NULL`），避免无限循环。

##### **2.3.5 单循环链表删除指定值的所有节点（保持环形）**

功能：删除循环链表中所有值为 `e` 的节点，维持环形结构

```c
CirLinkList CirLinkListDeleteAllVal(CirLinkList CL, int e) {
    if (CL == NULL || CL->next == CL) return CL;

    LNode *prev = CL;    // 前驱指针
    LNode *cur = CL->next; // 当前指针

    // 循环条件：cur 还没有遍历回头节点
    while (cur != CL) {
        if (cur->data == e) {
            LNode *del = cur;
            // 调整指针：prev 跳过 del
            prev->next = cur->next;
            // cur 指针后移到下一个节点（即 prev 的新后继）
            cur = cur->next;
            free(del); // 释放被删除的节点
        } else {
            // 不删除，指针后移
            prev = cur;
            cur = cur->next;
        }
    }
    return CL;
}
```

> [!WARNING] 易错点
> 删除后 `cur` 需指向 `prev->next`，且终止条件为 `cur == CL`，确保遍历整个环形。

---

### **三、链表模板使用技巧 (408 考研策略)**

#### **3.1 单链表核心技巧：指针策略与算法思想**

单链表的核心竞争力在于指针操作的灵活性，三大核心技巧贯穿 80% 以上考题：

*   **双指针法是单链表的“解题利器”：**
    *   **反转链表：** `pre`（前驱）、`cur`（当前）、`next`（后继缓存）三指针形成“断链 - 反转 - 移动”闭环，通过 `next = cur->next` 避免指针丢失，`cur->next = pre` 实现方向反转，时间复杂度 $O(n)$、空间 $O(1)$ 的优势使其成为 408 必考。
    *   **环检测：** 快慢指针以“步长差”突破：慢指针步长 1、快指针步长 2，若有环必相遇（快指针多走一圈），找环入口时让慢指针从头出发，双指针同步移动至相遇，利用“头到入口距离 = 相遇点到入口距离”的数学特性。
    *   **中间节点问题：** 同样依赖快慢指针，快指针到尾时，慢指针恰好停在中间（偶数长度取第二个），比“先求长度再遍历”更高效。
*   **分治法是处理复杂场景的“降维工具”：**
    *   **合并 k 个有序链表：** 分治法将问题拆解为“合并两个链表”的子问题：先拆分 `k` 为左右两部分，递归合并后再整合，时间复杂度从 $O(kN)$（`k` 为链表数，$N$ 为总节点数）降至 $O(N \log k)$，避免了逐次合并的低效。核心在于利用单链表“局部有序可直接拼接”的特性，通过递归减小问题规模。
*   **指针调整顺序是避免断链的“安全守则”：**
    *   **插入节点：** 需遵循“先连后再改前”（如后插法中 `s->next = p->next; p->next = s;`）。
    *   **删除节点：** 需“先缓存再断链”（如 `q = p->next; p->next = q->next;`）。
    *   **复杂操作：** 如两两交换节点，需严格按“`prev->next = second; first->next = second->next; second->next = first;`”的顺序调整，否则易因指针丢失导致断链，这是 408 真题中高频失分点。

#### **3.2 双链表核心：双向指针的效率革命**

双链表通过 `prev` 和 `next` 双向关联，实现单链表难以企及的 $O(1)$ 操作：

*   **双向指针的协同是核心：**
    *   **删除指定节点：** 无需遍历找前驱，直接通过 `p->prev->next = p->next` 和 `p->next->prev = p->prev` 完成双向断链，比单链表 $O(n)$ 时间复杂度实现质的飞跃。
    *   **双向遍历场景：** 正向从 `head->next` 出发，反向从尾节点（通过 `p->next != NULL` 定位）出发，沿 `prev` 回溯，适合“前后对比”“双向查询”等场景，如判断链表是否对称。
*   **LRU 缓存是双链表的经典应用：**
    *   LRU（最近最少使用）策略要求“访问节点移至头部，满时删除尾部”，双链表配合哈希表可实现 $O(1)$ 操作：移至头部通过“断链 + 头插”完成，删除尾部直接操作尾节点的 `prev`，完美适配缓存高频读写的需求，408 常以“设计 LRU 结构”考查此知识点。

#### **3.3 循环链表核心：环形结构的场景适配**

循环链表以“尾节点指向头节点”打破边界，三大核心围绕环形特性展开：

*   **环形终止条件是操作前提：**
    *   遍历、插入、删除需以“`p == head`”为终止标志（区别于单链表的 `p == NULL`），避免无限循环。如计数节点时，`while (p != head) { count++; p = p->next; }` 确保遍历整个环。
*   **约瑟夫问题是环形结构的典型应用：**
    *   `n` 人围圈报数，每次淘汰第 `k` 人，循环链表通过“数 `k-1` 步定位目标，删除后保持环形”模拟过程，核心是删除节点后让 `p` 指向 `prev->next`，维持遍历连续性，408 常考“最后胜利者位置”的推导。
*   **循环性维护是操作底线：**
    *   合并两个循环链表时，需找到新链表尾节点并指向头节点；删除节点后需确保“尾节点→头节点”的链路不中断，否则环形结构失效，这是区别于单链表的关键细节。

#### **3.4 通用技巧：标准化与工程化思维**
*   **带头节点优先是降低复杂度的“捷径”：**
    *   头节点（不存数据）使首元节点与中间节点操作统一，如单链表头插无需特殊判断，双链表删除首元节点可直接用 `p->prev->next`，408 真题中 90% 的链表操作基于带头节点结构。
*   **动态节点必 `free` 是避坑关键：**
    *   C 语言中 `malloc` 分配的节点需手动释放，否则导致内存泄漏，尤其在循环或递归操作中（如删除所有重复节点），需确保每个被移除的节点都被 `free`，并置指针为 `NULL` 避免野指针。
*   **复杂操作拆分是解题思路：**
    *   如重排链表拆分为“找中间→反转后半段→合并”三步，每步调用基础函数（中间节点用快慢指针，反转用双指针），将 $O(n^2)$ 的复杂问题转化为三个 $O(n)$ 的简单问题，体现“分而治之”的算法思想，这是 408 高分必备的解题策略。


