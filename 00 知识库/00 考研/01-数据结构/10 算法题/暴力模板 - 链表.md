---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 暴力解法模板 - 链表

## 核心思想

链表暴力解法通常遵循**空间换时间**的基本策略，通过引入辅助数据结构（如数组、哈希表）将链表的线性访问问题转化为随机访问问题，从而简化算法逻辑，提高代码可读性和实现效率。

### 常用链表节点结构定义

在下面的实例中，假设链表节点通常定义如下：

```c
// 假设链表节点定义
struct ListNode {
    int val;
    struct ListNode *next;
};
typedef struct ListNode ListNode; // 方便使用
```

## 暴力解法通用模板 - 链表

```c
#include <stdlib.h> // For malloc, free, qsort (if needed)
// #include <stdbool.h> // For bool (if not C99/C11 compatible and using a custom bool)
// #include <stdio.h> // For potential debug prints

// 链表暴力解法通用模板
ReturnType bruteForceSolution(ListNode* head, Parameters params) {
    // 1. 输入合法性检查
    // 检查头节点是否为空，或参数是否有效
    if (head == NULL /* || invalidParams(params) */) {
        return defaultValue; // 根据问题返回默认值或错误指示
    }

    // 2. 辅助数据结构初始化
    // 例如：int auxiliary[MAX_SIZE] = {0}; 或 struct MyStruct auxiliary_arr[MAX_SIZE];
    // 或用于哈希表等其他结构
    // AuxiliaryType auxiliary[MAX_SIZE];
    // initializeAuxiliary(auxiliary);

    // 3. 信息收集阶段（可能多次遍历）
    // 遍历链表，将必要信息存储到辅助数据结构中
    ListNode* current = head;
    while (current != NULL) {
        // collectInformation(current, auxiliary); // 将当前节点信息收集到辅助结构
        current = current->next;
    }

    // 4. 核心算法执行阶段
    // 利用辅助数据结构进行随机访问、排序、查找等操作
    // ReturnType result = processWithAuxiliary(auxiliary, params);

    // 5. 资源清理和结果返回
    // cleanupIfNeeded(auxiliary); // 如果辅助结构是动态分配的，需要释放
    // return result; // 返回最终结果
    return defaultValue; // 占位符
}
```

### 辅助存储模式

**模式：将链表节点指针或数据存储到数组中**

这是链表暴力解法中最常见的一种辅助存储模式，将链表的顺序访问特性转化为数组的随机访问特性。

```c
// 示例：将链表节点指针或数据存储到数组中
// 假设 MAX_NODES 是链表最大可能的节点数
// ListNode* auxiliary[MAX_NODES]; // 存储节点指针
// DataType auxiliary_values[MAX_NODES]; // 存储节点数据

ListNode* current = head;
int index = 0;
// while (current != NULL && index < MAX_NODES) { // 需注意数组越界
//     auxiliary_values[index++] = current->val; // 存储节点数据
//     // 或者 auxiliary_pointers[index++] = current; // 存储节点指针
//     current = current->next;
// }
```

---

## 模板使用实例 - 链表

### 实例 1：删除链表中的重复元素 II

**问题描述**：给定有序链表，删除所有重复出现的元素，只保留原链表中没有重复的元素。

```c
#include <stdlib.h> // For malloc, free
// 假设 ListNode 结构已定义
// struct ListNode { int val; struct ListNode *next; };

/**
 * 辅助存储模式：统计每个元素出现频次
 */
ListNode* deleteDuplicatesII(ListNode* head) {
    if (head == NULL) return NULL;

    // 1. 辅助数组存储：值-频次映射
    // 假设值范围[-100, 100]，所以需要201个桶
    // 负数通过 +100 偏移到非负索引
    int frequency[201] = {0};

    // 2. 第一次遍历：统计频次
    ListNode* current = head;
    while (current != NULL) {
        frequency[current->val + 100]++; // 偏移处理负数
        current = current->next;
    }

    // 3. 第二次遍历：重构链表
    // 创建一个哑节点 (dummy node) 简化头节点处理
    ListNode dummy = {0, NULL}; // C99 复合字面量
    ListNode* tail = &dummy;    // tail 指向新链表的最后一个节点

    current = head; // 重新从原链表头开始遍历
    while (current != NULL) {
        // 如果当前节点的出现频次为 1 (即不重复)
        if (frequency[current->val + 100] == 1) {
            tail->next = current; // 将当前节点连接到新链表
            tail = current;       // 更新 tail 指针
        }
        current = current->next; // 移动到下一个节点
    }
    tail->next = NULL; // 新链表末尾指向 NULL，截断原链表剩余部分
    return dummy.next; // 返回新链表的头节点
}
```

### 实例 2：链表中环的检测与定位

**问题描述**：检测链表是否有环，若有环则返回环的起始节点。

```c
#include <stdlib.h> // For NULL

// 假设 ListNode 结构已定义

/**
 * 辅助存储模式：节点地址哈希表 (这里用数组模拟)
 */
ListNode* detectCycle(ListNode* head) {
    if (head == NULL) return NULL;

    // 1. 辅助数组存储：访问过的节点地址
    // 假设最大节点数 10000，数组大小10001。
    // 在实际面试或工程中，通常使用哈希表（如C++的std::unordered_set）
    // 或者快慢指针（Floyd's Cycle Finding Algorithm）
    ListNode* visited[10001] = {NULL};
    int visitedCount = 0;

    // 2. 遍历并记录访问节点
    ListNode* current = head;
    while (current != NULL) {
        // 3. 检查当前节点是否已访问
        for (int i = 0; i < visitedCount; i++) {
            if (visited[i] == current) {
                return current; // 找到环起点，即当前节点
            }
        }
        // 4. 记录当前节点
        // 如果 visitedCount 达到数组上限，需要处理（例如扩容或报错）
        // 这里简化为假设不会溢出
        if (visitedCount < 10001) {
            visited[visitedCount++] = current;
        } else {
            // 超过辅助数组容量，说明链表过长或者环的起点超出可记录范围
            // 对于暴力解法，可以视为错误或直接返回NULL
            return NULL;
        }
        current = current->next;
    }
    return NULL; // 遍历结束仍未发现环
}
```

### 实例 3：合并 K 个有序链表

**问题描述**：将 K 个有序链表合并为一个有序链表。

```c
#include <stdlib.h> // For malloc, free, qsort

// 假设 ListNode 结构已定义

// qsort 的比较函数
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

/**
 * 辅助存储模式：所有元素收集排序
 */
ListNode* mergeKLists(ListNode** lists, int listsSize) {
    if (lists == NULL || listsSize == 0) return NULL;

    // 1. 辅助数组：收集所有节点值
    // 假设所有链表的总节点数不超过 10000
    int values[10000];
    int count = 0;

    // 2. 遍历所有链表收集数据
    for (int i = 0; i < listsSize; i++) {
        ListNode* current = lists[i];
        while (current != NULL) {
            // 同样需要检查 count 是否会超过数组容量
            if (count < 10000) {
                values[count++] = current->val;
            } else {
                // 超过容量，处理错误或直接返回
                // 这里为了演示，不做严格错误处理
                // free 掉已分配的节点，但此例没有动态分配
            }
            current = current->next;
        }
    }

    if (count == 0) return NULL; // 如果所有链表都为空

    // 3. 排序收集的值
    qsort(values, count, sizeof(int), compare);

    // 4. 重新构造链表
    ListNode dummy = {0, NULL}; // 哑节点
    ListNode* tail = &dummy;

    for (int i = 0; i < count; i++) {
        ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
        if (newNode == NULL) {
            // 内存分配失败处理，需要释放之前分配的所有节点
            // 简单处理为返回 NULL
            return NULL;
        }
        newNode->val = values[i];
        newNode->next = NULL;

        tail->next = newNode;
        tail = newNode;
    }
    return dummy.next;
}
```

### 实例 4：链表的回文检测

**问题描述**：判断链表是否构成回文结构。

```c
#include <stdbool.h> // For bool type
#include <stdlib.h>  // For NULL

// 假设 ListNode 结构已定义

/**
 * 辅助存储模式：数组存储+双指针比较
 */
bool isPalindrome(ListNode* head) {
    if (head == NULL || head->next == NULL) return true; // 空链表或单节点链表都是回文

    // 1. 辅助数组存储所有节点值
    // 假设链表最大长度为 50000
    int values[50000];
    int count = 0;

    // 2. 遍历链表收集数据
    ListNode* current = head;
    while (current != NULL) {
        if (count < 50000) { // 检查数组边界
            values[count++] = current->val;
        } else {
            // 链表过长，超出辅助数组容量，通常意味着输入数据超限
            return false; // 或者抛出错误
        }
        current = current->next;
    }

    // 3. 双指针检查回文性质
    int left = 0, right = count - 1;
    while (left < right) {
        if (values[left] != values[right]) {
            return false; // 发现不匹配，不是回文
        }
        left++;
        right--;
    }
    return true; // 所有元素都匹配，是回文
}
```

### 实例 5：删除链表倒数第 N 个节点

**问题描述**：删除链表的倒数第 n 个节点。

```c
#include <stdlib.h> // For free, NULL

// 假设 ListNode 结构已定义

/**
 * 多次遍历模式：长度计算+定位删除
 */
ListNode* removeNthFromEnd(ListNode* head, int n) {
    if (head == NULL) return NULL;

    // 1. 第一次遍历：计算链表长度
    int length = 0;
    ListNode* current = head;
    while (current != NULL) {
        length++;
        current = current->next;
    }

    // 2. 边界检查
    if (n <= 0 || n > length) {
        // n 无效或超出链表长度，按惯例不删除或返回原链表
        return head;
    }

    if (n == length) {
        // 如果 n 等于链表长度，意味着删除头节点
        ListNode* newHead = head->next;
        free(head); // 释放原头节点
        return newHead;
    }

    // 3. 第二次遍历：定位到待删除节点的前驱
    // 我们需要找到倒数第 n 个节点的前一个节点。
    // 这个前驱节点是正数第 (length - n) 个节点。
    // 所以需要遍历 (length - n - 1) 步。
    int targetPos = length - n; // 正数计数，目标是第 targetPos 个节点（从1开始）

    // 从头节点开始，找到第 targetPos - 1 个节点 (即目标节点的前一个节点)
    current = head;
    for (int i = 1; i < targetPos; i++) { // 循环 targetPos-1 次
        current = current->next;
    }

    // 4. 执行删除操作
    // current 现在指向待删除节点的前一个节点
    ListNode* nodeToDelete = current->next; // 待删除节点
    current->next = nodeToDelete->next;     // 将前驱节点指向待删除节点的下一个节点
    free(nodeToDelete);                     // 释放待删除节点的内存

    return head; // 返回链表头
}
```

---

## 模板使用练习 - 链表

以下是链表暴力解法模板的一些练习题目，你可以尝试使用上述通用模板和辅助存储模式来思考和实现。

1.  链表中环的检测与定位 (已在实例中提供)
2.  链表反转操作
3.  合并两个有序链表
4.  删除链表倒数第 N 个节点 (已在实例中提供)
5.  链表的中间节点查找
6.  判断链表是否为回文 (已在实例中提供)
7.  两个链表的交点查找
8.  删除链表中重复元素 (仅保留一个)
9.  链表排序算法
10. 旋转链表 K 个位置
11. 链表分割操作 (按值分割)
12. 复制带随机指针的链表
13. 链表两数相加
14. 重排链表结构 (L0 -> Ln -> L1 -> Ln-1 -> …)
15. 链表奇偶节点分离
16. 删除链表指定值节点 (所有值为 val 的节点)
17. 链表插入排序
18. 反转链表指定区间 (从 m 到 n)
19. 链表去重保留一个 (删除所有重复项，只保留第一次出现的)
20. 链表节点交换操作 (交换相邻节点，或任意两个节点)
```