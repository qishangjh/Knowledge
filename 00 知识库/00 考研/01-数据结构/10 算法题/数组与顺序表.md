---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---
# 数组与顺序表算法题模板

数组与顺序表是 408 数据结构的基础考点。以下模板覆盖静态数组操作、动态顺序表管理及高频考题场景（去重、二分查找、数组反转等），标注核心考点和易错点，适合直接背诵应用。

---

## 一、静态数组基础操作模板

静态数组是固定大小的连续存储空间。408 主要考察其随机访问、插入删除等特性，时间复杂度分析是重点。

### 1. 数组定义与初始化

```c
#include <stdio.h>   // 用于 printf
#include <stdlib.h>  // 用于 malloc, free, qsort, abs (如果需要)
#include <stdbool.h> // 用于 bool 类型
#include <string.h>  // 用于 strlen, memcmp (如果需要)
#include <limits.h>  // 用于 INT_MAX (如果需要)

// 定义数组元素类型（可替换为 int、char 等）
typedef int ElemType;

// 静态数组（固定大小）
#define MAX_SIZE 100 // 宏定义数组最大容量（题目常给出）

// 全局定义示例，实际使用中通常作为函数参数传递
ElemType global_arr[MAX_SIZE];
int global_length = 0; // 实际元素个数
```

### 2. 核心操作模板（必背）

#### （1）数组元素访问（随机访问，O(1)）

```c
/**
 * @brief 获取数组指定索引的元素地址
 * @param arr：目标数组
 * @param length：数组当前长度
 * @param index：元素索引（0 ≤ index < length）
 * @return ElemType*：元素指针（成功），NULL（失败，索引越界）
 * @考点：索引合法性检查（数组越界是高频错误点）
 */
ElemType* ArrayGet(ElemType arr[], int length, int index) {
    if (index < 0 || index >= length) {
        printf("数组索引越界！\n");
        return NULL;
    }
    return &arr[index]; // 数组支持随机访问，直接返回地址
}
```

#### （2）数组插入元素（指定位置，O(n)）

```c
/**
 * @brief 在数组指定位置插入元素
 * @param arr：目标数组
 * @param length：当前长度的指针（需修改长度）
 * @param index：插入位置（0 ≤ index ≤ *length）
 * @param e：待插入元素
 * @return int：0=成功，-1=失败（越界/数组满）
 * @考点 1：边界判断（index可以等于*length，即末尾插入）
 * @考点 2：元素后移（从后往前移，避免覆盖）
 */
int ArrayInsert(ElemType arr[], int *length, int index, ElemType e) {
    // 1. 合法性检查
    if (index < 0 || index > *length) {
        printf("插入位置非法！\n");
        return -1;
    }
    if (*length >= MAX_SIZE) { // 静态数组无法扩容，满则失败
        printf("数组已满，无法插入！\n");
        return -1;
    }

    // 2. 元素后移：从数组最后一个有效元素开始，向后移动
    for (int i = *length - 1; i >= index; i--) {
        arr[i + 1] = arr[i];
    }

    // 3. 插入元素并更新长度
    arr[index] = e;
    (*length)++; // 注意：length 是指针，需解引用修改
    return 0;
}
```

#### （3）数组删除元素（指定位置，O(n)）

```c
/**
 * @brief 删除数组指定位置的元素
 * @param arr：目标数组
 * @param length：当前长度的指针
 * @param index：删除位置（0 ≤ index < *length）
 * @param e：输出参数，存储被删除元素
 * @return int：0=成功，-1=失败（越界/数组空）
 * @考点 1：边界判断（index 不能等于*length）
 * @考点 2：元素前移（从前往后移，覆盖被删元素）
 */
int ArrayDelete(ElemType arr[], int *length, int index, ElemType *e) {
    // 1. 合法性检查
    if (*length == 0) {
        printf("数组为空，无法删除！\n");
        return -1;
    }
    if (index < 0 || index >= *length) {
        printf("删除位置非法！\n");
        return -1;
    }

    // 2. 保存被删元素
    *e = arr[index];

    // 3. 元素前移：从删除位置开始，将后面的元素向前移动覆盖
    for (int i = index; i < *length - 1; i++) {
        arr[i] = arr[i + 1];
    }

    // 4. 更新长度
    (*length)--;
    return 0;
}
```

#### （4）数组遍历（O(n)）

```c
/**
 * @brief 遍历并打印数组所有元素
 * @param arr：目标数组
 * @param length：数组长度
 */
void ArrayTraverse(ElemType arr[], int length) {
    if (length == 0) {
        printf("数组为空！\n");
        return;
    }
    printf("数组元素： ");
    for (int i = 0; i < length; i++) {
        printf("%d ", arr[i]); // 按实际类型修改格式符
    }
    printf("\n");
}
```

---

## 二、动态顺序表操作模板（扩展数组功能）

动态顺序表通过动态内存分配解决静态数组容量固定的问题，是 408 核心考点，需重点掌握扩容机制。

### 1. 动态顺序表结构体定义

```c
// 动态顺序表（可扩容）
typedef struct {
    ElemType *data;   // 动态数组指针
    int length;       // 当前实际元素个数
    int capacity;     // 当前最大容量
} DynamicArray;
```

### 2. 核心操作模板（必背）

#### （1）初始化动态顺序表

```c
/**
 * @brief 初始化一个动态顺序表
 * @param initCapacity：初始容量
 * @return DynamicArray：初始化后的顺序表（包含分配的内存和初始状态）
 * @考点：内存分配失败处理（易忽略）
 */
DynamicArray DynArrayInit(int initCapacity) {
    DynamicArray da;
    da.data = (ElemType *)malloc(initCapacity * sizeof(ElemType));
    if (da.data == NULL) { // 内存分配失败
        printf("内存分配失败！\n");
        da.length = 0;
        da.capacity = 0;
        return da; // 返回一个无效的 DynamicArray
    }
    da.length = 0;
    da.capacity = initCapacity;
    return da;
}
```

#### （2）动态扩容（核心考点）

```c
/**
 * @brief 对动态顺序表进行扩容
 * @param da：动态顺序表指针
 * @return int：0=成功，-1=失败
 * @考点 1：扩容策略（容量翻倍，摊还时间复杂度O(1)）
 * @考点 2：realloc 使用及失败处理（不影响原数据）
 */
int DynArrayExpand(DynamicArray *da) {
    if (da->capacity == 0 && da->data == NULL) { // 未初始化或已销毁
        printf("动态数组未初始化或已销毁！\n");
        return -1;
    }
    
    // 扩容策略：容量翻倍（408 推荐）
    int newCapacity = (da->capacity == 0) ? 1 : da->capacity * 2; // 避免0*2=0的情况
    ElemType *newData = (ElemType *)realloc(da->data, newCapacity * sizeof(ElemType));

    if (newData == NULL) { // 扩容失败不影响原数据
        printf("扩容失败！\n");
        return -1;
    }
    da->data = newData;
    da->capacity = newCapacity;
    return 0;
}
```

#### （3）动态顺序表插入（带扩容）

```c
/**
 * @brief 在动态顺序表指定位置插入元素（支持自动扩容）
 * @param da：动态顺序表指针
 * @param index：插入位置
 * @param e：待插入元素
 * @return int：0=成功，-1=失败
 * @考点：自动扩容逻辑与静态数组插入的结合
 */
int DynArrayInsert(DynamicArray *da, int index, ElemType e) {
    // 1. 位置合法性检查
    if (index < 0 || index > da->length) {
        printf("插入位置非法！\n");
        return -1;
    }

    // 2. 满则扩容（考点：自动扩容逻辑）
    if (da->length >= da->capacity) {
        if (DynArrayExpand(da) == -1) {
            printf("插入失败：无法扩容！\n");
            return -1;
        }
    }

    // 3. 元素后移（同静态数组插入）
    for (int i = da->length - 1; i >= index; i--) {
        da->data[i + 1] = da->data[i];
    }

    // 4. 插入并更新长度
    da->data[index] = e;
    da->length++;
    return 0;
}
```

#### （4）动态顺序表销毁（避免内存泄漏）

```c
/**
 * @brief 销毁动态顺序表，释放内存
 * @param da：动态顺序表指针
 * @考点：置空指针避免野指针，防止二次释放或非法访问
 */
void DynArrayDestroy(DynamicArray *da) {
    if (da->data != NULL) {
        free(da->data);
        da->data = NULL; // 考点：置空避免野指针
    }
    da->length = 0;
    da->capacity = 0;
}
```

---

## 三、高频应用场景模板（数组与顺序表）

### 1. 数组去重（有序 / 无序）

#### （1）有序数组去重（保留 1 个重复元素，O(n)）

```c
/**
 * @brief 对有序数组进行原地去重，保留一个重复元素
 * @param arr：有序数组（升序/降序）
 * @param length：数组长度指针
 * @return int：去重后的新长度
 * @考点：双指针法（快慢指针），时间 O(n)、空间 O(1)，仅适用于有序数组。
 */
int ArrayUnique(ElemType arr[], int *length) {
    if (*length <= 1) return *length; // 空或单元素无需去重

    int i = 0; // 慢指针：指向不重复元素的最后位置
    // 快指针 j 遍历数组
    for (int j = 1; j < *length; j++) {
        if (arr[j] != arr[i]) { // 找到一个与慢指针指向元素不重复的元素
            i++;               // 慢指针向前移动
            arr[i] = arr[j];   // 将不重复元素移动到慢指针位置
        }
    }
    *length = i + 1; // 更新长度为慢指针位置 + 1
    return *length;
}
```

#### （2）无序数组去重（暴力法，O(n²)）

```c
/**
 * @brief 对无序数组进行原地去重（暴力法），保留第一次出现的元素
 * @param arr：无序数组
 * @param length：数组长度指针
 * @return int：去重后的新长度
 * @考点：三层循环，内部删除操作 O(n)，总 O(n^2)。
 */
int ArrayUniqueUnordered(ElemType arr[], int *length) {
    if (*length <= 1) return *length;

    int i, j, k;
    for (i = 0; i < *length; i++) {
        // 检查后续元素是否与 arr[i]重复
        // 注意：这里 j 在内层循环中可能不自增，由内层逻辑控制
        for (j = i + 1; j < *length; ) {
            if (arr[j] == arr[i]) { // 找到重复元素
                // 删除 arr[j]（元素前移覆盖）
                for (k = j; k < *length - 1; k++) {
                    arr[k] = arr[k + 1];
                }
                (*length)--; // 长度减 1
                // 此时 j 位置已被新元素填充，无需 j++，继续检查当前 j 位置
            } else {
                j++; // 不重复则后移
            }
        }
    }
    return *length;
}
```

### 2. 二分查找（有序数组，O(logn)）

```c
/**
 * @brief 在升序有序数组中查找目标元素
 * @param arr：升序有序数组
 * @param length：数组长度
 * @param target：目标元素
 * @return int：元素索引（成功），-1（失败）
 * @考点 1：循环条件 low <= high（带等号，否则可能漏查）
 * @考点 2：mid 计算避免溢出（low + (high - low) / 2 优于 (low + high) / 2）
 * @注意：仅适用于有序数组，无序数组需先排序（O(nlogn)）
 */
int BinarySearch(ElemType arr[], int length, ElemType target) {
    int low = 0, high = length - 1; // 考点：high 初始值为 length-1

    while (low <= high) { // 注意：带等号（否则可能漏查）
        int mid = low + (high - low) / 2; // 避免(low+high)溢出

        if (arr[mid] == target) {
            return mid; // 找到目标
        } else if (arr[mid] < target) {
            low = mid + 1; // 目标在右半区，排除 mid
        } else { // arr[mid] > target
            high = mid - 1; // 目标在左半区，排除 mid
        }
    }
    return -1; // 未找到
}
```

### 3. 数组反转（O(n)）

```c
/**
 * @brief 反转数组元素顺序
 * @param arr：目标数组
 * @param length：数组长度
 * @考点：双指针法（左右指针），时间 O(n)、空间 O(1)。
 */
void ArrayReverse(ElemType arr[], int length) {
    if (length <= 1) return;

    int left = 0, right = length - 1; // 双指针：首尾对称
    while (left < right) {
        // 交换元素
        ElemType temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;

        left++;
        right--;
    }
}
```

### 4. 合并两个有序数组（O(n+m)）

```c
/**
 * @brief 合并两个升序数组到第一个数组（假设 arr1 有足够空间）
 * @param arr1：第一个数组（长度 n+m，前 n 个是有效元素，后面 m 个是预留空间）
 * @param n：arr1 有效元素个数
 * @param arr2：第二个数组（长度 m）
 * @param m：arr2 元素个数
 * @考点：从尾部合并避免覆盖 arr1 的有效元素，时间复杂度 O(n+m)，空间 O(1)。
 */
void MergeArrays(ElemType arr1[], int n, ElemType arr2[], int m) {
    int i = n - 1;      // arr1 的有效元素尾部指针
    int j = m - 1;      // arr2 的尾部指针
    int k = n + m - 1;  // 合并后 arr1 的尾部填充指针

    // 双指针从后往前合并（避免覆盖 arr1 的有效元素）
    while (i >= 0 && j >= 0) {
        if (arr1[i] >= arr2[j]) {
            arr1[k--] = arr1[i--];
        } else {
            arr1[k--] = arr2[j--];
        }
    }

    // 处理 arr2 剩余元素（如果 arr1 的元素都已合并完，arr2 可能还有剩余）
    while (j >= 0) {
        arr1[k--] = arr2[j--];
    }
    // 如果 arr1 还有剩余元素，它们本身就是有序且在正确位置，无需处理
}
```

### 5. 查找数组中最大值和最小值（O(n)）

```c
/**
 * @brief 同时查找最大值和最小值（优化比较次数）
 * @param arr：目标数组
 * @param length：数组长度
 * @param max：输出参数，存储最大值
 * @param min：输出参数，存储最小值
 * @考点：优化比较次数（常规需 2n 次，优化后需 3n/2 次），通过两两比较减少比较次数。
 */
void FindMaxMin(ElemType arr[], int length, ElemType *max, ElemType *min) {
    if (length == 0) {
        printf("数组为空！\n");
        return;
    }

    // 初始化 max 和 min
    if (length % 2 == 0) { // 偶数长度，前两个元素先比较
        if (arr[0] > arr[1]) {
            *max = arr[0];
            *min = arr[1];
        } else {
            *max = arr[1];
            *min = arr[0];
        }
    } else { // 奇数长度，第一个元素既是 max 也是 min
        *max = *min = arr[0];
    }

    // 两两比较，每轮 3 次比较（优化）
    // 从第二个或第三个元素开始，步长为 2
    int start_idx = (length % 2 == 0) ? 2 : 1;
    for (int i = start_idx; i < length; i += 2) {
        // 存在两个元素 arr[i] 和 arr[i+1]
        if (arr[i] > arr[i + 1]) {
            if (arr[i] > *max) *max = arr[i];
            if (arr[i + 1] < *min) *min = arr[i + 1];
        } else {
            if (arr[i + 1] > *max) *max = arr[i + 1];
            if (arr[i] < *min) *min = arr[i];
        }
    }
}
```

### 6. 数组中两数之和（返回索引，O(n²) 暴力法）

```c
/**
 * @brief 查找和为 target 的两个元素的索引（假设存在唯一解）
 * @param arr：目标数组
 * @param length：数组长度
 * @param target：目标和
 * @param indices：输出数组，存储两个索引
 * @考点：双重循环遍历所有元素对，时间 O(n²)。
 * @扩展：若数组有序，可用双指针优化为 O(n)（左右指针向中间移动）。
 */
void TwoSum(ElemType arr[], int length, ElemType target, int indices[]) {
    for (int i = 0; i < length; i++) {
        for (int j = i + 1; j < length; j++) { // j 从 i+1 开始，避免重复和自身
            if (arr[i] + arr[j] == target) {
                indices[0] = i;
                indices[1] = j;
                return; // 找到唯一解后立即返回
            }
        }
    }
}
```

### 7. 移除元素（删除所有值为 val 的元素，O(n)）

```c
/**
 * @brief 原地删除数组中所有值为 val 的元素，返回新长度
 * @param arr：目标数组
 * @param length：数组长度指针
 * @param val：待删除值
 * @return int：新长度
 * @考点：双指针法（快慢指针）实现原地修改，空间 O(1)。慢指针 i 指向新数组的下一个有效位置。
 */
int RemoveElement(ElemType arr[], int *length, ElemType val) {
    int i = 0; // 慢指针：指向有效元素应该存放的位置

    // 快指针 j 遍历整个数组
    for (int j = 0; j < *length; j++) {
        if (arr[j] != val) { // 如果当前元素不是待删除的值
            arr[i] = arr[j]; // 将非 val 元素前移到 i 位置
            i++;             // 慢指针向前移动
        }
        // 如果 arr[j] == val，则跳过，j 继续前进，arr[i]保持不变，等待被覆盖
    }
    *length = i; // 更新数组的实际长度
    return i;    // 返回新长度
}
```

### 8. 数组旋转（将数组向右旋转 k 步，O(n)）

```c
/**
 * @brief 辅助函数：反转数组指定区间的元素
 * @param arr：目标数组
 * @param start：起始索引
 * @param end：结束索引
 */
void _Reverse(ElemType arr[], int start, int end) {
    while (start < end) {
        ElemType temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}

/**
 * @brief 反转法实现数组右旋转（如 [1,2,3,4,5], k=2 → [4,5,1,2,3]）
 * @param arr：目标数组
 * @param length：数组长度
 * @param k：旋转步数
 * @考点：反转法的时间 O(n)、空间 O(1)，优于暴力移动（O(kn)）。
 * 步骤：
 * 1. 整体反转：[1,2,3,4,5] -> [5,4,3,2,1]
 * 2. 反转前 k 个元素：[5,4,3,2,1] -> [4,5,3,2,1]
 * 3. 反转剩余 n-k 个元素：[4,5,3,2,1] -> [4,5,1,2,3]
 */
void RotateArray(ElemType arr[], int length, int k) {
    if (length == 0 || k == 0) return;
    k %= length; // 处理 k ≥ length 的情况

    // 三步反转法
    _Reverse(arr, 0, length - 1); // 1. 整体反转： [5,4,3,2,1]
    _Reverse(arr, 0, k - 1);      // 2. 反转前 k 个： [4,5,3,2,1]
    _Reverse(arr, k, length - 1); // 3. 反转剩余部分： [4,5,1,2,3]
}
```

### 9. 寻找数组的中心索引（左侧和 = 右侧和，O(n)）

```c
/**
 * @brief 寻找中心索引：左侧所有元素和等于右侧所有元素和（中心元素不计入左右）
 * @param arr：目标数组
 * @param length：数组长度
 * @return int：中心索引（-1 表示无）
 * @考点：两趟遍历。第一趟计算总和，第二趟遍历并维护左侧和，从而推导右侧和。时间 O(n)。
 */
int PivotIndex(ElemType arr[], int length) {
    int totalSum = 0;
    // 第一步：计算数组所有元素的总和
    for (int i = 0; i < length; i++) {
        totalSum += arr[i];
    }

    int leftSum = 0;
    // 第二步：遍历数组，维护 leftSum，并判断是否满足中心索引条件
    for (int i = 0; i < length; i++) {
        // 右侧和 = 总和 - 左侧和 - 当前元素 (即 arr[i] 不包含在 leftSum 和 rightSum 中)
        if (leftSum == totalSum - leftSum - arr[i]) {
            return i; // 找到中心索引
        }
        leftSum += arr[i]; // 更新 leftSum，用于下一个元素的判断
    }
    return -1; // 未找到中心索引
}
```

### 10. 数组中出现次数超过一半的元素（O(n)）

```c
/**
 * @brief 摩尔投票法：找出出现次数 > length/2 的元素（假设该元素存在）
 * @param arr：目标数组
 * @param length：数组长度
 * @return ElemType：该多数元素
 * @考点：摩尔投票法空间 O(1)，优于哈希表（O(n) 空间）。
 */
ElemType MajorityElement(ElemType arr[], int length) {
    // 假设数组非空，且多数元素必然存在
    ElemType candidate = arr[0];
    int count = 1;

    // 投票阶段：相同+1，不同-1，count=0 更换候选人
    for (int i = 1; i < length; i++) {
        if (count == 0) {
            candidate = arr[i];
            count = 1;
        } else if (arr[i] == candidate) {
            count++;
        } else {
            count--;
        }
    }
    return candidate; // 题目保证存在，无需额外验证
}
```

### 11. 有序数组的平方（升序排列，O(n)）

```c
/**
 * @brief 给有序数组（含负数）的元素平方后按升序排列
 * @param arr：有序数组（非递减）
 * @param length：数组长度
 * @param res：结果数组（需提前分配好与 arr 相同长度的内存）
 * @考点：双指针从两端向中间移动，利用原数组有序性。
 * 因为负数平方后可能很大，最大值一定在原数组的两端。
 */
void SortedSquares(ElemType arr[], int length, ElemType res[]) {
    int left = 0, right = length - 1;
    int idx = length - 1; // 从结果数组的尾部开始填充

    while (left <= right) {
        int squareLeft = arr[left] * arr[left];
        int squareRight = arr[right] * arr[right];

        if (squareLeft > squareRight) {
            res[idx--] = squareLeft; // 将较大的平方值放到结果数组的末尾
            left++;                  // 移动左指针
        } else {
            res[idx--] = squareRight; // 将较大的平方值放到结果数组的末尾
            right--;                  // 移动右指针
        }
    }
}
```

### 12. 长度最小的子数组（和≥target 的最短连续子数组，O(n)）

```c
#include <limits.h> // For INT_MAX
// 辅助函数 (如果需要，也可以用宏定义)
// int min(int a, int b) { return a < b ? a : b; }

/**
 * @brief 滑动窗口法求最小长度（假设数组元素为正）
 * @param arr：目标数组
 * @param length：数组长度
 * @param target：目标和
 * @return int：最小长度（0 表示无满足条件的子数组）
 * @考点：滑动窗口，时间 O(n)，空间 O(1)。
 */
int MinSubArrayLen(ElemType arr[], int length, int target) {
    int minLen = length + 1; // 初始化为不可能的长度（比实际最大长度还大）
    int left = 0;             // 窗口左边界
    int currentSum = 0;       // 当前窗口内的元素和

    for (int right = 0; right < length; right++) {
        currentSum += arr[right]; // 扩大窗口，加入右边界元素

        // 当窗口内和 >= target 时，尝试缩小左边界以找到更短的子数组
        while (currentSum >= target) {
            int currentLen = right - left + 1; // 当前窗口的长度
            // minLen = min(minLen, currentLen); // 更新最小长度
            if (currentLen < minLen) {
                minLen = currentLen;
            }
            currentSum -= arr[left++]; // 缩小窗口，移除左边界元素，并移动左指针
        }
    }
    return minLen > length ? 0 : minLen; // 如果 minLen 仍为初始值，说明没有找到
}
```

### 13. 杨辉三角（生成前 n 行，O(n²)）

```c
#include <stdlib.h> // For malloc

/**
 * @brief 生成杨辉三角前 n 行
 * @param n：行数
 * @param triangle：二维数组存储结果（需外部传入 int**，每一行内部需要malloc）
 * @param rowSizes：存储每行元素个数的数组（int*）
 * @考点：二维数组动态分配和元素生成规则（每行首尾为 1，中间元素为上一行左右两数和）。
 */
void GeneratePascalTriangle(int n, int **triangle, int *rowSizes) {
    for (int i = 0; i < n; i++) {
        rowSizes[i] = i + 1; // 第 i 行有 i+1 个元素
        triangle[i] = (int *)malloc(rowSizes[i] * sizeof(int));
        if (triangle[i] == NULL) {
            // 内存分配失败处理
            fprintf(stderr, "内存分配失败，行 %d\n", i);
            // 释放之前分配的内存
            for(int k = 0; k < i; ++k) free(triangle[k]);
            return;
        }

        triangle[i][0] = 1; // 首元素
        triangle[i][i] = 1; // 尾元素

        // 填充中间元素
        for (int j = 1; j < i; j++) {
            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
        }
    }
}
```

### 14. 查找峰值元素（峰值≥相邻元素，O(logn)）

```c
// 辅助函数 (如果需要，也可以用宏定义)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 查找数组中的一个峰值元素
 * @param arr：目标数组 (假设 nums[-1] = nums[n] = -∞)
 * @param length：数组长度
 * @return int：峰值索引 (可能有多个峰值，返回其中一个即可)
 * @考点：利用二分查找优化，无需遍历所有元素。
 */
int FindPeakElement(ElemType arr[], int length) {
    int left = 0, right = length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        // 如果 arr[mid] > arr[mid + 1]，说明 mid 可能是峰值，或者峰值在 mid 的左侧
        // 因此将右边界缩小到 mid
        if (arr[mid] > arr[mid + 1]) {
            right = mid;
        } else { // arr[mid] < arr[mid + 1]，说明峰值在 mid 的右侧
            left = mid + 1;
        }
        // arr[mid] == arr[mid+1] 的情况，根据题目假设通常不会出现
        // 如果出现，二分查找会选择向右或向左，最终总能找到一个峰值
    }
    return left; // 当 left == right 时，找到峰值
}
```

### 15. 移动零（将所有 0 移到末尾，保持非零元素顺序，O(n)）

```c
/**
 * @brief 将数组中的所有 0 移动到末尾，同时保持非零元素的相对顺序
 * @param arr：目标数组
 * @param length：数组长度
 * @考点：双指针法：非零元素前移，剩余位置补 0。时间 O(n)，空间 O(1)。
 */
void MoveZeroes(ElemType arr[], int length) {
    int i = 0; // i 指针：指向下一个非零元素应该存放的位置

    // 第一步：将所有非零元素前移
    // 快指针 j 遍历整个数组
    for (int j = 0; j < length; j++) {
        if (arr[j] != 0) { // 如果当前元素是非零元素
            arr[i++] = arr[j]; // 将其放到 i 位置，并移动 i 指针
        }
        // 如果 arr[j] == 0，则跳过，i 指针不动，j 继续前进
    }

    // 第二步：将 i 指针之后的所有位置填充为 0
    while (i < length) {
        arr[i++] = 0;
    }
}
```

### 16. 寻找重复数（数组长度 n+1，元素 1~n，有且仅有一个重复数，O(n)）

```c
/**
 * @brief 找出数组中唯一的重复数（快慢指针法，模拟链表环检测）
 * @param arr：目标数组（长度 n+1，元素范围 1~n，有且仅有一个重复数）
 * @param length：数组长度（实际是 n+1）
 * @return int：重复数
 * @考点：快慢指针法（Floyd's Cycle Finding Algorithm），空间 O(1)，不修改原数组，优于哈希表。
 * 将数组索引和值视为链表：索引 i 指向值为 arr[i] 的下一个索引。
 */
int FindDuplicate(ElemType arr[], int length) {
    // 假设数组中至少有两个元素 (length >= 2)
    // 否则根据题目约束 (1~n 范围)，如果 length=1, 元素 1~0 不可能，所以 length 至少是 2
    // 快慢指针初始位置不同：慢指针从 arr[0] 开始，快指针从 arr[arr[0]] 开始
    int slow = arr[0];
    int fast = arr[arr[0]];

    // 第一步：寻找快慢指针相遇点
    // 相遇点一定在环内
    while (slow != fast) {
        slow = arr[slow];       // 慢指针走一步
        fast = arr[arr[fast]];  // 快指针走两步
    }

    // 第二步：寻找环的入口点（即重复数）
    // 将快指针重新放到起点（索引 0），慢指针留在相遇点
    // 两个指针都以一步的速度前进，再次相遇时就是环的入口（重复数）
    fast = 0; // 这里的 0 是数组的索引
    while (slow != fast) {
        slow = arr[slow];
        fast = arr[fast];
    }
    return slow; // 返回环的入口点，即重复的数字
}
```

### 17. 加一（数组表示非负整数，末尾加 1，O(n)）

```c
/**
 * @brief 将数组表示的非负整数末尾加 1（如 [1,2,3]→[1,2,4]， [9,9]→[1,0,0]）
 * @param arr：目标数组
 * @param length：数组长度指针（可能需要扩容，此处简化处理）
 * @考点：从数组末尾开始处理进位。当最高位有进位时，需要扩容数组。
 */
void PlusOne(ElemType arr[], int *length) {
    int carry = 1; // 初始进位为 1 (表示要加 1)

    // 从数组末尾开始向前遍历处理进位
    for (int i = *length - 1; i >= 0 && carry; i--) {
        int sum = arr[i] + carry; // 当前位与进位相加
        arr[i] = sum % 10;         // 更新当前位
        carry = sum / 10;          // 计算新的进位
    }

    // 若仍有进位 (例如 999 + 1 = 1000)，说明需要扩容数组
    if (carry) {
        // 实际操作中，如果 arr 是静态数组，则无法直接扩容。
        // 如果是动态数组，则需要重新分配更大的内存并将所有元素移动过去。
        printf("需要扩容：在数组头部插入 1，长度变为 %d\n", *length + 1);
        // 示例：如果实际是动态数组，这里会进行 realloc 等操作
        // ElemType *newArr = (ElemType*)malloc((*length + 1) * sizeof(ElemType));
        // newArr[0] = 1;
        // memcpy(newArr + 1, arr, *length * sizeof(ElemType));
        // free(arr);
        // arr = newArr;
        // (*length)++;
    }
}
```

### 18. 最长连续递增子序列（O(n)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 寻找数组中最长连续递增子序列的长度（如 [1,3,5,4,7] → 3，对应 [1,3,5]）
 * @param arr：目标数组
 * @param length：数组长度
 * @return int：最大长度
 * @考点：简单遍历，维护当前连续长度和最大长度。时间 O(n)，空间 O(1)。
 */
int FindLengthOfLCIS(ElemType arr[], int length) {
    if (length == 0) return 0;

    int maxLen = 1;      // 记录全局最长连续递增子序列的长度
    int currentLen = 1;  // 记录当前连续递增子序列的长度

    for (int i = 1; i < length; i++) {
        if (arr[i] > arr[i - 1]) { // 如果当前元素比前一个大，继续递增
            currentLen++;
            // maxLen = max(maxLen, currentLen); // 更新全局最长长度
            if (currentLen > maxLen) maxLen = currentLen;
        } else { // 如果不递增，则当前连续序列中断，重置计数
            currentLen = 1;
        }
    }
    return maxLen;
}
```

### 19. 接雨水（计算能接多少雨水，O(n)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }
// int min(int a, int b) { return a < b ? a : b; }

/**
 * @brief 计算数组中能接多少雨水
 * @param height：高度数组
 * @param length：数组长度
 * @return int：雨水量
 * @考点：双指针优化空间至 O(1)，替代动态规划（O(n) 空间）。
 * 关键思想：较矮的那根柱子决定了能接多少水。
 */
int Trap(int height[], int length) {
    if (length <= 2) return 0; // 小于等于 2 根柱子无法接水

    int left = 0, right = length - 1; // 左右指针
    int leftMax = 0, rightMax = 0;   // 记录左右两侧的最高柱子高度
    int water = 0;                   // 累积的雨水量

    while (left < right) {
        // 始终从较低的一侧开始处理，因为水的高度由较矮的一侧决定
        if (height[left] <= height[right]) {
            // 左侧为短板，以 leftMax 为基准
            if (height[left] >= leftMax) {
                leftMax = height[left]; // 更新左侧最高高度
            } else {
                water += leftMax - height[left]; // 累加雨水
            }
            left++; // 左指针向右移动
        } else {
            // 右侧为短板，以 rightMax 为基准
            if (height[right] >= rightMax) {
                rightMax = height[right]; // 更新右侧最高高度
            } else {
                water += rightMax - height[right]; // 累加雨水
            }
            right--; // 右指针向左移动
        }
    }
    return water;
}
```

### 20. 数组中第 k 大的元素（O(n) 平均，快排思想）

```c
#include <stdlib.h> // For qsort (if needed, or custom partition)

// 辅助函数：交换元素
void Swap(ElemType *a, ElemType *b) {
    ElemType temp = *a;
    *a = *b;
    *b = temp;
}

/**
 * @brief 辅助函数：划分（快排核心，选取基准并放置到正确位置）
 * @param arr：目标数组
 * @param left：当前区间的左边界索引
 * @param right：当前区间的右边界索引
 * @return int：基准元素最终所在的索引
 */
int Partition(ElemType arr[], int left, int right) {
    // 通常选择最右边元素作为基准 (pivot)
    ElemType pivot = arr[right];
    int i = left; // i 指针：指向下一个比基准小的元素应该放置的位置

    // 遍历从 left 到 right-1 的元素
    for (int j = left; j < right; j++) {
        if (arr[j] <= pivot) { // 如果当前元素小于等于基准
            Swap(&arr[i], &arr[j]); // 将其交换到 i 位置
            i++;                    // i 指针向右移动
        }
    }
    Swap(&arr[i], &arr[right]); // 将基准元素放到最终正确位置 (i)
    return i;                   // 返回基准元素的索引
}

/**
 * @brief 查找数组中第 k 大的元素（k 从 1 开始）
 * @param arr：目标数组
 * @param length：数组长度
 * @param k：第 k 大
 * @return ElemType：元素值
 * @考点：快速选择算法 (Quickselect)，基于快速排序的划分思想。平均时间 O(n)。
 * 核心思想：将查找第 k 大转换为查找第 (length - k) 小的元素 (0-based 索引)。
 */
ElemType FindKthLargest(ElemType arr[], int length, int k) {
    // 将“第 k 大”转换为“第 target 小” (0-based 索引)
    // 例如，第 1 大是 length-1 小；第 length 大是 0 小
    int target = length - k;
    int left = 0, right = length - 1;

    while (left <= right) { // 循环直到找到目标索引
        int pivotIdx = Partition(arr, left, right); // 进行一次划分操作

        if (pivotIdx == target) {
            return arr[pivotIdx]; // 如果基准恰好是目标索引，则找到
        } else if (pivotIdx < target) {
            left = pivotIdx + 1; // 如果基准索引太小，目标在右侧子区间
        } else { // pivotIdx > target
            right = pivotIdx - 1; // 如果基准索引太大，目标在左侧子区间
        }
    }
    // 理论上，如果 k 合法，循环一定会找到并返回，此行代码一般不会执行
    return -1; // 表示未找到 (通常不会发生，除非 k 不合法)
}
```

### 21. 三数之和（找出所有和为 0 的三元组，O(n²)）

```c
#include <stdlib.h> // For qsort
// 辅助函数：qsort 的比较函数 (升序)
int compareInt(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

/**
 * @brief 找出数组中所有和为 0 的不重复三元组
 * @param arr：目标数组
 * @param length：数组长度
 * @param result：存储结果的二维数组（需外部管理内存，例如动态分配并传入）
 * @param count：结果数量指针
 * @考点：先排序（O(nlogn)），再使用双指针（O(n)），总时间 O(nlogn + n^2) = O(n^2)。
 * 关键点在于排序后的去重逻辑。
 */
void ThreeSum(ElemType arr[], int length, ElemType **result, int *count) {
    *count = 0;
    if (length < 3) return;

    // 第一步：排序（便于去重和双指针）
    qsort(arr, length, sizeof(ElemType), compareInt);

    for (int i = 0; i < length - 2; i++) {
        // 优化：如果 arr[i] 已经大于 0，则后续元素更大，不可能和为 0
        if (arr[i] > 0) break;
        // 去重：如果当前元素与前一个元素相同，跳过，避免生成重复的三元组
        if (i > 0 && arr[i] == arr[i - 1]) continue;

        int left = i + 1;         // 左指针
        int right = length - 1;   // 右指针

        while (left < right) {
            int sum = arr[i] + arr[left] + arr[right];

            if (sum == 0) {
                // 找到一个三元组
                // 假设 result 已经为每行分配了 3 个 ElemType 的空间
                result[*count][0] = arr[i];
                result[*count][1] = arr[left];
                result[*count][2] = arr[right];
                (*count)++;

                // 去重：移动 left 和 right 指针，跳过重复元素
                while (left < right && arr[left] == arr[left + 1]) left++;
                while (left < right && arr[right] == arr[right - 1]) right--;

                left++;  // 移动到下一个不同的元素
                right--; // 移动到下一个不同的元素
            } else if (sum < 0) {
                left++;  // 和太小，左指针右移增大和
            } else { // sum > 0
                right--; // 和太大，右指针左移减小和
            }
        }
    }
}
```

### 22. 寻找两个正序数组的中位数（O(log(m+n))）

```c
#include <limits.h> // For INT_MIN, INT_MAX
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }
// int min(int a, int b) { return a < b ? a : b; }

/**
 * @brief 寻找两个正序数组的中位数
 * @param nums1：数组 1
 * @param m：数组 1 长度
 * @param nums2：数组 2
 * @param n：数组 2 长度
 * @return double：中位数
 * @考点：二分查找法，将二维中位数问题转换为一维分割点问题。时间 O(log(min(m,n)))。
 * 目标：在两个数组中找到一个分割点，使得左半部分元素个数和右半部分元素个数相等，
 * 且左半部分所有元素 <= 右半部分所有元素。
 */
double FindMedianSortedArrays(int nums1[], int m, int nums2[], int n) {
    // 确保 nums1 是较短数组，优化二分查找效率
    if (m > n) return FindMedianSortedArrays(nums2, n, nums1, m);

    int iMin = 0, iMax = m;
    int halfLen = (m + n + 1) / 2; // 左半部分的总长度（向上取整，以处理总长为奇数的情况）

    while (iMin <= iMax) {
        int i = iMin + (iMax - iMin) / 2; // nums1 的分割点 (左半部分有 i 个元素)
        int j = halfLen - i;             // nums2 的分割点 (左半部分有 j 个元素)

        // 调整分割点：i 太小，说明 nums1 左侧元素太少，需要向右移动 i
        // 对应条件：nums2 左侧的最大值 > nums1 右侧的最小值
        if (i < iMax && nums2[j - 1] > nums1[i]) {
            iMin = i + 1;
        }
        // i 太大，说明 nums1 左侧元素太多，需要向左移动 i
        // 对应条件：nums1 左侧的最大值 > nums2 右侧的最小值
        else if (i > iMin && nums1[i - 1] > nums2[j]) {
            iMax = i - 1;
        }
        // 找到合适分割点：满足条件 (nums1[i-1] <= nums2[j] 且 nums2[j-1] <= nums1[i])
        else {
            int maxLeft = 0; // 左半部分的最大值
            if (i == 0) maxLeft = nums2[j - 1]; // nums1 左半部分为空，则取 nums2 左半部分最大值
            else if (j == 0) maxLeft = nums1[i - 1]; // nums2 左半部分为空，则取 nums1 左半部分最大值
            else maxLeft = (nums1[i - 1] > nums2[j - 1]) ? nums1[i - 1] : nums2[j - 1]; // 否则取两者中较大者

            // 如果总长度为奇数，中位数就是左半部分的最大值
            if ((m + n) % 2 == 1) return (double)maxLeft;

            // 如果总长度为偶数，中位数是左半部分最大值和右半部分最小值的平均值
            int minRight = 0; // 右半部分的最小值
            if (i == m) minRight = nums2[j]; // nums1 右半部分为空，则取 nums2 右半部分最小值
            else if (j == n) minRight = nums1[i]; // nums2 右半部分为空，则取 nums1 右半部分最小值
            else minRight = (nums1[i] < nums2[j]) ? nums1[i] : nums2[j]; // 否则取两者中较小者

            return (maxLeft + minRight) / 2.0;
        }
    }
    return 0.0; // 理论上不会走到这里，除非输入不合法
}
```

### 23. 合并区间（O(nlogn)，排序后合并）

```c
#include <stdlib.h> // For qsort
// 区间结构体
typedef struct {
    int start;
    int end;
} Interval;

// 辅助函数：比较区间（用于 qsort 排序），按 start 值升序
int CompareIntervals(const void *a, const void *b) {
    return ((Interval *)a)->start - ((Interval *)b)->start;
}
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 合并所有重叠的区间（如 [[1,3],[2,6]] → [[1,6]]）
 * @param intervals：原始区间数组
 * @param length：原始区间数量
 * @param result：合并后的区间数组（需外部管理内存，假设足够大）
 * @param resLen：结果长度指针
 * @考点：先按区间起始点排序（O(nlogn)），然后遍历合并。
 */
void MergeIntervals(Interval intervals[], int length, Interval *result, int *resLen) {
    *resLen = 0;
    if (length == 0) return;

    // 1. 按区间的 start 值进行排序
    qsort(intervals, length, sizeof(Interval), CompareIntervals);

    // 2. 初始化结果数组的第一个区间为排序后的第一个区间
    result[0] = intervals[0];
    *resLen = 1;

    // 3. 遍历后续区间进行合并
    for (int i = 1; i < length; i++) {
        Interval *lastMerged = &result[*resLen - 1]; // 获取已合并的最后一个区间

        // 如果当前区间的 start 小于等于已合并区间 (lastMerged) 的 end，说明有重叠
        if (intervals[i].start <= lastMerged->end) {
            // 合并：更新已合并区间的 end 为当前区间 end 和 lastMerged end 的较大值
            lastMerged->end = (intervals[i].end > lastMerged->end) ? intervals[i].end : lastMerged->end;
        } else {
            // 没有重叠，将当前区间作为一个新的不重叠区间添加到结果中
            result[*resLen] = intervals[i];
            (*resLen)++;
        }
    }
}
```

### 24. 螺旋矩阵（按顺时针螺旋顺序返回元素，O(n²)）

```c
/**
 * @brief 按顺时针螺旋顺序遍历二维矩阵并返回所有元素
 * @param matrix：二维矩阵（int**，需外部管理内存）
 * @param rows：行数
 * @param cols：列数
 * @param result：存储结果的数组（int*，需外部管理内存，大小为 rows*cols）
 * @param resLen：结果长度指针
 * @考点：按层遍历，通过四个边界 (top, bottom, left, right) 控制方向并逐层收缩。
 */
void SpiralOrder(int **matrix, int rows, int cols, int *result, int *resLen) {
    *resLen = 0;
    if (rows == 0 || cols == 0) return;

    int top = 0, bottom = rows - 1;   // 顶部和底部边界
    int left = 0, right = cols - 1;   // 左侧和右侧边界

    while (top <= bottom && left <= right) {
        // 1. 从左到右遍历顶部行
        for (int col = left; col <= right; col++) {
            result[*resLen] = matrix[top][col];
            (*resLen)++;
        }
        top++; // 顶部边界向下收缩

        // 2. 从上到下遍历右侧列
        for (int row = top; row <= bottom; row++) {
            result[*resLen] = matrix[row][right];
            (*resLen)++;
        }
        right--; // 右侧边界向左收缩

        // 3. 从右到左遍历底部行（需判断 top <= bottom，避免单行/单列情况重复）
        if (top <= bottom) {
            for (int col = right; col >= left; col--) {
                result[*resLen] = matrix[bottom][col];
                (*resLen)++;
            }
            bottom--; // 底部边界向上收缩
        }

        // 4. 从下到上遍历左侧列（需判断 left <= right，避免单行/单列情况重复）
        if (left <= right) {
            for (int row = bottom; row >= top; row--) {
                result[*resLen] = matrix[row][left];
                (*resLen)++;
            }
            left++; // 左侧边界向右收缩
        }
    }
}
```

### 25. 搜索二维矩阵（每行有序，下一行首元素 > 上一行尾元素，O(log(mn))）

```c
/**
 * @brief 在一个特殊的二维矩阵中搜索目标值
 * @param matrix：二维矩阵（int**）
 * @param rows：行数
 * @param cols：列数
 * @param target：目标值
 * @return bool：是否存在
 * @考点：将二维矩阵视为一维有序数组进行二分查找。
 * 转换公式：一维索引 `mid` 对应二维坐标 `(mid / cols, mid % cols)`。
 */
bool SearchMatrix(int **matrix, int rows, int cols, int target) {
    if (rows == 0 || cols == 0) return false;

    int left = 0, right = rows * cols - 1; // 将二维矩阵展平为一维数组的索引范围

    while (left <= right) {
        int mid = left + (right - left) / 2; // 计算中间索引

        // 将一维索引 mid 转换为二维坐标 (row, col)
        int midRow = mid / cols;
        int midCol = mid % cols;
        int midVal = matrix[midRow][midCol];

        if (midVal == target) {
            return true; // 找到目标值
        } else if (midVal < target) {
            left = mid + 1; // 目标值在右半部分
        } else { // midVal > target
            right = mid - 1; // 目标值在左半部分
        }
    }
    return false; // 未找到目标值
}
```

### 26. 子数组最大平均数 I（固定长度窗口，O(n)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 求长度为 k 的连续子数组的最大平均数
 * @param arr：目标数组
 * @param length：数组长度
 * @param k：子数组固定长度
 * @return double：最大平均数（若 k>length 返回 0.0）
 * @考点 1：滑动窗口求和优化，避免重复计算子数组和。
 * @考点 2：强制类型转换避免整数除法。
 */
double FindMaxAverage(int arr[], int length, int k) {
    if (k > length || length == 0 || k <= 0) return 0.0; // 边界条件检查

    int currentSum = 0;
    // 1. 计算初始窗口的和 (前 k 个元素)
    for (int i = 0; i < k; i++) {
        currentSum += arr[i];
    }
    int maxSum = currentSum; // 初始化最大和

    // 2. 滑动窗口：从 k 索引开始，每次滑动一步
    for (int i = k; i < length; i++) {
        // 移除最左边的元素 (arr[i - k])，加入最右边的新元素 (arr[i])
        currentSum = currentSum - arr[i - k] + arr[i];
        // maxSum = max(maxSum, currentSum); // 更新最大和
        if (currentSum > maxSum) {
            maxSum = currentSum;
        }
    }
    return (double)maxSum / k; // 返回最大和的平均值，注意强制类型转换
}
```

### 27. 最长重复子数组（动态规划，O(nm)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 寻找两个数组中最长的连续公共子数组长度
 * @param nums1：数组 1
 * @param len1：数组 1 长度
 * @param nums2：数组 2
 * @param len2：数组 2 长度
 * @return int：最长长度
 * @考点：动态规划。dp[i][j] 表示以 nums1[i-1] 和 nums2[j-1] 结尾的最长公共子数组的长度。
 */
int FindLength(int nums1[], int len1, int nums2[], int len2) {
    if (len1 == 0 || len2 == 0) return 0;

    // DP 表：dp[i][j] 表示 nums1 的前 i 个元素与 nums2 的前 j 个元素的最长公共后缀长度
    // dp 表大小 (len1 + 1) x (len2 + 1)
    // 动态分配二维数组 (C99 支持变长数组，但兼容性考虑推荐 malloc)
    int (*dp)[len2 + 1] = malloc((len1 + 1) * sizeof(int[len2 + 1]));
    if (dp == NULL) {
        fprintf(stderr, "内存分配失败\n");
        return 0;
    }

    int maxLen = 0;

    // 初始化 DP 表（首行首列为 0，因为空数组无公共子数组）
    for (int i = 0; i <= len1; i++) dp[i][0] = 0;
    for (int j = 0; j <= len2; j++) dp[0][j] = 0;

    // 填充 DP 表
    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (nums1[i - 1] == nums2[j - 1]) { // 如果当前元素相等
                dp[i][j] = dp[i - 1][j - 1] + 1; // 公共后缀长度在前一个基础上加 1
                // maxLen = max(maxLen, dp[i][j]); // 更新全局最长长度
                if (dp[i][j] > maxLen) maxLen = dp[i][j];
            } else {
                dp[i][j] = 0; // 元素不等，公共后缀中断，长度为 0
            }
        }
    }

    free(dp); // 释放内存
    return maxLen;
}
```

### 28. 数组的度（哈希统计，O(n)）

```c
#include <limits.h> // For INT_MAX
#include <stdio.h>

// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }
// int min(int a, int b) { return a < b ? a : b; }

/**
 * @brief 数组的度：出现频率最高的元素的频率。找出与度相同的最短子数组长度。
 * @param nums：目标数组
 * @param length：数组长度
 * @return int：最短子数组长度
 * @考点：使用数组模拟哈希表来统计频率、首次出现索引、末次出现索引。时间 O(n)。
 * 假设元素范围已知且较小 (0~50000)。
 */
int FindShortestSubArray(int nums[], int length) {
    if (length == 0) return 0;

    // 使用三个数组模拟哈希表，假设元素值范围 0 ~ 50000
    int freq[50001] = {0};   // 存储每个元素出现的频率
    int first[50001];       // 存储每个元素首次出现的索引
    int last[50001];        // 存储每个元素末次出现的索引

    // 初始化 first 数组为 -1，表示未出现
    for (int i = 0; i <= 50000; i++) {
        first[i] = -1;
    }

    int maxFreq = 0; // 记录数组的最大频率 (即“度”)

    // 第一次遍历：统计频率，记录首次和末次出现索引
    for (int i = 0; i < length; i++) {
        int num = nums[i];
        if (first[num] == -1) { // 如果是首次出现
            first[num] = i;
        }
        last[num] = i; // 更新末次出现索引

        freq[num]++; // 增加频率
        // maxFreq = max(maxFreq, freq[num]); // 更新最大频率
        if (freq[num] > maxFreq) maxFreq = freq[num];
    }

    // 第二次遍历：找出频率等于 maxFreq 的元素中，对应的最短子数组长度
    int minLen = length; // 初始化最短长度为数组总长

    // 再次遍历数组，但只检查那些频率等于 maxFreq 的元素
    // 也可以遍历所有可能的数字，但遍历原数组更高效
    for (int i = 0; i < length; i++) {
        int num = nums[i];
        if (freq[num] == maxFreq) {
            int len = last[num] - first[num] + 1; // 计算子数组长度
            // minLen = min(minLen, len); // 更新最短长度
            if (len < minLen) minLen = len;
            // 找到一个度数相同的元素的最小长度后，将其频率设为0，避免重复计算
            // 这一步是优化，确保每个数字只处理一次。
            freq[num] = 0; 
        }
    }
    return minLen;
}
```

### 29. 最短无序连续子数组（排序对比，O(nlogn)）

```c
#include <stdlib.h> // For qsort
#include <string.h> // For memcpy (used for copying array)

// 辅助函数：qsort 的比较函数（升序）
int cmp(const void *a, const void *b) {
    return *(int *)a - *(int *)b;
}

/**
 * @brief 找出需排序的最短连续子数组，使得整个数组排序后有序
 * @param nums：目标数组
 * @param length：数组长度
 * @return int：子数组长度（无需排序返回 0）
 * @考点 1：复制数组并排序，然后与原数组对比。
 * @考点 2：边界判断（如果已完全有序，返回 0）。
 */
int FindUnsortedSubarray(int nums[], int length) {
    if (length <= 1) return 0;

    // 1. 复制数组并排序
    int *temp = (int *)malloc(length * sizeof(int));
    if (temp == NULL) {
        fprintf(stderr, "内存分配失败\n");
        return 0;
    }
    memcpy(temp, nums, length * sizeof(int)); // 将 nums 复制到 temp
    qsort(temp, length, sizeof(int), cmp);    // 对 temp 进行排序

    int left = 0, right = length - 1;

    // 2. 找左边界：从左往右，找到第一个与排序数组不同的位置
    while (left < length && nums[left] == temp[left]) {
        left++;
    }

    // 3. 找右边界：从右往左，找到第一个与排序数组不同的位置
    while (right >= 0 && nums[right] == temp[right]) {
        right--;
    }

    free(temp); // 释放临时数组内存

    // 4. 计算子数组长度
    // 如果 left >= right，说明数组已经有序，无需排序（或者只有一个元素/空区间）
    return left >= right ? 0 : right - left + 1;
}
```

### 30. 旋转图像（90 度原地旋转，O(n²)）

```c
/**
 * @brief 顺时针旋转 n x n 矩阵 90 度（原地操作）
 * @param matrix：n x n 二维矩阵（int**）
 * @param n：矩阵边长
 * @考点 1：两次翻转替代旋转：先沿主对角线翻转，再沿垂直中线翻转。
 * @考点 2：原地操作，空间 O(1)。
 */
void Rotate(int **matrix, int n) {
    // 1. 先沿主对角线翻转 (matrix[i][j] ↔ matrix[j][i])
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) { // 只遍历上三角部分，避免重复交换
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // 2. 再沿垂直中线翻转 (matrix[i][j] ↔ matrix[i][n-1-j])
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n / 2; j++) { // 只遍历每行的前半部分
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][n - 1 - j];
            matrix[i][n - 1 - j] = temp;
        }
    }
}
```

### 31. 矩阵置零（原地标记，O(mn)）

```c
#include <stdbool.h> // For bool

/**
 * @brief 当矩阵中元素为 0 时，将其所在行和列全部置 0（原地操作）
 * @param matrix：m x n 二维矩阵（int**）
 * @param rows：行数
 * @param cols：列数
 * @考点 1：使用首行和首列作为标记数组，空间 O(1)。
 * @考点 2：特殊处理首行和首列自身是否需要置零，避免标记信息被覆盖。
 */
void SetZeroes(int **matrix, int rows, int cols) {
    if (rows == 0 || cols == 0) return;

    bool row0HasZero = false; // 标记首行是否含有 0
    bool col0HasZero = false; // 标记首列是否含有 0

    // 步骤 1：检查首行是否有 0
    for (int j = 0; j < cols; j++) {
        if (matrix[0][j] == 0) {
            row0HasZero = true;
            break;
        }
    }

    // 步骤 2：检查首列是否有 0
    for (int i = 0; i < rows; i++) {
        if (matrix[i][0] == 0) {
            col0HasZero = true;
            break;
        }
    }

    // 步骤 3：用首行首列标记其他行/列的 0 位置
    // 从 (1,1) 开始遍历，如果 matrix[i][j] 是 0，则将 matrix[i][0] 和 matrix[0][j] 置为 0
    for (int i = 1; i < rows; i++) {
        for (int j = 1; j < cols; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0; // 标记第 i 行需要置 0
                matrix[0][j] = 0; // 标记第 j 列需要置 0
            }
        }
    }

    // 步骤 4：根据首行首列的标记置零（除首行首列）
    // 从 (1,1) 开始，如果 matrix[i][0] 或 matrix[0][j] 为 0，则 matrix[i][j] 置 0
    for (int i = 1; i < rows; i++) {
        for (int j = 1; j < cols; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // 步骤 5：处理首行首列的 0 （最后处理，避免影响标记）
    if (row0HasZero) {
        for (int j = 0; j < cols; j++) matrix[0][j] = 0;
    }
    if (col0HasZero) {
        for (int i = 0; i < rows; i++) matrix[i][0] = 0;
    }
}
```

### 32. 对角线遍历（方向控制，O(mn)）

```c
/**
 * @brief 按对角线顺序遍历矩阵并返回所有元素
 * @param matrix：m x n 二维矩阵（int**）
 * @param rows：行数
 * @param cols：列数
 * @param result：输出数组（int*，长度 rows * cols，需外部管理内存）
 * @考点 1：方向控制：通过一个变量切换右上/左下方向。
 * @考点 2：边界处理：当到达矩阵边界时，需要调整行/列索引并改变方向。
 */
void FindDiagonalOrder(int **matrix, int rows, int cols, int *result) {
    if (rows == 0 || cols == 0) return;

    int row = 0, col = 0;  // 当前遍历的起始坐标
    int dir = 1;           // 方向：1 表示右上 (row--, col++)，-1 表示左下 (row++, col--)
    int idx = 0;           // 结果数组索引

    while (idx < rows * cols) {
        result[idx++] = matrix[row][col];

        // 右上方向 (dir == 1)
        if (dir == 1) {
            // 到达右上角 (列到右边界)
            if (col == cols - 1) {
                row++;   // 向下移动一格
                dir = -1; // 改变方向为左下
            }
            // 到达顶行 (行到上边界)
            else if (row == 0) {
                col++;   // 向右移动一格
                dir = -1; // 改变方向为左下
            }
            // 正常右上移动
            else {
                row--;
                col++;
            }
        }
        // 左下方向 (dir == -1)
        else {
            // 到达左下角 (行到底边界)
            if (row == rows - 1) {
                col++;   // 向右移动一格
                dir = 1; // 改变方向为右上
            }
            // 到达左列 (列到左边界)
            else if (col == 0) {
                row++;   // 向下移动一格
                dir = 1; // 改变方向为右上
            }
            // 正常左下移动
            else {
                row++;
                col--;
            }
        }
    }
}
```

### 33. 乘积小于 K 的子数组（滑动窗口，O(n)）

```c
/**
 * @brief 统计非负整数数组中乘积小于 k 的连续子数组个数
 * @param nums：目标数组 (非负整数)
 * @param length：数组长度
 * @param k：目标乘积上限 (k > 0)
 * @return int：子数组个数（若 k <= 1 或数组为空返回 0）
 * @考点 1：使用 long long 避免乘积溢出。
 * @考点 2：滑动窗口，乘积超过 k 时收缩左边界。每次窗口扩张，新增 right-left+1 个子数组。
 */
int NumSubarrayProductLessThanK(int nums[], int length, int k) {
    if (k <= 1 || length == 0) return 0; // k <= 1 意味着乘积不会小于 k (因为元素非负)

    int left = 0;          // 窗口左边界
    int count = 0;         // 统计符合条件的子数组个数
    long long currentProduct = 1; // 当前窗口内元素的乘积，用 long long 避免溢出

    for (int right = 0; right < length; right++) {
        currentProduct *= nums[right]; // 扩大窗口，加入右边界元素

        // 当窗口乘积 >= k 时，收缩左边界，直到乘积 < k
        while (currentProduct >= k) {
            currentProduct /= nums[left]; // 移除左边界元素
            left++;                       // 左指针向右移动
        }

        // 每次窗口扩张到 right 时，以 arr[right] 结尾，且乘积小于 k 的子数组有 (right - left + 1) 个
        // 例如，如果窗口是 [left, right]，那么以 right 结尾的子数组有 [right], [left, right-1, right], … [left, …, right]
        count += (right - left + 1);
    }
    return count;
}
```

### 35. 子数组异或和为 0 的个数（前缀异或 + 哈希，O(n)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 统计数组中异或和为 0 的连续子数组个数
 * @param nums：目标数组
 * @param length：数组长度
 * @return int：子数组个数
 * @考点：前缀异或结合哈希表。
 * 若 `prefixXor[i] == prefixXor[j]` (假设 `j < i`)，则 `nums[j]^…^nums[i-1]` 的异或和为 0。
 */
int SubarrayXorZero(int nums[], int length) {
    if (length == 0) return 0;

    int prefixXor = 0; // 记录当前的前缀异或和
    int count = 0;     // 统计异或和为 0 的子数组个数

    // 哈希表：key=前缀异或值，value=该值出现的次数
    // 假设异或值范围 0~1e6，使用数组模拟哈希表
    int hash[1000001] = {0};

    // 初始化：前缀异或为 0 出现 1 次 (对应空前缀，或子数组从索引 0 开始)
    hash[0] = 1;

    for (int i = 0; i < length; i++) {
        prefixXor ^= nums[i]; // 更新当前前缀异或和

        // 如果当前 `prefixXor` 值在哈希表中已存在，
        // 说明存在 `hash[prefixXor]` 个以 `i` 结尾，且异或和为 0 的子数组
        // (因为 `A ^ B = C` => `A ^ C = B`)
        // `prefixXor` (当前) `^ target (0) = previous_prefixXor`
        if (prefixXor <= 1000000 && hash[prefixXor] > 0) { // 检查索引范围
            count += hash[prefixXor];
        }

        // 更新哈希表：当前 `prefixXor` 的出现次数加 1
        if (prefixXor <= 1000000) { // 检查索引范围
            hash[prefixXor]++;
        } else {
            // 如果异或值超出 hash 数组范围，需要更高级的哈希结构
            // 或题目保证异或值在范围内
        }
    }
    return count;
}
```

### 36. 多数元素 II（摩尔投票法，O(n)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 找出数组中出现次数超过 n/3 次的所有元素（最多只有 2 个）
 * @param nums：目标数组
 * @param length：数组长度
 * @param result：输出数组（存储结果）
 * @param resLen：结果长度指针
 * @考点 1：摩尔投票法扩展，维护两个候选人及票数。
 * @考点 2：投票结束后需要再次遍历验证候选人是否真的满足条件。
 */
void MajorityElementII(int nums[], int length, int *result, int *resLen) {
    *resLen = 0;
    if (length == 0) return;

    // 1. 投票阶段：选出两个可能出现次数 > n/3 的候选人
    int cand1 = 0, cand2 = 0; // 候选人
    int count1 = 0, count2 = 0; // 候选人的票数

    for (int i = 0; i < length; i++) {
        if (nums[i] == cand1) {
            count1++;
        } else if (nums[i] == cand2) {
            count2++;
        } else if (count1 == 0) { // 如果第一个候选人票数为 0，更新为当前元素
            cand1 = nums[i];
            count1 = 1;
        } else if (count2 == 0) { // 如果第二个候选人票数为 0，更新为当前元素
            cand2 = nums[i];
            count2 = 1;
        } else { // 如果都不匹配，且两个候选人票数都不为 0，则同时抵消
            count1--;
            count2--;
        }
    }

    // 2. 验证阶段：确认这两个候选人是否真的满足出现次数 > n/3
    count1 = 0; // 重新计数
    count2 = 0;
    for (int i = 0; i < length; i++) {
        if (nums[i] == cand1) count1++;
        // 注意：这里需要确保 cand2 不等于 cand1，避免对同一元素重复计数
        // 如果 cand1 和 cand2 恰好被同一个多数元素占据，那么 if (nums[i] == cand2) 会是多余的
        // 但为了通用性，如果两个候选人恰好是不同元素，这里应确保分别计数
        // 实际上，摩尔投票的特性会使得cand1和cand2趋向于不同的高频元素
        else if (nums[i] == cand2) count2++;
    }

    if (count1 > length / 3) {
        result[(*resLen)++] = cand1;
    }
    // 只有当 cand2 和 cand1 不同时，才检查 cand2
    // 避免在某些情况下 (例如数组中只有一个多数元素) cand2 最终也变成了那个多数元素，导致结果重复
    if (count2 > length / 3 && cand2 != cand1) {
        result[(*resLen)++] = cand2;
    }
}
```

### 37. 找不同（异或 / 频率统计，O(n)）

```c
#include <string.h> // For strlen

/**
 * @brief 找出字符串 s 到 t 的重排中多出的那个字符
 * @param s：源字符串
 * @param t：目标字符串（比 s 多一个字符）
 * @return char：多出来的字符
 * @考点 1：异或特性：a^a=0, 0^a=a。所有字符异或一遍，重复的抵消，剩下的就是多的。
 * @考点 2：频率统计：适用于字符范围已知，通过增减计数找出多余的。
 */
char FindTheDifference(char *s, char *t) {
    // 方法 1：异或 (推荐，更简洁高效)
    char diff = 0;
    for (int i = 0; s[i] != '\0'; i++) diff ^= s[i]; // 异或 s 中的所有字符
    for (int i = 0; t[i] != '\0'; i++) diff ^= t[i]; // 异或 t 中的所有字符
    return diff; // 最终剩下的就是多出的字符

    /*
    // 方法 2：频率统计 (适用于字符范围已知，如 'a'-'z')
    int freq[26] = {0}; // 假设只包含小写英文字母
    for (int i = 0; s[i] != '\0'; i++) freq[s[i] - 'a']++;
    for (int i = 0; t[i] != '\0'; i++) {
        freq[t[i] - 'a']--; // t 中字符出现，对应频率减 1
        if (freq[t[i] - 'a'] < 0) { // 如果减到负数，说明这个字符是 t 中多出来的
            return t[i];
        }
    }
    return '\0'; // 理论上不会走到这里，除非输入不符合题意
    */
}
```

### 38. 有效的数独（三次遍历检查，O(1)）

```c
#include <stdbool.h> // For bool

/**
 * @brief 判断 9x9 数独是否有效
 * @param board：9x9 数独矩阵（char 类型，'.' 表示空）
 * @return bool：true=有效，false=无效
 * @考点 1：使用三个布尔数组（row, col, box）记录数字出现情况。
 * @考点 2：计算 3x3 宫格索引的公式：`boxIdx = (i / 3) * 3 + (j / 3)`。
 * 时间复杂度 O(1)，因为是固定 9x9 网格。
 */
bool IsValidSudoku(char board[9][9]) {
    // 定义布尔数组来记录数字出现情况
    // row[i][num]：第 i 行是否有数字 num (1-9)
    // col[j][num]：第 j 列是否有数字 num (1-9)
    // box[boxIdx][num]：第 boxIdx 个 3x3 宫格是否有数字 num (1-9)
    bool row[9][10] = {false}; // 索引 0-8 代表行，索引 1-9 代表数字
    bool col[9][10] = {false}; // 索引 0-8 代表列
    bool box[9][10] = {false}; // 索引 0-8 代表 3x3 宫格 (0:左上, 8:右下)

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') continue; // 跳过空位

            int num = board[i][j] - '0'; // 将字符数字转换为整数
            // 计算当前数字所在的 3x3 宫格的索引
            int boxIdx = (i / 3) * 3 + (j / 3); // 考点 1：计算宫格索引（0-8）

            // 检查当前数字是否在行、列、宫格中重复出现
            if (row[i][num] || col[j][num] || box[boxIdx][num]) {
                return false; // 发现重复，数独无效
            }

            // 标记数字已出现
            row[i][num] = true;
            col[j][num] = true;
            box[boxIdx][num] = true;
        }
    }
    return true; // 所有检查通过，数独有效
}
```

### 39. 重塑矩阵（行优先填充，O(mn)）

```c
#include <stdbool.h> // For bool

/**
 * @brief 将 m x n 矩阵重塑为 r x c 矩阵
 * @param nums：原 m x n 矩阵（int**）
 * @param rows：原行数 m
 * @param cols：原列数 n
 * @param r：目标行数
 * @param c：目标列数
 * @param result：输出矩阵（int**，需提前分配内存）
 * @return bool：是否重塑成功（true=成功，false=失败，返回原矩阵）
 * @考点 1：判断能否重塑：原矩阵和目标矩阵的元素总数必须相等。
 * 转换公式：一维索引 `idx` 对应目标矩阵的 `(idx / c, idx % c)`。
 */
bool MatrixReshape(int **nums, int rows, int cols, int r, int c, int **result) {
    // 考点 1：判断能否重塑（元素总数相等）
    if (rows * cols != r * c) {
        // 如果无法重塑，根据题意通常是返回原矩阵，但此处模板返回 false
        return false;
    }

    int idx = 0; // 将原矩阵元素按行优先顺序转换为一维逻辑索引

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            // 计算目标矩阵的行和列：行 = idx / 目标列数 c，列 = idx % 目标列数 c
            int resRow = idx / c;
            int resCol = idx % c;
            result[resRow][resCol] = nums[i][j];
            idx++;
        }
    }
    return true;
}
```

### 40. 删除排序数组中的重复项 II（双指针，O(n)）

```c
/**
 * @brief 在排序数组中，删除多余的重复项，允许元素最多出现两次（原地操作）
 * @param nums：排序数组
 * @param length：数组长度
 * @return int：新长度
 * @考点 1：双指针法：slow 指向有效元素末尾，fast 遍历数组。
 * 关键判断：`nums[fast] != nums[slow - 2]`，确保当前元素不会导致超过两次重复。
 */
int RemoveDuplicatesII(ElemType nums[], int length) {
    if (length <= 2) return length; // 如果长度小于等于 2，则无需删除

    // slow 指针：指向新数组的下一个有效位置，从第三个位置开始（前两个元素直接保留）
    int slow = 2;

    // fast 指针：遍历原数组
    for (int fast = 2; fast < length; fast++) {
        // 如果当前 fast 指向的元素与新数组中倒数第二个元素不同
        // (即 nums[slow - 2]，因为 slow 已经指向第 slow 个位置，前两个有效元素是 nums[slow-1]和nums[slow-2])
        // 这表示 nums[fast] 可以被保留，因为它不会导致超过两次重复
        if (nums[fast] != nums[slow - 2]) {
            nums[slow] = nums[fast]; // 将 fast 元素移动到 slow 位置
            slow++;                  // slow 指针前进
        }
    }
    return slow; // 返回新数组的长度 (即 slow 的最终值)
}
```

### 41. 加油站（贪心算法，O(n)）

```c
/**
 * @brief 判断是否能绕环形加油站一周，并返回起始站索引
 * @param gas：加油站油量数组
 * @param cost：到下一站耗油量数组
 * @param length：数组长度
 * @return int：起点索引（无法绕圈返回 -1）
 * @考点 1：总油量 >= 总耗油量 是能否绕圈的前提。
 * @考点 2：贪心策略：如果当前油箱油量 < 0，说明从当前起点到此站无法到达，则将起点重置为下一站。
 */
int CanCompleteCircuit(int gas[], int cost[], int length) {
    int totalGas = 0;      // 记录总的油量盈余/亏损
    int currentGas = 0;    // 记录从当前 `start` 站点出发，到达当前站时的油量
    int start = 0;         // 记录可能的起始加油站索引

    for (int i = 0; i < length; i++) {
        int diff = gas[i] - cost[i]; // 当前站的油量盈余或亏损
        totalGas += diff;            // 累加到总盈亏
        currentGas += diff;          // 累加到当前路径的油量

        // 如果从 `start` 到 `i`，油量变为负数，说明 `start` 不是一个有效的起点
        // 那么将 `start` 重置为 `i + 1`，并清空 `currentGas`
        if (currentGas < 0) {
            start = i + 1;
            currentGas = 0; // 重置当前路径的油量
        }
    }

    // 最终判断：如果总油量大于等于 0，则一定存在一个起点可以绕圈
    // 否则，无法绕圈
    return totalGas >= 0 ? start : -1;
}
```

### 42. 跳跃游戏（贪心算法，O(n)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 判断能否从数组第 0 个位置跳到最后一个位置
 * @param nums：跳步数组（nums[i] 表示在索引 i 处能跳跃的最大长度）
 * @param length：数组长度
 * @return bool：true=能，false=不能
 * @考点 1：贪心算法：维护当前能到达的最远距离 `maxReach`。
 * @考点 2：如果当前位置 `i` 超过了 `maxReach`，说明 `i` 无法到达，因此也无法跳到更远。
 */
bool CanJump(int nums[], int length) {
    if (length <= 1) return true; // 0 或 1 个元素的数组视为可以到达

    int maxReach = 0; // 记录当前能到达的最远索引

    for (int i = 0; i < length; i++) {
        // 如果当前位置 `i` 已经超出了 `maxReach`，说明 `i` 无法被到达
        // 因此也无法从 `i` 继续跳到终点
        if (i > maxReach) return false;

        // 更新 `maxReach`：当前位置 `i` 加上 `nums[i]` (当前能跳的最远距离)
        // maxReach = max(maxReach, i + nums[i]);
        if (i + nums[i] > maxReach) maxReach = i + nums[i];

        // 如果 `maxReach` 已经覆盖或超过了最后一个索引 (length - 1)，说明可以到达终点
        if (maxReach >= length - 1) return true;
    }
    return false; // 遍历完所有可达位置，仍未覆盖终点
}
```

### 43. 跳跃游戏 II（贪心算法，O(n)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 求跳到最后一个位置的最小跳数（假设一定能到达）
 * @param nums：跳步数组（nums[i] 表示在索引 i 处能跳跃的最大长度）
 * @param length：数组长度
 * @return int：最小跳数
 * @考点：贪心算法。每次跳跃都尽可能选择能到达最远的位置。
 * 维护 `currentEnd` (当前跳跃能到达的终点) 和 `maxReach` (下一跳能到达的最远距离)。
 */
int Jump(int nums[], int length) {
    if (length <= 1) return 0; // 0 或 1 个元素的数组跳数为 0

    int jumps = 0;        // 总跳数
    int currentEnd = 0;   // 当前跳跃能够到达的最远位置 (即“当前所在阶梯”的右边界)
    int maxReach = 0;     // 在当前 `currentEnd` 范围内，下一跳能够到达的最远距离

    // 遍历数组，直到倒数第二个元素 (最后一个元素无需跳跃)
    for (int i = 0; i < length - 1; i++) {
        // 更新 `maxReach`：在所有从 `currentEnd` 范围内可达的位置中，能跳到的最远距离
        // maxReach = max(maxReach, i + nums[i]);
        if (i + nums[i] > maxReach) maxReach = i + nums[i];

        // 如果 `i` 达到了 `currentEnd`，说明需要进行一次新的跳跃
        if (i == currentEnd) {
            jumps++;             // 跳跃次数加 1
            currentEnd = maxReach; // 更新 `currentEnd` 为本次跳跃能够到达的最远距离

            // 如果 `currentEnd` 已经覆盖或超过了最后一个索引，提前跳出
            if (currentEnd >= length - 1) break;
        }
    }
    return jumps;
}
```

### 44. 最长公共前缀（纵向扫描，O(mn)）

```c
#include <string.h> // For strlen

/**
 * @brief 找出字符串数组中的最长公共前缀
 * @param strs：字符串数组（char**）
 * @param strCount：字符串个数
 * @param result：输出公共前缀（char*，需提前分配内存，假设足够大）
 * @考点：纵向扫描，逐列比较所有字符串在相同位置的字符。
 * 时间复杂度 O(mn)，其中 m 是字符串个数，n 是最短字符串长度。
 */
void LongestCommonPrefix(char **strs, int strCount, char *result) {
    if (strCount == 0) { // 空字符串数组，公共前缀为空
        result[0] = '\0';
        return;
    }
    if (strCount == 1) { // 只有一个字符串，公共前缀就是它自己
        strcpy(result, strs[0]);
        return;
    }

    int col = 0; // 当前正在比较的列索引 (字符索引)

    while (1) {
        char c = strs[0][col]; // 以第一个字符串的当前字符为基准

        // 如果第一个字符串已经到达末尾，则停止
        if (c == '\0') break;

        // 比较其他字符串的当前列字符
        for (int i = 1; i < strCount; i++) {
            // 如果某个字符串到达末尾，或者当前字符与基准字符不匹配，则停止
            if (strs[i][col] == '\0' || strs[i][col] != c) {
                result[col] = '\0'; // 在结果字符串中添加终止符
                return;
            }
        }
        // 当前列所有字符串字符都匹配，将其添加到结果中
        result[col] = c;
        col++; // 移动到下一列
    }
    result[col] = '\0'; // 最终在结果字符串末尾添加终止符
}
```

### 45. 字符串的排列（滑动窗口 + 频率，O(n)）

```c
#include <string.h> // For strlen, memcmp
#include <stdbool.h> // For bool

/**
 * @brief 判断字符串 s2 是否包含 s1 的某个排列
 * @param s1：短字符串
 * @param s2：长字符串
 * @return bool：true=包含，false=不包含
 * @考点：滑动窗口结合频率数组。维护两个频率数组，比较它们是否相等。
 * 假设字符串只包含小写英文字母。
 */
bool CheckInclusion(char *s1, char *s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    if (len1 > len2) return false;

    int freq1[26] = {0}; // s1 中字符的频率
    int freq2[26] = {0}; // s2 中滑动窗口内字符的频率

    // 1. 初始化：统计 s1 的频率和 s2 前 len1 个字符的频率
    for (int i = 0; i < len1; i++) {
        freq1[s1[i] - 'a']++;
        freq2[s2[i] - 'a']++;
    }

    // 2. 检查初始窗口是否匹配
    if (memcmp(freq1, freq2, sizeof(freq1)) == 0) return true;

    // 3. 滑动窗口：从 len1 索引开始遍历 s2
    for (int i = len1; i < len2; i++) {
        freq2[s2[i] - 'a']++;         // 加入右边界字符
        freq2[s2[i - len1] - 'a']--; // 移除左边界字符

        // 比较两个频率数组是否相等
        if (memcmp(freq1, freq2, sizeof(freq1)) == 0) return true;
    }
    return false; // 未找到 s1 的排列
}
```

### 46. 找到字符串中所有字母异位词（滑动窗口 + 频率，O(n)）

```c
#include <string.h> // For strlen, memcmp

/**
 * @brief 找出字符串 s 中所有 p 的字母异位词的起始索引
 * @param s：长字符串
 * @param p：短字符串
 * @param result：输出索引数组（int*，需外部管理内存，假设足够大）
 * @param resLen：结果长度指针
 * @考点：滑动窗口结合频率数组。与“字符串的排列”类似，只是需要收集所有符合条件的起始索引。
 * 假设字符串只包含小写英文字母。
 */
void FindAnagrams(char *s, char *p, int *result, int *resLen) {
    *resLen = 0;
    int lenS = strlen(s);
    int lenP = strlen(p);
    if (lenP > lenS) return;

    int freqP[26] = {0}; // p 中字符的频率
    int freqS[26] = {0}; // s 中滑动窗口内字符的频率

    // 1. 初始化：统计 p 的频率和 s 前 lenP 个字符的频率
    for (int i = 0; i < lenP; i++) {
        freqP[p[i] - 'a']++;
        freqS[s[i] - 'a']++;
    }

    // 2. 检查初始窗口是否匹配
    if (memcmp(freqP, freqS, sizeof(freqP)) == 0) {
        result[(*resLen)++] = 0; // 记录第一个异位词的起始索引
    }

    // 3. 滑动窗口遍历 s
    for (int i = lenP; i < lenS; i++) {
        freqS[s[i] - 'a']++;         // 加入右边界字符
        freqS[s[i - lenP] - 'a']--; // 移除左边界字符

        // 频率匹配则记录起始索引
        if (memcmp(freqP, freqS, sizeof(freqP)) == 0) {
            result[(*resLen)++] = i - lenP + 1; // 当前窗口的起始索引
        }
    }
}
```

### 47. 动态数组的中位数（插入排序维护，O(n²)）

```c
/**
 * @brief 动态数组：支持插入元素并随时获取中位数
 * @param dynamicArr：动态数组（假设已经有序且有足够空间，int*）
 * @param len：数组当前长度指针
 * @param val：待插入元素
 * @return double：插入后的中位数
 * @考点 1：动态维护有序结构，通过插入排序保持数组有序。
 * @考点 2：根据数组长度奇偶性计算中位数。
 */
double GetMedianAfterInsert(int *dynamicArr, int *len, int val) {
    // 步骤 1：通过插入排序维护数组有序
    int i = *len - 1;
    // 找到 val 的插入位置（从后往前移动元素）
    while (i >= 0 && dynamicArr[i] > val) {
        dynamicArr[i + 1] = dynamicArr[i];
        i--;
    }
    dynamicArr[i + 1] = val; // 插入元素
    (*len)++;               // 更新长度

    // 步骤 2：计算中位数
    if (*len % 2 == 1) {
        // 奇数长度：中位数是中间元素
        return (double)dynamicArr[*len / 2];
    } else {
        // 偶数长度：中位数是中间两个元素的平均值
        return (dynamicArr[(*len / 2) - 1] + dynamicArr[*len / 2]) / 2.0;
    }
}
```

### 48. 缺失的第一个正数（原地哈希，O(n)）

```c
/**
 * @brief 找出数组中未出现的最小正整数
 * @param nums：目标数组（int*）
 * @param length：数组长度
 * @return int：最小正整数
 * @考点 1：原地哈希：将 `nums[i]` 放到索引 `nums[i]-1` 的位置。
 * 时间 O(n)，空间 O(1)，不使用额外数据结构。
 */
int FirstMissingPositive(int nums[], int length) {
    // 1. 原地哈希：将每个正整数 `x` 放到它应该在的位置 `nums[x-1]`
    for (int i = 0; i < length; i++) {
        // 循环条件：
        // 1. nums[i] 必须是正整数
        // 2. nums[i] 必须在 [1, length] 范围内 (因为要放到 length-1 的索引中)
        // 3. nums[i] 尚未放在正确位置 (即 nums[i] != nums[nums[i]-1])
        while (nums[i] > 0 && nums[i] <= length && nums[nums[i] - 1] != nums[i]) {
            // 交换 nums[i] 和 nums[nums[i]-1]
            int temp = nums[i];
            nums[i] = nums[temp - 1];
            nums[temp - 1] = temp;
        }
    }

    // 2. 遍历数组：找出第一个不满足 `nums[i] == i + 1` 的索引 `i`
    for (int i = 0; i < length; i++) {
        if (nums[i] != i + 1) {
            return i + 1; // 缺失的最小正整数就是 i+1
        }
    }

    // 3. 如果所有 [1, length] 都存在，那么缺失的最小正整数就是 length + 1
    return length + 1;
}
```

### 49. 最小路径和（动态规划，O(mn)）

```c
// 辅助函数 (如果需要)
// int min(int a, int b) { return a < b ? a : b; }

/**
 * @brief 寻找 m x n 网格从左上角到右下角的最小路径和（只能向右或向下走）
 * @param grid：m x n 网格（int**）
 * @param rows：行数
 * @param cols：列数
 * @return int：最小路径和
 * @考点 1：动态规划。状态定义：`dp[i][j]` 为到达 `(i,j)` 的最小路径和。
 * @考点 2：原地 DP 优化：直接修改原网格作为 DP 表，空间 O(1) (不计输入)。
 */
int MinPathSum(int **grid, int rows, int cols) {
    if (rows == 0 || cols == 0) return 0;

    // 1. 初始化第一行：只能从左边来
    for (int j = 1; j < cols; j++) {
        grid[0][j] += grid[0][j - 1];
    }
    // 2. 初始化第一列：只能从上面来
    for (int i = 1; i < rows; i++) {
        grid[i][0] += grid[i - 1][0];
    }

    // 3. 填充其他位置：路径和 = min(上面路径和, 左边路径和) + 当前格子值
    for (int i = 1; i < rows; i++) {
        for (int j = 1; j < cols; j++) {
            // grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);
            grid[i][j] += (grid[i - 1][j] < grid[i][j - 1]) ? grid[i - 1][j] : grid[i][j - 1];
        }
    }
    return grid[rows - 1][cols - 1]; // 右下角元素即为最小路径和
}
```

### 50. 最长递增子序列（动态规划，O(n²)）

```c
// 辅助函数 (如果需要)
// int max(int a, int b) { return a > b ? a : b; }

/**
 * @brief 寻找数组中最长递增子序列的长度（非连续，如 [10,9,2,5,3,7] → 3，对应 [2,3,7] 或 [2,5,7]）
 * @param nums：目标数组
 * @param length：数组长度
 * @return int：最长长度
 * @考点：动态规划。`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
 */
int LengthOfLIS(int nums[], int length) {
    if (length == 0) return 0;

    // `dp` 表：`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度
    int *dp = (int *)malloc(length * sizeof(int));
    if (dp == NULL) {
        fprintf(stderr, "内存分配失败\n");
        return 0;
    }

    int maxLen = 1; // 全局最长递增子序列的长度

    // 初始化：每个元素自身就是长度为 1 的递增子序列
    for (int i = 0; i < length; i++) {
        dp[i] = 1;
    }

    for (int i = 1; i < length; i++) {
        // 遍历 `i` 之前的元素 `j`
        for (int j = 0; j < i; j++) {
            // 如果 `nums[j]` 小于 `nums[i]`，说明 `nums[i]` 可以接在以 `nums[j]` 结尾的子序列后面
            if (nums[j] < nums[i]) {
                // `dp[i]` 可以更新为 `dp[j] + 1`，取当前 `dp[i]` 和 `dp[j]+1` 的较大值
                // dp[i] = max(dp[i], dp[j] + 1);
                if (dp[j] + 1 > dp[i]) dp[i] = dp[j] + 1;
            }
        }
        // 更新全局最长长度
        // maxLen = max(maxLen, dp[i]);
        if (dp[i] > maxLen) maxLen = dp[i];
    }

    free(dp); // 释放内存
    return maxLen;
}
```

---

## 四、数组与顺序表模板使用技巧

### 一、数组与顺序表的选择：适配场景是关键

数组与顺序表的本质都是连续存储空间，但因容量特性不同，适用场景有明确区分。

*   **静态数组**：以固定大小为特征，代码实现简洁，无需处理扩容逻辑。
    *   **优势**：操作直观，随机访问效率为 O(1)，插入删除的元素移动逻辑清晰。
    *   **适用场景**：题目明确指定容量，例如“给定长度为 n 的数组”、“实现一个容量为 100 的顺序表”。
    *   **局限性**：容量固定，一旦容量满则无法继续插入，可能导致“假溢出”。
*   **动态顺序表**：通过动态内存分配解决容量固定问题，核心是“按需扩容”机制。
    *   **优势**：解决容量限制，通过 `realloc` 函数实现容量调整（通常采用“翻倍策略”），兼顾空间利用率和性能。
    *   **适用场景**：容量不确定或需要频繁插入的场景，例如“实现一个支持动态增长的顺序表”、“处理未知长度的数据流”。
    *   **局限性**：需额外维护 `capacity`（当前容量）和 `length`（实际长度），代码稍复杂，且必须在销毁时释放内存，否则会造成内存泄漏。

**选择技巧**：审题时重点关注“容量是否固定”、“是否需要扩容”等关键词。若题目明确给出最大长度（如“最多存储 1000 个元素”），优先用静态数组；若题目隐含“元素数量动态变化”（如“对任意输入数组进行操作”），则必用动态顺序表。

### 二、核心考点记忆：抓住本质与细节

1.  **插入与删除的元素移动方向**
    *   **插入元素**：需将目标位置及之后的元素**“从后往前”**依次后移，避免覆盖未处理的元素。时间复杂度为 O(n)。
    *   **删除元素**：需将目标位置之后的元素**“从前往后”**依次前移，覆盖被删除元素。时间复杂度为 O(n)。
    *   **考点**：这两种操作的时间复杂度均为 O(n)，需明确“移动次数与元素位置的关系”（插入/删除越靠前，移动次数越多）。
2.  **动态扩容的翻倍策略与 `realloc` 使用**
    *   **翻倍策略**：408 推荐“容量翻倍”策略（新容量 = 原容量 × 2），能使扩容的摊还时间复杂度降至 O(1)。
    *   **`realloc` 使用**：其返回值为新内存块的地址（可能与原地址不同），必须先判断返回值是否为 `NULL`（避免扩容失败导致原数据丢失），再更新指针。
    ```c
    ElemType* newData = (ElemType*)realloc(oldData, newCapacity * sizeof(ElemType));
    if (newData != NULL) { // 扩容成功才更新
        oldData = newData;
        capacity = newCapacity;
    }
    ```
3.  **二分查找的边界条件**
    *   **循环条件**：`low <= high` 适用于“查找特定元素”；`low < high` 适用于“查找边界元素”（如第一个大于目标的值）。
    *   **`mid` 计算**：需用 `low + (high - low)/2` 替代 `(low + high)/2`，避免 `low + high` 溢出（当 `low` 和 `high` 为较大整数时）。
    *   **范围调整**：
        *   若 `arr[mid] < target`，则 `low = mid + 1`（目标在右半区，排除 `mid`）。
        *   若 `arr[mid] > target`，则 `high = mid - 1`（目标在左半区，排除 `mid`）。
4.  **双指针法的优化应用**
    双指针法通过两个指针协同遍历，将 O(n²) 时间复杂度降至 O(n)，是 408 高频考点：
    *   **快慢指针**：适用于去重（如“删除排序数组中的重复项”）、找环（如“寻找重复数”）。
    *   **左右指针**：适用于反转（如“反转数组”）、二分查找（如“两数之和 II”，如果数组有序）。
    *   **尾指针**：适用于合并有序数组（如“合并两个有序数组”）。

### 三、易错点规避：细节决定成败

1.  **数组索引的合法性检查**
    数组索引从 0 开始，操作前必须验证 `0 ≤ index < length`，否则会导致越界访问（读写非法内存）。
    *   **插入元素**：`index` 需满足 `0 ≤ index ≤ length`。
    *   **删除元素**：`index` 需满足 `0 ≤ index < length`。
    *   **访问元素**：`index` 必须在 `[0, length-1]` 范围内。
2.  **动态内存的释放与指针置空**
    动态分配的内存（`malloc`/`realloc`）必须用 `free` 释放，否则会造成内存泄漏。释放后需将指针置空（`ptr = NULL`），避免“野指针”（指向已释放内存的指针）导致的二次释放或非法访问。
    ```c
    void DynArrayDestroy(DynamicArray* da) {
        if (da->data != NULL) {
            free(da->data);
            da->data = NULL; // 置空避免野指针
        }
        da->length = 0;
        da->capacity = 0;
    }
    ```
3.  **有序性的前置确认**
    依赖数组有序性的操作（如二分查找、有序数组去重、合并区间），必须先确认数组是有序的（升序或降序），否则会导致逻辑错误。若题目未明确说明数组有序，需先通过排序（如 `qsort`）使其有序，再进行后续操作。

**总结**
数组与顺序表的掌握需兼顾“场景适配”、“核心逻辑”与“细节规避”。在 408 备考中，应通过真题练习强化对静态/动态结构选择的判断，熟练记忆插入删除的移动逻辑、二分查找的边界处理及双指针法的应用场景，同时养成索引检查、内存释放的习惯，才能在考试中高效准确地解决问题。
```
