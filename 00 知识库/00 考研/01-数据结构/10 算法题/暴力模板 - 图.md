---
tags:
---

# 暴力解法模板 - 图

## 核心思想

图的暴力解法通常涉及对图的顶点和边进行全面遍历，检查所有可能的路径、子图或组合，以找到满足特定条件的解。虽然时间复杂度较高，但在问题规模较小或作为理解问题的基础时，暴力解法能提供清晰的逻辑和易于实现的优势。

### 常用图结构定义

在下面的实例中，假设图通常以邻接矩阵 `MGraph` 的形式表示。

```c
#define MAXV 100 // 假设图的最大顶点数

// 邻接矩阵存储的图结构
typedef struct {
    int edge[MAXV][MAXV]; // 邻接矩阵，edge[i][j]=1 表示 i 到 j 有边，0 表示无边 (无权图)
    int numVertices;      // 图的实际顶点数
    int numEdges;         // 图的实际边数
} MGraph;
```

## 暴力解法通用模板 - 图

这个模板主要适用于基于邻接矩阵的图问题，通过双重循环遍历所有边，或者单重循环遍历所有顶点，并结合辅助数组进行状态记录和结果计算。

```c
#define MAXV 100 // 假设最大顶点数

int graphAlgorithm(MGraph G) {
    // 1. 数据结构初始化阶段
    // property 数组用于存储每个顶点的特定属性 (如度数、颜色、状态等)
    int property[MAXV];
    // auxiliary 数组用于存储辅助信息 (如访问标记、队列、堆栈等)
    int auxiliary[MAXV];
    int result = 0; // 算法的最终结果变量

    // 初始化数组，通常所有顶点属性或辅助标记初始化为0或默认值
    for (int i = 0; i < G.numVertices; i++) {
        property[i] = 0;
        auxiliary[i] = 0;
    }

    // 2. 邻接矩阵遍历阶段
    // 双重循环遍历所有可能的边 (i, j)
    for (int i = 0; i < G.numVertices; i++) {
        for (int j = 0; j < G.numVertices; j++) {
            if (G.edge[i][j] == 1) { // 如果 (i, j) 之间存在边
                // 根据问题类型，更新顶点 i 和/或 j 的属性
                // 例如：计算度数，统计邻居等
                // updateProperty(i, j, property);
            }
        }
    }

    // 3. 条件判断与结果计算阶段
    // 单重循环遍历所有顶点，根据其 property 属性进行判断并计算结果
    for (int i = 0; i < G.numVertices; i++) {
        // if (satisfyCondition(property[i])) {
        //     result = processResult(i, result); // 更新最终结果
        // }
    }
    return result;
}
```

---

## 模板使用实例 - 图

### 实例 1：强连通分量个数统计

**问题形式化描述**：
*   输入：有向图 `G` 的邻接矩阵表示
*   输出：返回图 `G` 中强连通分量的个数
*   约束：使用邻接矩阵存储，顶点数不超过 `MAXV`

**暴力解法思路**：
核心策略：对每个未访问过的顶点 `v`，进行两次 DFS。第一次 DFS 查找从 `v` 可达的所有顶点集 `R(v)`。第二次 DFS (在转置图上或通过特定方式) 查找所有能到达 `v` 的顶点集 `P(v)`。`v` 所在的强连通分量就是 `R(v)` 和 `P(v)` 的交集。

**注意**：下方提供的 `countStrongComponents` 是一种简化且可能不完全正确的暴力思路，它尝试对每个未访问顶点启动两次DFS，但其逻辑未能完全捕获强连通分量的精确定义。更经典的暴力解法（虽然效率不高）会去计算每对顶点 `(u, v)` 之间是否都存在双向路径。这里我们忠实于原文提供的代码结构，并添加缺失的辅助DFS函数。

```c
#include <stdio.h>
#include <stdlib.h> // For memset (optional for init)

#define MAXV 100 // 假设最大顶点数

// MGraph 结构定义 (同上)
typedef struct {
    int edge[MAXV][MAXV];
    int numVertices, numEdges;
} MGraph;

// 辅助DFS函数：从 start 顶点出发，标记所有可达的顶点
void dfsForward(MGraph G, int start, int visitedDFS[], int canReach[]) {
    visitedDFS[start] = 1;
    canReach[start] = 1;
    for (int j = 0; j < G.numVertices; j++) {
        if (G.edge[start][j] == 1 && !visitedDFS[j]) { // 如果有边且未访问
            dfsForward(G, j, visitedDFS, canReach);
        }
    }
}

// 辅助DFS函数：在转置图上 (或通过检查反向边) 从 start 顶点出发，标记所有能到达 start 的顶点
// 实际实现通常需要构造转置图，这里简化为检查反向边
void dfsBackward(MGraph G, int start, int visitedDFS[], int canBeReached[]) {
    visitedDFS[start] = 1;
    canBeReached[start] = 1;
    for (int j = 0; j < G.numVertices; j++) {
        // 检查是否存在从 j 到 start 的边
        if (G.edge[j][start] == 1 && !visitedDFS[j]) {
            dfsBackward(G, j, visitedDFS, canBeReached);
        }
    }
}


int countStrongComponents(MGraph G) {
    // 1. 数据结构初始化阶段
    int visited[MAXV];        // 标记主循环中已处理的顶点 (属于某个SCC)
    int component[MAXV];      // 连通分量标记 (每个顶点属于哪个SCC)
    int componentCount = 0;   // 强连通分量计数

    // 初始化数组
    for (int i = 0; i < G.numVertices; i++) {
        visited[i] = 0;       // 所有顶点都未被处理
        component[i] = -1;    // 尚未分配到任何连通分量
    }

    // 2. 邻接矩阵遍历阶段
    for (int start = 0; start < G.numVertices; start++) {
        if (!visited[start]) { // 如果当前顶点尚未被分配到任何强连通分量
            int canReach[MAXV] = {0};     // 标记从 start 可达的顶点
            int canBeReached[MAXV] = {0}; // 标记可达 start 的顶点

            // 为每次DFS准备独立的 visited 数组，防止干扰
            int dfsVisitedForward[MAXV] = {0};
            int dfsVisitedBackward[MAXV] = {0};

            // 检查从 start 可达的顶点
            dfsForward(G, start, dfsVisitedForward, canReach);
            // 检查可达到 start 的顶点
            dfsBackward(G, start, dfsVisitedBackward, canBeReached);

            // 3. 条件判断与结果计算阶段
            // 找出与 start 属于同一个强连通分量的顶点
            // 这些顶点必须既能从 start 到达，又能到达 start，且未被处理过
            int foundComponentMembers = 0;
            for (int i = 0; i < G.numVertices; i++) {
                if (canReach[i] && canBeReached[i] && !visited[i]) {
                    visited[i] = 1;           // 标记为已处理
                    component[i] = componentCount; // 分配当前分量ID
                    foundComponentMembers = 1;
                }
            }
            if (foundComponentMembers) { // 如果找到了至少一个顶点属于新分量
                componentCount++;
            }
        }
    }
    return componentCount;
}
```

### 实例 2：二分图判断

**问题形式化描述**：
*   输入：无向图 `G` 的邻接矩阵表示
*   输出：若 `G` 是二分图返回 1，否则返回 0
*   约束：无向连通图（或多个连通分量），使用邻接矩阵存储

**暴力解法思路**：
核心策略：使用两种颜色对顶点进行着色（例如 BFS 或 DFS）。从任意未着色顶点开始，将其染成第一种颜色，然后将其所有邻居染成第二种颜色，再将其邻居的邻居染成第一种颜色，以此类推。如果在着色过程中发现相邻顶点被染成了相同的颜色，则不是二分图。

```c
#include <stdio.h> // For NULL
#include <stdlib.h> // For queue operations (implicitly used)

#define MAXV 100 // 假设最大顶点数

// MGraph 结构定义 (同上)

int isBipartite(MGraph G) {
    // 1. 数据结构初始化阶段
    int color[MAXV];    // 顶点颜色数组 (0=未着色, 1=红色, 2=蓝色)
    int queue[MAXV];    // BFS 队列 (用于存储待访问顶点)
    int front = 0, rear = 0; // 队列头尾指针

    // 初始化数组：所有顶点未着色
    for (int i = 0; i < G.numVertices; i++) {
        color[i] = 0;
    }

    // 2. 邻接矩阵遍历阶段 (尝试对每个连通分量进行着色)
    for (int start = 0; start < G.numVertices; start++) {
        if (color[start] == 0) { // 如果当前顶点未着色，说明是新连通分量的起点
            // 开始新的连通分量着色 (使用 BFS 遍历)
            color[start] = 1;    // 染成红色
            queue[rear++] = start; // 入队

            while (front < rear) { // 队列不为空
                int current = queue[front++]; // 出队当前顶点

                // 遍历 current 的所有邻居
                for (int j = 0; j < G.numVertices; j++) {
                    if (G.edge[current][j] == 1) { // 如果 j 是 current 的邻居
                        // 3. 条件判断与结果计算阶段
                        if (color[j] == 0) { // 如果邻居 j 未着色
                            // 将 j 染成与 current 相反的颜色
                            color[j] = (color[current] == 1) ? 2 : 1;
                            queue[rear++] = j; // j 入队，待后续处理其邻居
                        } else if (color[j] == color[current]) {
                            // 如果邻居 j 已着色，且与 current 颜色相同，则不是二分图
                            return 0; // 返回 0 (false)
                        }
                        // else if (color[j] != 0 && color[j] != color[current])
                        //  邻居已着色且颜色不同，符合二分图条件，无需额外操作
                    }
                }
            }
        }
    }
    return 1; // 所有连通分量都成功着色，是二分图 (返回 1, true)
}
```

### 实例 3：图的直径计算

**问题形式化描述**：
*   输入：无向连通图 `G` 的邻接矩阵表示
*   输出：返回图 `G` 的直径（最长最短路径）
*   约束：无向连通图，使用邻接矩阵存储

**暴力解法思路**：
核心策略：计算图中所有顶点对之间的最短路径，然后从这些最短路径中找出最大的值，即为图的直径。这里使用 Floyd-Warshall 算法来计算所有顶点对之间的最短路径。

```c
#include <stdio.h>
#include <limits.h> // For INT_MAX

#define MAXV 100 // 假设最大顶点数
#define INF 0x3f3f3f3f // 定义一个很大的数表示无穷大 (避免 INT_MAX+INT_MAX 溢出)

// MGraph 结构定义 (同上)

int graphDiameter(MGraph G) {
    // 1. 数据结构初始化阶段
    int dist[MAXV][MAXV]; // 距离矩阵，dist[i][j] 存储 i 到 j 的最短路径长度
    int maxDiameter = 0;  // 图的直径，初始化为 0

    // 初始化距离矩阵
    for (int i = 0; i < G.numVertices; i++) {
        for (int j = 0; j < G.numVertices; j++) {
            if (i == j) {
                dist[i][j] = 0; // 自己到自己的距离为 0
            } else if (G.edge[i][j] == 1) {
                dist[i][j] = 1; // 有直接边，距离为 1
            } else {
                dist[i][j] = INF; // 无直接边，初始化为无穷大
            }
        }
    }

    // 2. Floyd-Warshall 算法计算所有最短路径
    // 遍历所有可能的中间顶点 k
    for (int k = 0; k < G.numVertices; k++) {
        // 遍历所有可能的起始顶点 i
        for (int i = 0; i < G.numVertices; i++) {
            // 遍历所有可能的结束顶点 j
            for (int j = 0; j < G.numVertices; j++) {
                // 如果从 i 经过 k 到 j 的路径比已知路径短，则更新
                if (dist[i][k] != INF && dist[k][j] != INF && // 确保中间路径可达
                    dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    // 3. 条件判断与结果计算阶段
    // 遍历所有顶点对的最短路径，找出最大值作为图的直径
    for (int i = 0; i < G.numVertices; i++) {
        for (int j = 0; j < G.numVertices; j++) {
            // 确保路径可达且比当前最大直径大
            if (dist[i][j] != INF && dist[i][j] > maxDiameter) {
                maxDiameter = dist[i][j];
            }
        }
    }
    return maxDiameter;
}
```

### 实例 4：关键顶点识别

**问题形式化描述**：
*   输入：无向连通图 `G` 的邻接矩阵表示
*   输出：返回关键顶点个数（删除后连通分量增加的顶点，也称割点）
*   约束：无向连通图，使用邻接矩阵存储

**暴力解法思路**：
核心策略：计算原始图的连通分量数。然后，逐个删除每个顶点，在删除该顶点后的新图中重新计算连通分量数。如果新图的连通分量数大于原始图，则该被删除的顶点是关键顶点。

```c
#include <stdio.h>
#include <stdlib.h> // For memset, potential MGraph copy

#define MAXV 100 // 假设最大顶点数

// MGraph 结构定义 (同上)

// 辅助DFS函数：用于遍历一个连通分量并标记已访问
void dfsVisit(MGraph G, int v, int visited[]) {
    visited[v] = 1; // 标记当前顶点已访问
    for (int j = 0; j < G.numVertices; j++) {
        // 如果有边 (v, j) 且 j 未被访问
        if (G.edge[v][j] == 1 && !visited[j]) {
            dfsVisit(G, j, visited);
        }
    }
}

// 辅助函数：计算图 G 的连通分量数目
int countConnectedComponents(MGraph G) {
    int visited[MAXV] = {0}; // 访问标记数组
    int components = 0;      // 连通分量计数

    for (int i = 0; i < G.numVertices; i++) {
        // 只有当顶点 i 未被访问时，才从它开始一次新的 DFS
        // 这意味着 i 属于一个新的未被探索的连通分量
        if (!visited[i]) {
            dfsVisit(G, i, visited); // 遍历从 i 开始的连通分量
            components++;            // 连通分量数加 1
        }
    }
    return components;
}


int countCriticalVertices(MGraph G) {
    // 1. 数据结构初始化阶段
    int criticalCount = 0;        // 关键顶点计数
    int originalComponents;       // 原始图的连通分量数

    // 计算原始图的连通分量数
    originalComponents = countConnectedComponents(G);

    // 2. 遍历每个顶点，模拟删除操作
    for (int vertex = 0; vertex < G.numVertices; vertex++) {
        // 创建一个临时图副本，避免修改原始图
        MGraph tempG = G;

        // "删除" 顶点 vertex：通过将其所有邻接边设为 0 来实现
        // 无论是出边还是入边都删除 (对于无向图是对称的)
        for (int i = 0; i < G.numVertices; i++) {
            tempG.edge[vertex][i] = 0; // 删除 vertex 到 i 的边
            tempG.edge[i][vertex] = 0; // 删除 i 到 vertex 的边
        }
        // 注意：在 `countConnectedComponents` 中，被"删除"的顶点不会被`dfsVisit`作为起点，
        // 也不会被其他`dfsVisit`访问，因为它所有的边都被去除了。
        // 但它仍然占据一个节点位置，如果它是孤立的，它自己算一个连通分量。
        // 关键在于考察其他未被删除的顶点形成的连通分量。

        // 3. 条件判断与结果计算阶段
        // 计算删除顶点 vertex 后的新图的连通分量数
        int newComponents = countConnectedComponents(tempG);

        // 如果连通分量数增加，则 vertex 是关键顶点 (割点)
        if (newComponents > originalComponents) {
            criticalCount++;
        }
    }
    return criticalCount;
}
```

---

## 模板使用练习 - 图

### 一、基础遍历与连通性问题

1.  给定一个无向图的邻接矩阵，判断该图是否连通。如果连通返回 1，否则返回 0。
2.  给定一个有向图的邻接矩阵，计算从指定起点出发能够到达的顶点个数。
3.  给定一个无向图的邻接矩阵，统计该图中连通分量的个数。(已在实例中提供辅助函数)
4.  给定一个有向图的邻接矩阵，判断图中是否存在环。存在环返回 1，否则返回 0。
5.  给定一个无向图的邻接矩阵，找出图中的所有桥（割边）的个数。

### 二、路径与距离问题

6.  给定一个无向图的邻接矩阵和两个顶点 u、 v，判断是否存在从 u 到 v 长度为 k 的路径。
7.  给定一个有向无环图的邻接矩阵，计算图中最长路径的长度。
8.  给定一个无向图的邻接矩阵，计算图的半径（到其他所有顶点最大距离的最小值）。
9.  给定一个有向图的邻接矩阵，统计从任意顶点出发能够回到自身的顶点个数。
10. 给定一个无向图的邻接矩阵，找出离心率最大的顶点个数（中心性分析）。

### 三、图的性质判断

11. 给定一个无向图的邻接矩阵，判断该图是否为完全图。
12. 给定一个有向图的邻接矩阵，判断该图是否为竞赛图（任意两个顶点间恰好有一条有向边）。
13. 给定一个无向图的邻接矩阵，判断该图是否为树（连通且边数等于顶点数减 1）。
14. 给定一个有向图的邻接矩阵，判断该图是否为强连通图。
15. 给定一个无向图的邻接矩阵，判断该图的色数是否小于等于 3（三着色问题）。

### 四、顶点重要性分析

16. 给定一个无向图的邻接矩阵，找出所有割点（关节点）的个数。(与实例 4 相似，但更精确地定义了割点，实例 4 是关键顶点)
17. 给定一个有向图的邻接矩阵，计算每个顶点的入度和出度，返回入度等于出度的顶点个数。
18. 给定一个无向图的邻接矩阵，找出度数最大的顶点个数。
19. 给定一个有向图的邻接矩阵，统计有多少个顶点可以到达图中所有其他顶点。
20. 给定一个无向图的邻接矩阵，计算删除度数最小的顶点后剩余图的连通分量个数。
