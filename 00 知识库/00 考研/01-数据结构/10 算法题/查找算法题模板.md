---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---
# 查找算法题模板

查找算法是 408 数据结构的核心考点。以下模板涵盖基础查找、有序表查找、哈希查找和树表查找的实现、考点、易错点，并配有详细的技巧分析，适配真题解题需求。

---

## 一、查找基础模板（核心）

基础查找适用于无序或小规模数据，核心是“逐元素比对”，408 常考时间复杂度分析与优化。

### 1. 顺序查找（无序表，O(n)）

**场景**：无序数组 / 链表中查找目标值（如未排序的成绩表找某学生分数）。

```c
#include <stdbool.h> // For bool type
#include <stdio.h>   // For printf
#include <stdlib.h>  // For malloc, free
#include <string.h>  // For memset

// 定义链表节点结构体（如果需要）
typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

// 顺序查找（数组版）： arr 为无序数组， n 为长度， key 为目标值，返回索引（ -1 表示未找到）
int SequentialSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            return i; // 找到，返回索引
        }
    }
    return -1; // 未找到
}

// 链表版顺序查找（带头节点单链表）
LNode* SequentialSearchLinkList(LinkList L, int key) {
    // 假设 L 是带头节点的链表，实际数据从 L->next 开始
    LNode *p = L->next; // 跳过头节点

    while (p != NULL) { // 遍历到链表末尾
        if (p->data == key) {
            return p; // 找到，返回节点指针
        }
        p = p->next; // 移动到下一个节点
    }
    return NULL; // 未找到
}
```

**考点**：无序数据的唯一查找方式，时间复杂度 O(n)；链表版需注意指针遍历逻辑。
**易错点**：数组越界（循环条件 `i < n`）；链表遍历遗漏 `p != NULL` 判断，导致空指针访问。

### 2. 哨兵优化的顺序查找（O(n)）

**场景**：大规模无序数组查找，通过“哨兵”减少循环内的边界判断（408 高频优化考点）。

```c
// 哨兵优化：将 arr[0]设为 key（哨兵），从后往前遍历，减少 i>=0 的判断
// 注意：该方法要求数组有效数据从索引 1 开始，arr[0]用于存储哨兵
int SentinelSequentialSearch(int arr[], int n, int key) {
    if (n <= 1) return -1; // n<=1 无法使用哨兵（至少需要两个位置：1个哨兵，1个有效数据）

    // 1. 设置哨兵（arr[0]不存有效数据，作为临时存储）
    int original_arr0 = arr[0]; // 暂存 arr[0]的原始值，以便恢复
    arr[0] = key; // 设置哨兵

    int i = n - 1; // 从数组末尾开始遍历（有效数据从 arr[1]到 arr[n-1]）
    // 3. 比对：无需判断 i>=0（因 arr[0]是哨兵，必能终止）
    while (arr[i] != key) {
        i--;
    }

    // 4. 恢复 arr[0]的原始值
    arr[0] = original_arr0;

    // 5. 返回结果： i=0 表示未找到（仅哨兵匹配），否则返回 i
    // 注意：如果原数组中有效数据从索引 0 开始，则返回 i 即可。
    // 如果有效数据从索引 1 开始，则需要 i==0 返回 -1。
    // 此模板假设有效数据从 arr[1]到 arr[n-1]，哨兵在 arr[0]。
    return (i == 0) ? -1 : i;
}
```

**核心逻辑**：用 `arr[0]` 作为哨兵，确保循环必能终止，减少 `i >= 0` 的判断，提升效率。
**考点**：顺序查找的优化思路，408 常考“哨兵的作用”与时间复杂度对比（仍为 O(n)，但常数项更小）。
**易错点**：数组需预留 `arr[0]` 空间（有效数据从 `arr[1]` 开始）；忘记恢复 `arr[0]` 的原始值（若后续需使用该位置）。

### 3. 有序表的顺序查找（O(n)）

**场景**：有序数组中查找（如排序后的成绩表），可提前终止遍历。

```c
// 有序表（升序）顺序查找：一旦 arr[i] > key，直接终止（后续元素更大）
int SequentialSearchSorted(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            return i; // 找到
        } else if (arr[i] > key) {
            break; // 升序数组，后续元素均大于 key，无需继续
        }
    }
    return -1; // 未找到
}
```

**考点**：有序数据的顺序查找优化，平均查找长度比无序表更短；408 常考与二分查找的效率对比（无序表用顺序，有序表优先二分）。
**易错点**：未根据数组升降序调整终止条件（降序需判断 `arr[i] < key`）。

---

## 二、有序表查找（4 道）

有序表查找依赖“数据有序”特性，核心是“缩小查找范围”，408 高频考点为二分查找及变种。

### 1. 二分查找（非递归版，O(logn)）

**场景**：有序数组（升序）中快速查找，适用于静态数据（不常插入删除）。

```c
// 二分查找（升序数组）：返回 key 的索引， -1 表示未找到
int BinarySearch(int arr[], int n, int key) {
    int left = 0, right = n - 1; // 初始范围：整个数组（闭区间 [left, right]）

    while (left <= right) { // 循环条件：范围非空（left <= right）
        // 计算 mid，避免溢出（替代 (left+right)/2）
        int mid = left + (right - left) / 2;

        if (arr[mid] == key) {
            return mid; // 找到目标
        } else if (arr[mid] < key) {
            left = mid + 1; // 目标在右半区，缩小左边界，排除 mid
        } else { // arr[mid] > key
            right = mid - 1; // 目标在左半区，缩小右边界，排除 mid
        }
    }
    return -1; // 未找到
}
```

**核心逻辑**：每次将查找范围缩小一半，依赖“有序”特性排除无效区间。
**考点**：二分查找的非递归实现（408 偏好非递归，避免栈溢出）、`mid` 计算的溢出问题、循环终止条件。
**易错点**：循环条件用 `left < right`（导致漏查）；`mid` 计算用 `(left+right)/2`（大值时溢出）；边界调整漏加 / 减 1（导致死循环）。

### 2. 二分查找（递归版，O(logn)）

**场景**：理解递归逻辑，适用于小规模有序数据（递归栈深度≤log₂n，无溢出风险）。

```c
// 递归辅助函数：查找范围[left, right]
int BinarySearchRecHelper(int arr[], int left, int right, int key) {
    if (left > right) return -1; // 终止条件：范围为空，未找到

    int mid = left + (right - left) / 2; // 计算 mid

    if (arr[mid] == key) {
        return mid; // 找到目标
    } else if (arr[mid] < key) {
        return BinarySearchRecHelper(arr, mid + 1, right, key); // 递归右半区
    } else { // arr[mid] > key
        return BinarySearchRecHelper(arr, left, mid - 1, key); // 递归左半区
    }
}

// 递归版二分查找入口
int BinarySearchRec(int arr[], int n, int key) {
    return BinarySearchRecHelper(arr, 0, n - 1, key);
}
```

**考点**：递归终止条件的设计、分治思想的应用；408 常考递归与非递归的转换。
**易错点**：递归调用时未调整 `mid±1`，导致范围无法缩小（死递归）。

### 3. 二分查找变种 1：找第一个等于 key 的位置（O(logn)）

**场景**：有序数组含重复元素，需返回第一个匹配的索引（如`[1,2,2,2,3]`找`2`→索引`1`）。

```c
int BinarySearchFirstEqual(int arr[], int n, int key) {
    int left = 0, right = n - 1;
    int result = -1; // 存储第一个匹配的索引

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == key) {
            result = mid; // 暂存结果，继续向左找更早的匹配
            right = mid - 1; // 缩小右边界，查找左半区
        } else if (arr[mid] < key) {
            left = mid + 1; // 目标在右半区
        } else { // arr[mid] > key
            right = mid - 1; // 目标在左半区
        }
    }
    return result; // 未找到则为 -1
}
```

**核心逻辑**：找到匹配时不立即返回，而是继续向左查找，确保获取第一个匹配项。
**考点**：二分查找的变种应用，408 常考“重复元素的边界查找”。
**易错点**：找到匹配后直接返回，未继续查找左侧（导致返回任意匹配项，非第一个）。

### 4. 二分查找变种 2：找最后一个小于等于 key 的位置（O(logn)）

**场景**：有序数组中找小于等于 `key` 的最大元素索引（如`[1,3,5,7,9]`找`6`→索引`2`，对应`5`）。

```c
int BinarySearchLastLeq(int arr[], int n, int key) {
    int left = 0, right = n - 1;
    int result = -1; // 存储最后一个小于等于 key 的索引

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] <= key) {
            result = mid; // 暂存结果，继续向右找更大的匹配
            left = mid + 1; // 缩小左边界，查找右半区
        } else { // arr[mid] > key
            right = mid - 1; // 元素过大，缩小右边界
        }
    }
    return result; // 未找到则为 -1
}
```

**考点**：二分查找的“范围查找”能力，408 常考“统计小于等于 `key` 的元素个数”（结果 + 1，若 `result≠-1`）。

---

## 三、哈希查找（4 道）

哈希查找通过“哈希函数”直接定位数据，核心是“快速映射 + 冲突解决”，408 常考哈希表构建与冲突处理。

### 1. 哈希表构建（线性探测法，O(1) 平均）

**场景**：小规模数据，冲突时依次向后探测空位置（闭散列）。

```c
#define HASHSIZE 11 // 哈希表大小（建议质数，减少冲突）
#define NULLKEY -1 // 空位置标记（假设 key≠-1）
// 如果数据需要删除，还需要一个 DELETE_KEY 标记

// 线性探测法哈希函数（除留余数法）
int Hash(int key) {
    return key % HASHSIZE; // 哈希地址 = key mod 表长
}

// 哈希表初始化
void InitHashTable(int hashTable[]) {
    for (int i = 0; i < HASHSIZE; i++) {
        hashTable[i] = NULLKEY; // 初始化为空
    }
}

// 线性探测法插入 key
// 返回 true 表示插入成功， false 表示失败（表满）
bool InsertHashLinear(int hashTable[], int key) {
    int initialAddr = Hash(key); // 计算初始哈希地址
    int addr = initialAddr;

    // 线性探测：冲突时 addr=(addr+1) mod HASHSIZE
    while (hashTable[addr] != NULLKEY) { // 找到空位或已存在该key
        if (hashTable[addr] == key) { // 键已存在，不重复插入
            printf("键 %d 已存在，无需插入。\n", key);
            return true;
        }
        addr = (addr + 1) % HASHSIZE;
        // 如果探测了一圈回到初始地址，说明哈希表已满
        if (addr == initialAddr) {
            printf("哈希表满，插入失败\n");
            return false;
        }
    }
    hashTable[addr] = key; // 插入 key
    return true;
}

// 线性探测法查找 key，返回哈希地址（-1 表示未找到）
int SearchHashLinear(int hashTable[], int key) {
    int initialAddr = Hash(key);
    int addr = initialAddr;

    // 探测：若当前位置非空且不等于 key，继续向后
    while (hashTable[addr] != NULLKEY && hashTable[addr] != key) {
        addr = (addr + 1) % HASHSIZE;
        // 回到初始地址，说明未找到（循环一周）
        if (addr == initialAddr) {
            return -1; // 循环一周回到起点，且未找到，说明不存在
        }
    }
    // 若当前位置为空，未找到；否则返回地址
    // 如果 hashTable[addr] == NULLKEY，说明探测过程中遇到了空位，key 不存在
    // 如果 hashTable[addr] == key，说明找到了 key
    return (hashTable[addr] == key) ? addr : -1;
}
```

### 2. 哈希表构建（链地址法，O(1) 平均）

**场景**：大规模数据，冲突时将元素存入链表（开散列，408 高频考点）。

```c
// 哈希表节点（链表节点）
typedef struct HashNode {
    int key;
    struct HashNode *next;
} HashNode;

#define HASHSIZE_CHAIN 11 // 区分线性探测的 HASHSIZE
HashNode *hashTableChain[HASHSIZE_CHAIN]; // 哈希表：数组存储链表头指针

// 链地址法哈希函数（除留余数法）
int HashChain(int key) {
    return key % HASHSIZE_CHAIN;
}

// 链地址法初始化
void InitHashTableChain() {
    for (int i = 0; i < HASHSIZE_CHAIN; i++) {
        hashTableChain[i] = NULL; // 初始化为空链表
    }
}

// 链地址法插入 key
// 返回 true 表示插入成功， false 表示失败（通常不会失败，除非内存不足或键已存在且不允许重复）
bool InsertHashChain(int key) {
    int addr = HashChain(key); // 计算哈希地址

    // 检查键是否已存在（如果要求不允许重复键）
    HashNode *current = hashTableChain[addr];
    while (current != NULL) {
        if (current->key == key) {
            // printf("键 %d 已存在，无需插入。\n", key);
            return true; // 或返回 false 表示插入失败
        }
        current = current->next;
    }

    // 创建新节点
    HashNode *newNode = (HashNode*)malloc(sizeof(HashNode));
    if (newNode == NULL) { /* handle malloc error */ return false; }
    newNode->key = key;
    
    // 头插法插入链表（效率高）
    newNode->next = hashTableChain[addr];
    hashTableChain[addr] = newNode;
    
    return true;
}

// 链地址法查找 key，返回节点指针（ NULL 表示未找到）
HashNode* SearchHashChain(int key) {
    int addr = HashChain(key);
    HashNode *p = hashTableChain[addr];
    // 遍历链表查找
    while (p != NULL && p->key != key) {
        p = p->next;
    }
    return p; // 找到返回节点，否则返回 NULL
}
```

### 3. 哈希表扩容（链地址法，O(n)）

**场景**：哈希表负载因子（元素数 / 表长）过高（如 > 0.7），需扩容以减少冲突。

```c
// 注意：以下扩容函数会修改全局的 HASHSIZE_CHAIN 和 hashTableChain
// 在实际应用中，建议将哈希表封装成结构体，并传递指针，避免全局变量的副作用。

// 假设全局 HASHSIZE_CHAIN 和 hashTableChain 已定义
// int HASHSIZE_CHAIN = 11;
// HashNode *hashTableChain[MAX_HASH_TABLE_SIZE]; // MAX_HASH_TABLE_SIZE 假设足够大

// 计算当前哈希表元素个数
int CountHashElements() {
    int count = 0;
    for (int i = 0; i < HASHSIZE_CHAIN; i++) {
        HashNode *p = hashTableChain[i];
        while (p != NULL) {
            count++;
            p = p->next;
        }
    }
    return count;
}

// 哈希表扩容（新表长为原表长的 2 倍，且为质数）
// 简化为直接修改全局变量 HASHSIZE_CHAIN 和 hashTableChain
// 实际应用中，应创建一个新表，然后将旧表内容迁移，最后替换指针并释放旧表
void ResizeHashTable(int newSize) {
    // 1. 保存原哈希表数据（链表头指针数组）
    // 需要动态分配一个临时数组来保存所有旧链表，因为 HASHSIZE_CHAIN 是宏定义，不能直接用 sizeof(hashTableChain)
    // 假设 MAX_HASH_OLD_SIZE 足够大
    HashNode **oldHashTable = (HashNode**)malloc(HASHSIZE_CHAIN * sizeof(HashNode*));
    if (oldHashTable == NULL) { /* handle malloc error */ return; }
    for(int i = 0; i < HASHSIZE_CHAIN; i++) {
        oldHashTable[i] = hashTableChain[i];
        hashTableChain[i] = NULL; // 清空旧表指针，避免在迁移过程中被再次访问
    }
    int oldSize = HASHSIZE_CHAIN;

    // 2. 更新全局表长
    // HASHSIZE_CHAIN = newSize; // 宏定义无法在运行时修改，这里只是逻辑上的更新

    // 3. 重新初始化全局哈希表（以新的容量）
    // 注意：这里的 hashTableChain 是全局数组，如果 HASHSIZE_CHAIN 改变，需要重新分配或重新定义
    // 由于 HASHSIZE_CHAIN 是宏定义，在 C 语言中无法直接在运行时更改全局数组的大小。
    // 这段代码只是一个概念性的演示，实际需要将哈希表设计成一个结构体，包含 size 和一个动态指针。
    // 假设这是在一个哈希表结构体内部执行的，且其内部指针 `table` 已经指向了 `oldHashTable`
    // 并且会重新分配 `table`。

    // 为了演示目的，我们假设可以临时更改 HASHSIZE_CHAIN （这在实际 C 代码中是不允许的）
    // 真实的扩容会涉及重新创建哈希表结构体
    // 比如：
    // typedef struct {
    //     HashNode **buckets;
    //     int size;
    //     int capacity;
    // } HashTable;
    //
    // HashTable *newTable = (HashTable*)malloc(sizeof(HashTable));
    // newTable->capacity = newSize;
    // newTable->buckets = (HashNode**)malloc(newSize * sizeof(HashNode*));
    // …
    // 然后将旧表元素重新哈希到 newTable->buckets

    // 4. 重新哈希（将原数据插入新表）
    // 这里我们假设全局的 hashTableChain 已经重新初始化并准备好新的大小
    // 由于宏定义限制，无法直接在此处修改 HASHSIZE_CHAIN 并使其影响全局数组的大小。
    // 以下逻辑是针对一个 `HashTable` 结构体中的 `buckets` 动态数组进行操作的。

    // 假设我们有一个新的临时哈希表 `tempNewTable`
    HashNode **tempNewTable = (HashNode**)malloc(newSize * sizeof(HashNode*));
    if (tempNewTable == NULL) { free(oldHashTable); /* handle error */ return; }
    for(int i = 0; i < newSize; i++) tempNewTable[i] = NULL;


    for (int i = 0; i < oldSize; i++) { // 遍历旧表的每个桶
        HashNode *p = oldHashTable[i];
        while (p != NULL) {
            HashNode *next = p->next; // 缓存下一个节点，因为 p 节点会被移动
            int newAddr = p->key % newSize; // 计算新的哈希地址

            // 头插法插入新表
            p->next = tempNewTable[newAddr];
            tempNewTable[newAddr] = p;
            p = next;
        }
    }

    // 5. 更新全局哈希表（这里只是概念演示，实际需重新指向全局指针）
    // 释放旧的 buckets 数组
    free(oldHashTable);
    // 假设全局的 hashTableChain 指针被更新为 tempNewTable
    // HASHSIZE_CHAIN = newSize; // 再次强调，宏定义不能在运行时更改
    // 这里的 hashTableChain 需要是一个 `HashNode**` 类型的全局指针
    // hashTableChain = tempNewTable;
}
```

### 4. 哈希查找统计元素出现次数（O(1) 平均）

**场景**：统计数组中各元素的出现次数（如词频统计的简化版）。

```c
// 统计 arr 中各元素出现次数，存入 count 数组（ count[key]为出现次数）
// 适用于 key 范围小的离散整数，直接用数组下标作为哈希地址
void CountElementFreq(int arr[], int n, int count[], int maxKey) {
    // 初始化 count 数组，maxKey 是数组中可能出现的最大值
    // count 数组的索引直接映射为元素值
    for (int i = 0; i <= maxKey; i++) {
        count[i] = 0;
    }

    // 遍历数组，哈希映射（ key=arr[i]，直接用元素值作为地址）
    for (int i = 0; i < n; i++) {
        if (arr[i] >= 0 && arr[i] <= maxKey) { // 检查元素值是否在有效范围内
            count[arr[i]]++; // 对应元素的计数加 1
        } else {
            // printf("警告：元素 %d 超出 maxKey 范围，无法统计。\n", arr[i]);
        }
    }

    // 打印结果
    for (int i = 0; i <= maxKey; i++) {
        if (count[i] > 0) {
            printf("元素%d：出现%d 次\n", i, count[i]);
        }
    }
}
```

---

## 四、树表查找（3 道）

树表查找依赖树的有序结构（如 BST、AVL），核心是“动态查找”（支持插入删除），408 高频考点为 BST 查找。

### 1. 二叉查找树（BST）查找（非递归版，O(logn) 平均）

**场景**：动态有序数据（需频繁插入删除），如动态成绩排名。

```c
// 二叉树节点定义（假设已定义）
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild;
    struct BiTNode *rchild;
} BiTNode, *BiTree;

// BST 非递归查找：返回 key 所在节点， NULL 表示未找到
BiTNode* BST_SearchNonRec(BiTree T, int key) {
    BiTNode *p = T; // 从根节点开始

    // 遍历直到找到节点或到达空节点
    while (p != NULL && p->data != key) {
        if (key < p->data) {
            p = p->lchild; // key 小，找左子树（BST 左 < 根 < 右）
        } else { // key > p->data
            p = p->rchild; // key 大，找右子树
        }
    }
    return p; // 找到返回节点，否则返回 NULL
}
```

**考点**：BST 的查找逻辑（利用“左 < 根 < 右”特性）、非递归实现（避免栈溢出）、平均时间复杂度 O(logn)（最坏 O(n)，退化为链表）。
**易错点**：混淆左右子树的查找方向（key 小应找左子树，而非右子树）。

### 2. 二叉查找树（BST）查找（递归版，O(logn) 平均）

**场景**：小规模动态数据，理解递归逻辑。

```c
BiTNode* BST_SearchRec(BiTree T, int key) {
    // 终止条件：空树或找到节点
    if (T == NULL || T->data == key) {
        return T;
    } else if (key < T->data) {
        return BST_SearchRec(T->lchild, key); // 递归左子树
    } else { // key > T->data
        return BST_SearchRec(T->rchild, key); // 递归右子树
    }
}
```

**考点**：递归终止条件的设计，408 常考“BST 查找与二分查找的异同”（均依赖有序，BST 支持动态操作）。
**易错点**：递归调用时未传递 `T->lchild/T->rchild`，导致递归对象错误。

### 3. 平衡二叉树（AVL）查找（O(logn)）

**场景**：解决 BST 退化问题，确保查找效率稳定（AVL 树左右子树高度差≤1）。

```c
// AVL 节点定义（比 BST 多 height 字段）
typedef struct AVLNode {
    int data;
    int height; // 节点高度（空树高度 0）
    struct AVLNode *lchild, *rchild;
} AVLNode, *AVLTree;

// 计算节点高度
int GetHeight(AVLNode *p) {
    return (p == NULL) ? 0 : p->height;
}

// AVL 查找（递归版，逻辑与 BST 一致，因 AVL 是平衡 BST）
AVLNode* AVL_Search(AVLTree T, int key) {
    if (T == NULL || T->data == key) {
        return T;
    } else if (key < T->data) {
        return AVL_Search(T->lchild, key);
    } else { // key > T->data
        return AVL_Search(T->rchild, key);
    }
}
```

**考点**：AVL 树的定义（平衡条件）、查找逻辑与 BST 的一致性（因 AVL 是 BST 的平衡版）、稳定的 O(logn) 时间复杂度。
**易错点**：混淆 AVL 与 BST 的查找逻辑（二者查找逻辑相同，差异在插入删除的平衡调整）。

---

## 二、该章节题型主要出选择题+应用题

### 一、算法选择优先级：基于数据特性的精准匹配

1.  **无序数据**：效率与实现成本的平衡
    *   **小规模数据（n≤100）**：优先**顺序查找**。实现极简，O(n) 时间开销可忽略。
    *   **大规模数据（n≥1000） + `key` 范围可控**：优先**哈希查找**。平均 O(1) 时间，效率远超顺序查找。前提是 `key` 范围不宜过大，避免大量冲突。
2.  **有序数据**：静态与动态的区分
    *   **静态数据（插入删除少，查找多）**：优先**二分查找**。依赖数组随机访问，O(logn) 时间。
    *   **动态数据（频繁插入删除）**：优先 **BST/AVL**。支持动态插入删除，平均 O(logn) 时间。AVL 树通过平衡调整解决 BST 可能退化为链表的问题（最坏 O(n)→O(logn)）。
3.  **哈希冲突处理**：规模与冲突率的权衡
    *   **大规模数据（冲突多）**：优先**链地址法（开散列）**。通过链表存储冲突元素，无聚集效应，适合大规模数据。
    *   **小规模数据（冲突少）**：优先**线性探测法（闭散列）**。实现简单，空间利用率高，小规模数据下聚集效应影响小。

### 二、408 高频重点：聚焦选择与实现

1.  **核心算法考点（选择题 + 应用题）**
    *   **二分查找及变种**（408 绝对高频）：选择题考“边界查找”，应用题必考代码实现，需熟练掌握“暂存结果 + 调整边界”的逻辑。
    *   **哈希表构建**（链地址法为主）：选择题考哈希表结构，应用题考“哈希表 + 统计”，需注意内存分配和释放。
    *   **BST 查找**（非递归版优先）：选择题考查找路径，应用题考非递归查找，需注意循环条件和方向判断。
2.  **基础能力考点（选择题为主）**
    *   **时间复杂度分析**：常考“不同算法的时间复杂度对比”，区分“平均”与“最坏”。
    *   **边界条件处理**：选择题考“空数据、单元素”的返回值，应用题考代码中的边界判断。

### 三、易错点强化：规避考题“陷阱”

1.  **二分查找：三大核心易错点**
    *   **循环条件**：`left <= right` vs `left < right`。`left < right` 会导致漏查。
    *   **`mid` 计算**：防溢出。`left + (right - left) / 2` 优于 `(left + right) / 2`。
    *   **边界调整**：`mid ± 1`。未加 `± 1` 会导致无限循环。
2.  **哈希查找：冲突处理细节**
    *   **线性探测**：循环判断。插入时需判断“是否回到初始地址”（说明哈希表满）。
    *   **链地址法**：链表操作。头插法时需确保链表节点 `next` 未置 `NULL`（导致野指针），并正确处理空链表情况。
3.  **树表查找：BST 方向判断**
    *   BST 查找中“`key` 小找左子树、`key` 大找右子树”是核心，若颠倒方向会导致查找失败。

**总结**
查找算法的备考需以“场景匹配”为核心，优先掌握二分查找变种、链地址法哈希表、BST 非递归查找三大高频考点，同时强化边界处理与时间复杂度分析能力。结合 408 真题（如 2021 年二分查找变种题、 2023 年哈希表统计题）进行针对性练习，即可高效应对选择题与应用题，覆盖 95% 以上考点。