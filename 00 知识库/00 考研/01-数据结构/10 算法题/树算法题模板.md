---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 树算法题模板

树是 408 数据结构的核心考点，以下模板覆盖二叉树基础操作、BST 特性应用、堆（优先队列）实现及大量高频考题场景。每个模板均标注核心考点和易错点，适合直接背诵应用。

---

## 一、二叉树基础模板（核心）

二叉树是树结构的基础，所有操作围绕 “节点定义、构建、遍历” 展开。408 真题 90% 以上树相关题基于二叉树。

### 1. 二叉树节点定义（必背）

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h> // 用于字符串操作，如 strcmp
#include <limits.h> // 用于 INT_MIN, INT_MAX, abs
#include <math.h>   // 用于 pow, log2

// 二叉树节点结构体（408 默认 int 数据域，可替换为结构体）
typedef struct BiTNode {
    int data; // 数据域
    struct BiTNode *lchild; // 左孩子指针
    struct BiTNode *rchild; // 右孩子指针
} BiTNode, *BiTree;
```

**考点**：节点定义是所有树操作的前提，若数据域为复杂结构（如学生信息），需修改 `data` 类型并自定义比较函数（如 `strcmp`）。

### 2. 二叉树构建（高频场景）

#### （1）根据层序序列构建（队列实现， O (n)）

**场景**：输入层序序列（含 `NULL` 标记，如 `[1,2,3,NULL,NULL,5]`），构建二叉树。

```c
// 层序构建二叉树（用队列暂存待处理节点）
BiTree CreateBiTreeByLevel(int *levelSeq, int len, int nullFlag) {
    if (len == 0 || levelSeq[0] == nullFlag) return NULL;

    // 1. 初始化根节点
    BiTree root = (BiTNode*)malloc(sizeof(BiTNode));
    root->data = levelSeq[0];
    root->lchild = root->rchild = NULL;

    // 2. 队列暂存节点（用数组模拟队列，简化代码）
    BiTNode *queue[1000]; // 假设最大节点数 1000
    int front = 0, rear = 0;
    queue[rear++] = root;

    // 3. 遍历层序序列，填充左右孩子
    int idx = 1; // 从第二个元素开始（根已处理）
    while (front < rear && idx < len) {
        BiTNode *cur = queue[front++]; // 取出队头节点

        // 处理左孩子
        if (levelSeq[idx] != nullFlag) {
            cur->lchild = (BiTNode*)malloc(sizeof(BiTNode));
            cur->lchild->data = levelSeq[idx];
            cur->lchild->lchild = cur->lchild->rchild = NULL;
            queue[rear++] = cur->lchild;
        }
        idx++;

        // 处理右孩子（需判断是否越界）
        if (idx >= len) break;
        if (levelSeq[idx] != nullFlag) {
            cur->rchild = (BiTNode*)malloc(sizeof(BiTNode));
            cur->rchild->data = levelSeq[idx];
            cur->rchild->lchild = cur->rchild->rchild = NULL;
            queue[rear++] = cur->rchild;
        }
        idx++;
    }
    return root;
}
```

**考点**：层序构建依赖队列（BFS 思想），需处理 “`NULL` 标记” 和 “序列越界”，408 常考 “根据输入构建树” 的前置步骤。

#### （2）根据前序 + 中序序列构建（递归， O (n²)）【 中后也可确定前】

**场景**：已知前序（根左右）和中序（左根右）序列，唯一确定二叉树（无重复元素）。

```c
// 辅助函数：在中序序列中找根节点索引
int FindRootInInorder(int *inorder, int inLen, int rootVal) {
    for (int i = 0; i < inLen; i++) {
        if (inorder[i] == rootVal) return i;
    }
    return -1; // 理论上不会触发（输入合法）
}

// 前序+中序构建二叉树
BiTree CreateBiTreeByPreIn(int *preorder, int preLen,
                           int *inorder, int inLen) {
    if (preLen == 0 || inLen == 0) return NULL;

    // 1. 前序序列第一个元素为根节点
    int rootVal = preorder[0];
    BiTree root = (BiTNode*)malloc(sizeof(BiTNode));
    root->data = rootVal;
    root->lchild = root->rchild = NULL;

    // 2. 在中序序列中找根节点，分割左右子树
    int rootIdx = FindRootInInorder(inorder, inLen, rootVal);

    // 左子树长度： rootIdx，右子树长度： inLen - rootIdx - 1
    int leftLen = rootIdx;
    int rightLen = inLen - rootIdx - 1;

    // 3. 递归构建左右子树
    // 左子树：前序[1..leftLen]，中序[0..rootIdx-1]
    root->lchild = CreateBiTreeByPreIn(preorder + 1, leftLen,
                                       inorder, leftLen);
    // 右子树：前序[1+leftLen..preLen-1]，中序[rootIdx+1..inLen-1]
    root->rchild = CreateBiTreeByPreIn(preorder + 1 + leftLen, rightLen,
                                       inorder + rootIdx + 1, rightLen);
    return root;
}
```

**考点**：利用 “前序定根、中序分左右” 的特性，递归构建子树；若有重复元素，需额外信息（如父节点），408 常考此构建逻辑。

### 3. 二叉树遍历（ 408 必考，递归 + 非递归）

遍历是树操作的基础，递归遍历简单但可能栈溢出，非递归遍历（栈 / 队列）是考点重点。

#### （1）递归遍历（前、中、后序， O (n)）

```c
// 前序遍历（根→左→右）
void PreOrderTraverse(BiTree T) {
    if (T == NULL) return;
    printf("%d ", T->data); // 访问根
    PreOrderTraverse(T->lchild); // 遍历左子树
    PreOrderTraverse(T->rchild); // 遍历右子树
}

// 中序遍历（左→根→右）
void InOrderTraverse(BiTree T) {
    if (T == NULL) return;
    InOrderTraverse(T->lchild); // 遍历左子树
    printf("%d ", T->data); // 访问根
    InOrderTraverse(T->rchild); // 遍历右子树
}

// 后序遍历（左→右→根）
void PostOrderTraverse(BiTree T) {
    if (T == NULL) return;
    PostOrderTraverse(T->lchild); // 遍历左子树
    PostOrderTraverse(T->rchild); // 遍历右子树
    printf("%d ", T->data); // 访问根
}
```

**考点**：递归遍历的终止条件（`T==NULL`），访问根的时机决定遍历类型；中序遍历是 BST 的核心特性（有序）。

#### （2）非递归遍历（栈实现， O (n)）

##### ① 前序遍历（根→左→右，栈入栈 “根右左”）

```c
void PreOrderTraverseNonRec(BiTree T) {
    if (T == NULL) return;
    BiTNode *stack[1000];
    int top = -1;
    stack[++top] = T; // 根节点入栈
    while (top != -1) {
        BiTNode *cur = stack[top--]; // 出栈根节点
        printf("%d ", cur->data); // 访问根
        // 右孩子先入栈（栈先进后出，确保左孩子先处理）
        if (cur->rchild != NULL) stack[++top] = cur->rchild;
        if (cur->lchild != NULL) stack[++top] = cur->lchild;
    }
}
```

**易错点**：右孩子先入栈，左孩子后入栈，保证出栈顺序为 “根→左→右”。

##### ② 中序遍历（左→根→右， “左到底再出栈”）

```c
void InOrderTraverseNonRec(BiTree T) {
    if (T == NULL) return;
    BiTNode *stack[1000];
    int top = -1;
    BiTNode *cur = T;
    while (cur != NULL || top != -1) {
        // 左子树全入栈
        while (cur != NULL) {
            stack[++top] = cur;
            cur = cur->lchild;
        }
        // 出栈访问根
        cur = stack[top--];
        printf("%d ", cur->data);
        // 处理右子树
        cur = cur->rchild;
    }
}
```

**考点**：中序非递归的核心是 “先遍历左子树，再访问根，最后右子树”，需用 `cur` 指针追踪左子树。

##### ③ 后序遍历（左→右→根，双栈法）

```c
void PostOrderTraverseNonRec(BiTree T) {
    if (T == NULL) return;
    BiTNode *stack1[1000], *stack2[1000]; // 栈 1 处理节点，栈 2 存结果
    int top1 = -1, top2 = -1;
    stack1[++top1] = T;
    while (top1 != -1) {
        BiTNode *cur = stack1[top1--];
        stack2[++top2] = cur; // 栈 2 存“根右左”
        // 左孩子先入栈 1（确保栈 2 最终为“左右根”）
        if (cur->lchild != NULL) stack1[++top1] = cur->lchild;
        if (cur->rchild != NULL) stack1[++top1] = cur->rchild;
    }
    // 栈 2 出栈即后序
    while (top2 != -1) {
        printf("%d ", stack2[top2--]->data);
    }
}
```

**考点**：双栈法通过 “栈 1 入栈左→右，栈 2 存根→右→左”，出栈时得到后序顺序，是 408 后序非递归的主流考法。

#### （3）层序遍历（队列实现 BFS， O (n)）

```c
void LevelOrderTraverse(BiTree T) {
    if (T == NULL) return;
    BiTNode *queue[1000];
    int front = 0, rear = 0;
    queue[rear++] = T; // 根节点入队
    while (front < rear) {
        BiTNode *cur = queue[front++]; // 出队
        printf("%d ", cur->data); // 访问
        // 左右孩子入队（先左后右，保证层序）
        if (cur->lchild != NULL) queue[rear++] = cur->lchild;
        if (cur->rchild != NULL) queue[rear++] = cur->rchild;
    }
}
```

**考点**：层序遍历依赖队列，是 “二叉树高度、宽度、层平均值” 等问题的基础，408 常考 “分层打印”（需记录每层节点数）。

---

## 二、高频应用场景模板（ 树+BST+堆）

### 树高频应用场景模板

#### 1. 求二叉树高度（递归 + 非递归， O (n)）

```c
// 递归法：树高=max(左子树高, 右子树高)+1
int GetBiTreeHeightRec(BiTree T) {
    if (T == NULL) return 0; // 空树高度 0
    int leftH = GetBiTreeHeightRec(T->lchild);
    int rightH = GetBiTreeHeightRec(T->rchild);
    return (leftH > rightH ? leftH : rightH) + 1;
}

// 非递归法（层序遍历，记录层数）
int GetBiTreeHeightNonRec(BiTree T) {
    if (T == NULL) return 0;
    BiTNode *queue[1000];
    int front = 0, rear = 0;
    queue[rear++] = T;
    int height = 0;
    while (front < rear) {
        int levelSize = rear - front; // 当前层节点数
        height++; // 每遍历一层，高度+1
        // 遍历当前层所有节点，孩子入队
        for (int i = 0; i < levelSize; i++) {
            BiTNode *cur = queue[front++];
            if (cur->lchild != NULL) queue[rear++] = cur->lchild;
            if (cur->rchild != NULL) queue[rear++] = cur->rchild;
        }
    }
    return height;
}
```

**考点**：树高是 “平衡二叉树判断” 的前置步骤，递归法需注意终止条件，非递归法需记录每层节点数。

#### 2. 判断平衡二叉树（后序遍历剪枝， O (n)）

**平衡二叉树定义**：任意节点的左右子树高度差≤1。

```c
// 辅助函数：返回子树高度，若不平衡返回-1（剪枝）
int IsBalancedHelper(BiTree T) {
    if (T == NULL) return 0;
    // 后序遍历：先判断左子树，再判断右子树
    int leftH = IsBalancedHelper(T->lchild);
    if (leftH == -1) return -1; // 左子树不平衡，直接返回
    int rightH = IsBalancedHelper(T->rchild);
    if (rightH == -1) return -1; // 右子树不平衡，直接返回
    // 判断当前节点是否平衡
    if (abs(leftH - rightH) > 1) return -1;
    // 返回当前子树高度
    return (leftH > rightH ? leftH : rightH) + 1;
}

// 主函数：判断是否为平衡二叉树
bool IsBalancedBiTree(BiTree T) {
    return IsBalancedHelper(T) != -1;
}
```

**考点**：用后序遍历 “自底向上” 判断，避免重复计算高度（暴力法 O (n²)），剪枝优化效率至 O (n)，408 高频考点。

#### 3. 找最近公共祖先（ LCA， O (n)）

**LCA 定义**：二叉树中同时包含 `p` 和 `q` 的最深节点。

```c
BiTNode* LowestCommonAncestor(BiTree T, BiTNode *p, BiTNode *q) {
    // 终止条件：空树或找到 p/q（自身是祖先）
    if (T == NULL || T == p || T == q) return T;
    // 递归找左子树的 LCA
    BiTNode *leftLCA = LowestCommonAncestor(T->lchild, p, q);
    // 递归找右子树的 LCA
    BiTNode *rightLCA = LowestCommonAncestor(T->rchild, p, q);
    // 分情况讨论：
    if (leftLCA == NULL) return rightLCA; // 左子树无 p/q， LCA 在右
    if (rightLCA == NULL) return leftLCA; // 右子树无 p/q， LCA 在左
    return T; // 左右都有 p/q，当前节点是 LCA
}
```

**考点**：递归 “自上而下” 减 `target`，终止条件为叶子节点，408 常扩展为 “找出所有路径”（需用数组存路径）。

#### 4. 路径总和（判断是否存在和为 target 的路径， O (n)）

```c
bool HasPathSum(BiTree T, int target) {
    if (T == NULL) return false; // 空树无路径
    // 叶子节点：判断当前值是否等于剩余 target
    if (T->lchild == NULL && T->rchild == NULL) {
        return T->data == target;
    }
    // 递归判断左右子树： target 减去当前节点值
    int remain = target - T->data;
    return HasPathSum(T->lchild, remain) || HasPathSum(T->rchild, remain);
}
```

**考点**：递归 “自上而下” 减 `target`，终止条件为叶子节点，408 常扩展为 “找出所有路径”（需用数组存路径）。

#### 5. 二叉树分层打印（层序遍历变种， O (n)）

**场景**：按层输出节点，每层占一行（如`[3,9,20,null,null,7]`→`3\n9 20\n15 7`）

```c
void LevelOrderPrintByLayer(BiTree T) {
    if (T == NULL) return;
    BiTNode *queue[1000];
    int front = 0, rear = 0;
    queue[rear++] = T;
    while (front < rear) {
        int levelSize = rear - front; // 关键：记录当前层节点数
        // 遍历当前层
        for (int i = 0; i < levelSize; i++) {
            BiTNode *cur = queue[front++];
            printf("%d ", cur->data);
            // 孩子入队
            if (cur->lchild != NULL) queue[rear++] = cur->lchild;
            if (cur->rchild != NULL) queue[rear++] = cur->rchild;
        }
        printf("\n"); // 一层结束换行
    }
}
```

**考点**：层序遍历的核心变种，需通过 `levelSize` 控制每层输出，408 常考 “分层统计” 场景。

#### 6 二叉树的层平均值（ O (n)）

**场景**：计算每层节点的平均值，返回结果数组（如`[3,9,20,null,null,7]`→`[3.0,14.5,16.0]`）

```c
double* AverageOfLevels(BiTree T, int *returnSize) {
    *returnSize = 0;
    if (T == NULL) return NULL;
    double *res = (double*)malloc(1000 * sizeof(double));
    BiTNode *queue[1000];
    int front = 0, rear = 0;
    queue[rear++] = T;
    while (front < rear) {
        int levelSize = rear - front;
        double sum = 0.0;
        for (int i = 0; i < levelSize; i++) {
            BiTNode *cur = queue[front++];
            sum += cur->data;
            if (cur->lchild != NULL) queue[rear++] = cur->lchild;
            if (cur->rchild != NULL) queue[rear++] = cur->rchild;
        }
        res[(*returnSize)++] = sum / levelSize; // 计算平均值
    }
    return res;
}
```

**易错点**：`sum` 需用 `double` 类型，避免整数除法导致精度丢失。

#### 7. 二叉树的镜像（反转二叉树， O (n)）

**场景**：交换每个节点的左右孩子，得到镜像树（如 4→2→1/3→4→3→2/1）

```c
BiTree MirrorTree(BiTree T) {
    if (T == NULL) return NULL;
    // 1. 交换当前节点的左右孩子
    BiTNode *temp = T->lchild;
    T->lchild = T->rchild;
    T->rchild = temp;
    // 2. 递归处理左右子树
    MirrorTree(T->lchild);
    MirrorTree(T->rchild);
    return T;
}
```

**考点**：递归 “自上而下” 交换，非递归可用栈 / 队列遍历交换，408 常考 “判断两树是否为镜像”。

#### 8. 判断对称二叉树（ O (n)）

**场景**：判断二叉树是否关于根节点对称（如 1→2→3/4 和 1→4→3/2 对称）

```c
// 辅助函数：判断两棵子树是否对称
bool isSymmetricHelper(BiTNode *left, BiTNode *right) {
    if (left == NULL && right == NULL) return true; // 都空
    if (left == NULL || right == NULL) return false; // 一空一非空
    // 1. 当前节点值相等 2. 左左=右右 3. 左右=右左
    return (left->data == right->data) &&
           isSymmetricHelper(left->lchild, right->rchild) &&
           isSymmetricHelper(left->rchild, right->lchild);
}

bool IsSymmetric(BiTree T) {
    if (T == NULL) return true;
    return isSymmetricHelper(T->lchild, T->rchild);
}
```

**核心逻辑**：对称的本质是 “左子树的左 = 右子树的右，左子树的右 = 右子树的左”。

#### 9. 二叉树的最小深度（ O (n)）

**场景**：最小深度是从根到最近叶子节点的最短路径长度（空树深度 0，单节点深度 1）

```c
int MinDepth(BiTree T) {
    if (T == NULL) return 0;
    // 叶子节点：深度 1
    if (T->lchild == NULL && T->rchild == NULL) return 1;
    // 左子树空：最小深度=右子树深度+1
    if (T->lchild == NULL) return MinDepth(T->rchild) + 1;
    // 右子树空：最小深度=左子树深度+1
    if (T->rchild == NULL) return MinDepth(T->lchild) + 1;
    // 都非空：取左右最小+1
    int leftD = MinDepth(T->lchild);
    int rightD = MinDepth(T->rchild);
    return (leftD < rightD ? leftD : rightD) + 1;
}
```

**易错点**：不能直接用 `min(leftD, rightD)+1`（需处理单空子树，避免将非叶子节点误判为叶子）。

#### 10. 二叉树的节点个数（ O (n)）

**场景**：统计二叉树所有节点总数（空树 0，单节点 1）

```c
// 递归法
int CountNodesRec(BiTree T) {
    if (T == NULL) return 0;
    // 节点数=左子树数+右子树数+1（当前节点）
    return CountNodesRec(T->lchild) + CountNodesRec(T->rchild) + 1;
}

// 非递归法（层序遍历）
int CountNodesNonRec(BiTree T) {
    if (T == NULL) return 0;
    int count = 0;
    BiTNode *queue[1000];
    int front = 0, rear = 0;
    queue[rear++] = T;
    while (front < rear) {
        BiTNode *cur = queue[front++];
        count++;
        if (cur->lchild != NULL) queue[rear++] = cur->lchild;
        if (cur->rchild != NULL) queue[rear++] = cur->rchild;
    }
    return count;
}
```

**考点**：基础统计操作，是 “完全二叉树节点数（ O (log²n) 优化）” 的前置。

#### 11. 二叉树的叶子节点个数（ O (n)）

**场景**：统计所有叶子节点（无左右孩子）的数量

```c
int CountLeafNodes(BiTree T) {
    if (T == NULL) return 0;
    // 叶子节点：左右都空
    if (T->lchild == NULL && T->rchild == NULL) return 1;
    // 非叶子：递归统计左右子树
    return CountLeafNodes(T->lchild) + CountLeafNodes(T->rchild);
}
```

**考点**：递归 “逐节点对比”，非递归可用栈 / 队列同步遍历。

#### 12. 合并二叉树（ O (min (n,m))）

**场景**：两个节点重叠时值相加，否则取非空节点（如 1→3/2 和 2→1/3 合并为 3→4/5）

```c
BiTree MergeTrees(BiTree T1, BiTree T2) {
    if (T1 == NULL) return T2; // T1 空，返回 T2
    if (T2 == NULL) return T1; // T2 空，返回 T1
    // 1. 合并当前节点值
    T1->data += T2->data;
    // 2. 递归合并左右子树
    T1->lchild = MergeTrees(T1->lchild, T2->lchild);
    T1->rchild = MergeTrees(T1->rchild, T2->rchild);
    // 3. 释放 T2 节点（避免内存泄漏）
    free(T2);
    return T1;
}
```

**易错点**：合并后需释放其中一棵树的节点，避免内存泄漏。

#### 13. 二叉树的右视图（ O (n)）

**场景**：从右侧看树，输出每层最右节点（如 1→2→3/4→`[1,2,4]`）

```c
int* RightSideView(BiTree T, int *returnSize) {
    *returnSize = 0;
    if (T == NULL) return NULL;
    int *res = (int*)malloc(1000 * sizeof(int));
    BiTNode *queue[1000];
    int front = 0, rear = 0;
    queue[rear++] = T;
    while (front < rear) {
        int levelSize = rear - front;
        // 遍历当前层，记录最后一个节点（最右）
        for (int i = 0; i < levelSize; i++) {
            BiTNode *cur = queue[front++];
            if (i == levelSize - 1) { // 最右节点
                res[(*returnSize)++] = cur->data;
            }
            if (cur->lchild != NULL) queue[rear++] = cur->lchild;
            if (cur->rchild != NULL) queue[rear++] = cur->rchild;
        }
    }
    return res;
}
```

**核心**：层序遍历中记录每层最后一个节点，左视图类似（记录第一个节点）。

#### 14. 二叉树的所有路径（ O (n)）

**场景**：输出从根到叶子的所有路径（如 1→2/3→`["1->2","1->3"]`）

```c
// 辅助函数：递归收集路径
void collectPaths(BiTree T, char **paths, int *returnSize, char *temp, int tempLen) {
    if (T == NULL) return;
    // 1. 将当前节点值存入临时路径
    int len = sprintf(temp + tempLen, "%d", T->data);
    tempLen += len;
    // 2. 叶子节点：保存路径
    if (T->lchild == NULL && T->rchild == NULL) {
        paths[*returnSize] = (char*)malloc(tempLen + 1);
        strncpy(paths[*returnSize], temp, tempLen);
        paths[*returnSize][tempLen] = '\0';
        (*returnSize)++;
        return;
    }
    // 3. 非叶子：添加"->"，递归左右子树
    temp[tempLen++] = '-';
    temp[tempLen++] = '>';
    collectPaths(T->lchild, paths, returnSize, temp, tempLen);
    collectPaths(T->rchild, paths, returnSize, temp, tempLen);
}

char** BinaryTreePaths(BiTree T, int *returnSize) {
    *returnSize = 0;
    if (T == NULL) return NULL;
    char **paths = (char**)malloc(1000 * sizeof(char*));
    char temp[1000]; // 临时存储路径
    collectPaths(T, paths, returnSize, temp, 0);
    return paths;
}
```

**考点**：递归 “自上而下” 构建路径，叶子节点时保存，需处理字符串拼接。

#### 15. 路径总和 II（找所有和为 target 的路径， O (n)）

**场景**：输出从根到叶子的所有路径，路径和等于 `target`（如 5→4→11→2 和 5→8→4→5，`target=22`）

```c
// 辅助函数：递归收集路径
void collectSumPaths(BiTree T, int target, int **paths, int *returnSize,
                     int *colSizes, int *temp, int tempLen) {
    if (T == NULL) return;
    // 1. 当前节点值入临时路径
    temp[tempLen++] = T->data;
    target -= T->data; // 剩余目标和
    // 2. 叶子节点且和为 0：保存路径
    if (T->lchild == NULL && T->rchild == NULL && target == 0) {
        paths[*returnSize] = (int*)malloc(tempLen * sizeof(int));
        memcpy(paths[*returnSize], temp, tempLen * sizeof(int));
        colSizes[*returnSize] = tempLen;
        (*returnSize)++;
        return;
    }
    // 3. 递归左右子树
    collectSumPaths(T->lchild, target, paths, returnSize, colSizes, temp, tempLen);
    collectSumPaths(T->rchild, target, paths, returnSize, colSizes, temp, tempLen);
}

int** PathSumII(BiTree T, int target, int *returnSize, int **colSizes) {
    *returnSize = 0;
    if (T == NULL) return NULL;
    int **paths = (int**)malloc(1000 * sizeof(int*));
    *colSizes = (int*)malloc(1000 * sizeof(int));
    int temp[1000]; // 临时路径
    collectSumPaths(T, target, paths, returnSize, *colSizes, temp, 0);
    return paths;
}
```

**易错点**：`target` 需传值（每次递归是剩余和），避免递归间相互影响。

#### 16. 二叉树的最近公共祖先（ LCA） - 含父指针（ O (n)）

**场景**：若节点含 `parent` 指针，找 `p` 和 `q` 的 LCA（无需递归）

```c
// 含父指针的节点定义
typedef struct BiTNodeWithParent {
    int data;
    struct BiTNodeWithParent *lchild, *rchild, *parent;
} BiTNodeP, *BiTreeP;

BiTNodeP* LCAWithParent(BiTreeP p, BiTreeP q) {
    // 1. 计算 p 和 q 的深度
    int depthP = 0, depthQ = 0;
    BiTNodeP *curP = p, *curQ = q;
    while (curP->parent != NULL) { depthP++; curP = curP->parent; }
    while (curQ->parent != NULL) { depthQ++; curQ = curQ->parent; }
    // 2. 对齐深度（深的节点先上移）
    curP = p; curQ = q;
    while (depthP > depthQ) { curP = curP->parent; depthP--; }
    while (depthQ > depthP) { curQ = curQ->parent; depthQ--; }
    // 3. 同步上移，相遇即 LCA
    while (curP != curQ) {
        curP = curP->parent;
        curQ = curQ->parent;
    }
    return curP;
}
```

**考点**：利用父指针 “自下而上” 找 LCA，无需遍历整棵树，效率更高。

#### 17. 删除二叉树中的节点（ O (n)）

**场景**：删除值为 `key` 的节点，保持二叉树结构（删除后用左子树最大或右子树最小节点替代）

```c
// 辅助函数：找右子树的最小节点（后继）
BiTNode* findMin(BiTree T) {
    while (T->lchild != NULL) T = T->lchild;
    return T;
}

BiTree DeleteNode(BiTree T, int key) {
    if (T == NULL) return NULL;
    // 1. 找待删除节点
    if (key < T->data) {
        T->lchild = DeleteNode(T->lchild, key); // 左子树删除
    } else if (key > T->data) {
        T->rchild = DeleteNode(T->rchild, key); // 右子树删除
    } else {
        // 2. 找到待删除节点，分三种情况
        if (T->lchild == NULL) { // 无左孩子：返回右孩子
            BiTNode *temp = T->rchild;
            free(T);
            return temp;
        } else if (T->rchild == NULL) { // 无右孩子：返回左孩子
            BiTNode *temp = T->lchild;
            free(T);
            return temp;
        }
        // 3. 有两个孩子：找右子树最小节点（后继）替代
        BiTNode *minNode = findMin(T->rchild);
        T->data = minNode->data; // 复制值
        // 删除后继节点
        T->rchild = DeleteNode(T->rchild, minNode->data);
    }
    return T;
}
```

**核心**：删除节点的三种情况处理，是 BST 删除的基础逻辑。

#### 18. 二叉树转化为有序双向链表（中序遍历， O (n)）

**场景**：将二叉树按中序顺序转化为双向链表（左指针 = 前驱，右指针 = 后继）

```c
// 辅助变量：记录前驱节点
BiTNode *prev_global_tree_to_dll = NULL;

// 辅助函数：中序遍历构建双向链表
void treeToDLLHelper(BiTree T, BiTNode **head) {
    if (T == NULL) return;
    // 1. 递归左子树
    treeToDLLHelper(T->lchild, head);
    // 2. 处理当前节点
    if (prev_global_tree_to_dll == NULL) {
        *head = T; // 第一个节点为头
    } else {
        prev_global_tree_to_dll->rchild = T; // 前驱的右=当前
        T->lchild = prev_global_tree_to_dll; // 当前的左=前驱
    }
    prev_global_tree_to_dll = T; // 更新前驱
    // 3. 递归右子树
    treeToDLLHelper(T->rchild, head);
}

BiTNode* TreeToDoublyList(BiTree T) {
    BiTNode *head = NULL;
    prev_global_tree_to_dll = NULL; // 重置全局变量
    treeToDLLHelper(T, &head);
    return head;
}
```

**考点**：利用中序遍历的有序性，通过 `prev` 指针构建双向关联，408 常考 “转化为循环双向链表”（需让头尾相连）。

#### 19. 根据后序 + 中序序列构建二叉树（ O (n²)）

**场景**：已知后序（左右根）和中序（左根右）序列，唯一确定二叉树（无重复元素）

```c
// 辅助函数：找中序序列中根节点索引 (与 CreateBiTreeByPreIn 中的类似，这里重新定义以保持独立性)
int findRootInInorder_postin(int *inorder, int inLen, int rootVal) {
    for (int i = 0; i < inLen; i++) {
        if (inorder[i] == rootVal) return i;
    }
    return -1;
}

BiTree CreateBiTreeByPostIn(int *postorder, int postLen,
                            int *inorder, int inLen) {
    if (postLen == 0 || inLen == 0) return NULL;
    // 1. 后序序列最后一个元素为根
    int rootVal = postorder[postLen - 1];
    BiTree root = (BiTNode*)malloc(sizeof(BiTNode));
    root->data = rootVal;
    root->lchild = root->rchild = NULL;
    // 2. 中序序列分左右子树
    int rootIdx = findRootInInorder_postin(inorder, inLen, rootVal);
    int leftLen = rootIdx;
    int rightLen = inLen - rootIdx - 1;
    // 3. 递归构建左右子树
    // 左子树：后序[0..leftLen-1]，中序[0..rootIdx-1]
    root->lchild = CreateBiTreeByPostIn(postorder, leftLen,
                                        inorder, leftLen);
    // 右子树：后序[leftLen..postLen-2]，中序[rootIdx+1..inLen-1]
    root->rchild = CreateBiTreeByPostIn(postorder + leftLen, rightLen,
                                        inorder + rootIdx + 1, rightLen);
    return root;
}
```

**考点**：与 “前序 + 中序” 构建逻辑对称，核心是 “后序定根、中序分左右”。

#### 20. 完全二叉树的节点计数（优化版， O (log²n)）

**场景**：完全二叉树特性：叶子节点仅在最后两层，且最后一层左密右疏，利用此特性优化节点计数（比普通 O (n) 更高效，408 高频优化考点）

```c
// 辅助函数：计算完全二叉树的左子树深度（仅左走）
int getLeftDepth(BiTree T) {
    int depth = 0;
    while (T != NULL) {
        depth++;
        T = T->lchild;
    }
    return depth;
}

// 完全二叉树节点计数（O(log²n)）
int CountCompleteTreeNodes(BiTree T) {
    if (T == NULL) return 0;
    // 计算左子树左深度、右子树左深度
    int leftLeftDepth = getLeftDepth(T->lchild);
    int rightLeftDepth = getLeftDepth(T->rchild);
    if (leftLeftDepth == rightLeftDepth) {
        // 左子树是满二叉树：节点数=2^leftLeftDepth -1 + 1（当前） + 右子树计数
        return (1 << leftLeftDepth) + CountCompleteTreeNodes(T->rchild); // (2^k - 1) + 1 = 2^k
    } else {
        // 右子树是满二叉树：节点数=2^rightLeftDepth -1 + 1（当前） + 左子树计数
        return (1 << rightLeftDepth) + CountCompleteTreeNodes(T->lchild); // (2^k - 1) + 1 = 2^k
    }
}
```

**考点**：利用完全二叉树 “左子树或右子树必为满二叉树” 的特性，通过移位计算满二叉树节点数（2^depth 用 `1<<depth`），优化时间复杂度；408 常考复杂度分析。
**易错点**：移位运算优先级低于减法，需加括号（如`(1<<depth)-1`）。

#### 21. 判断是否为完全二叉树（层序遍历， O (n)）

**场景**：完全二叉树定义：除最后一层外，每层节点数满，最后一层节点左密右疏（空节点后无非空节点）

```c
bool IsCompleteBinaryTree(BiTree T) {
    if (T == NULL) return true; // 空树是完全二叉树
    BiTNode *queue[1000];
    int front = 0, rear = 0;
    queue[rear++] = T;
    bool hasNull = false; // 标记是否遇到空节点
    while (front < rear) {
        BiTNode *cur = queue[front++];
        if (cur == NULL) {
            hasNull = true; // 遇到空节点，后续必须全为空
        } else {
            if (hasNull) return false; // 空节点后出现非空节点，不是完全二叉树
            // 无论孩子是否为空，都入队（用于判断后续空节点）
            queue[rear++] = cur->lchild;
            queue[rear++] = cur->rchild;
        }
    }
    return true;
}
```

**核心逻辑**：层序遍历中，一旦遇到空节点，后续所有节点必须为空；若空节点后有非空节点，直接判定为非完全二叉树。
**考点**：完全二叉树的判定标准，408 常与 “满二叉树” 对比考查。

#### 22. 二分查找的判定树构建（模拟二分过程， O (logn)）

**场景**：二分查找的过程可映射为判定树，每个非叶子节点代表 “与 `mid` 比较”，左子树 “小于 `mid`”，右子树 “大于 `mid`”

```c
// 辅助函数：递归构建二分查找判定树（节点值为数组索引，方便定位）
void buildBinarySearchDecisionTree(int arr[], int low, int high, BiTree *T) {
    if (low > high) {
        *T = NULL;
        return;
    }
    int mid = low + (high - low) / 2; // 避免溢出
    // 创建当前节点（值为 arr[mid]，索引为 mid，方便后续查找）
    *T = (BiTNode*)malloc(sizeof(BiTNode));
    (*T)->data = arr[mid];
    (*T)->lchild = (*T)->rchild = NULL;
    // 左子树： low~mid-1（小于当前值的区间）
    buildBinarySearchDecisionTree(arr, low, mid - 1, &((*T)->lchild));
    // 右子树： mid+1~high（大于当前值的区间）
    buildBinarySearchDecisionTree(arr, mid + 1, high, &((*T)->rchild));
}

// 构建二分查找判定树（输入有序数组）
BiTree BuildBinarySearchDecisionTree(int arr[], int n) {
    if (n == 0) return NULL;
    BiTree T;
    buildBinarySearchDecisionTree(arr, 0, n - 1, &T);
    return T;
}
```

**判定树与查找算法的映射关系**：二分查找的判定树是平衡二叉树，查找长度为树的深度（ O (logn)）。
**易错点**：必须输入有序数组，符合二分查找的前提； `mid` 计算用 `low+(high-low)/2` 避免溢出。

#### 23. 判定树的深度计算（查找长度分析， O (logn)）

**场景**：判定树的深度对应 “最坏情况下的查找次数”（查找长度），如二分查找判定树的深度为`⌈log₂(n+1)⌉`

```c
// 计算判定树的深度（递归法，同普通二叉树深度，但仅适用于平衡判定树）
int DecisionTreeDepth(BiTree T) {
    if (T == NULL) return 0;
    int leftDepth = DecisionTreeDepth(T->lchild);
    int rightDepth = DecisionTreeDepth(T->rchild);
    return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
}

// 二分查找判定树的深度（公式法， O(1)， 408 常考）
int BinarySearchDecisionTreeDepth(int n) {
    if (n == 0) return 0;
    // 公式：深度=⌈log2(n+1)⌉，用移位实现 log2 计算
    int depth = 0;
    int count = 1; // 2^0=1
    while (count < n + 1) {
        count <<= 1; // 2^depth
        depth++;
    }
    return depth;
}
```

**核心**：平衡判定树（如二分查找）的深度可通过公式计算，避免递归遍历；非平衡判定树（如线性查找）的深度为 `n`（ O (n)）。
**考点**：查找算法的最坏查找长度分析，408 常考二分查找与顺序查找的判定树深度对比。

#### 24. 红黑树的节点定义与旋转操作（基础， O (1)）

**场景**：红黑树的平衡调整依赖左旋转、右旋转，是插入 / 删除的前提

```c
// 红黑树节点定义（颜色： 0=黑， 1=红）
typedef enum { BLACK, RED } Color;
typedef struct RBNode {
    int key;
    Color color;
    struct RBNode *parent, *lchild, *rchild;
} RBNode, *RBTRee;

// 红黑树左旋转（ x 为旋转节点）
void RB_RotateLeft(RBTRee *root, RBNode *x) {
    RBNode *y = x->rchild; // y 是 x 的右孩子
    // 1. 处理 y 的左孩子（移给 x 的右孩子）
    x->rchild = y->lchild;
    if (y->lchild != NULL) {
        y->lchild->parent = x;
    }
    // 2. 处理 y 的父节点（ x 的父节点变为 y 的父节点）
    y->parent = x->parent;
    if (x->parent == NULL) {
        *root = y; // x 是根，旋转后 y 为根
    } else if (x == x->parent->lchild) {
        x->parent->lchild = y; // x 是左孩子， y 接替 x 的左孩子位置
    } else {
        x->parent->rchild = y; // x 是右孩子， y 接替 x 的右孩子位置
    }
    // 3. 连接 x 和 y（y 的左孩子变为 x， x 的父节点变为 y）
    y->lchild = x;
    x->parent = y;
}

// 红黑树右旋转（y 为旋转节点，与左旋转对称）
void RB_RotateRight(RBTRee *root, RBNode *y) {
    RBNode *x = y->lchild; // x 是 y 的左孩子
    // 1. 处理 x 的右孩子（移给 y 的左孩子）
    y->lchild = x->rchild;
    if (x->rchild != NULL) {
        x->rchild->parent = y;
    }
    // 2. 处理 x 的父节点
    x->parent = y->parent;
    if (y->parent == NULL) {
        *root = x; // y 是根，旋转后 x 为根
    } else if (y == y->parent->lchild) {
        y->parent->lchild = x;
    } else {
        y->parent->rchild = x;
    }
    // 3. 连接 y 和 x
    x->rchild = y;
    y->parent = x;
}
```

**考点**：旋转操作不改变红黑树的 “黑高”（路径黑节点数），是平衡调整的核心；408 需熟记旋转步骤，尤其是指针的修改顺序。
**易错点**：忘记处理 “旋转节点的父节点” 和 “旋转节点孩子的父节点”，导致树结构断裂。

#### 25. 红黑树插入后的平衡调整（核心， O (logn)）

**场景**：红黑树插入节点默认设为红色（减少黑高变化），若违反 “红父必黑”，需通过旋转 + 颜色修正恢复性质

```c
// 红黑树插入平衡调整
void RB_InsertFixup(RBTRee *root, RBNode *z) {
    while (z->parent != NULL && z->parent->color == RED) { // 父节点为红，违反性质
        if (z->parent == z->parent->parent->lchild) { // 父节点是祖父的左孩子
            RBNode *y = z->parent->parent->rchild; // 叔叔节点（祖父的右孩子）
            // 情况 1：叔叔是红色（父、叔变黑，祖父变红， z 上移）
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                // 情况 2：叔叔是黑色， z 是右孩子（先左旋转，转为情况 3）
                if (z == z->parent->rchild) {
                    z = z->parent;
                    RB_RotateLeft(root, z);
                }
                // 情况 3：叔叔是黑色， z 是左孩子（父变黑，祖父变红，右旋转）
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                RB_RotateRight(root, z->parent->parent);
            }
        } else { // 父节点是祖父的右孩子（与左对称）
            RBNode *y = z->parent->parent->lchild; // 叔叔节点
            // 情况 1：叔叔是红色
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                // 情况 2：叔叔是黑色， z 是左孩子（右旋转）
                if (z == z->parent->lchild) {
                    z = z->parent;
                    RB_RotateRight(root, z);
                }
                // 情况 3：叔叔是黑色， z 是右孩子（父变黑，祖父变红，左旋转）
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                RB_RotateLeft(root, z->parent->parent);
            }
        }
    }
    (*root)->color = BLACK; // 根节点必为黑，确保性质 1
}

// 红黑树插入（先 BST 插入，再平衡调整）
void RB_Insert(RBTRee *root, int key) {
    // 1. BST 插入
    RBNode *z = (RBNode*)malloc(sizeof(RBNode));
    z->key = key;
    z->color = RED; // 新节点默认红色
    z->parent = z->lchild = z->rchild = NULL;
    RBNode *y = NULL; // 父节点缓存
    RBNode *x = *root;
    while (x != NULL) {
        y = x;
        if (z->key < x->key) {
            x = x->lchild;
        } else {
            x = x->rchild;
        }
    }
    z->parent = y;
    if (y == NULL) {
        *root = z; // 空树， z 为根
    } else if (z->key < y->key) {
        y->lchild = z;
    } else {
        y->rchild = z;
    }
    // 2. 平衡调整
    RB_InsertFixup(root, z);
}
```

**考点**：红黑树插入的三大情况（叔叔颜色不同），408 需能区分并写出调整步骤；核心是 “通过旋转改变结构，通过颜色修正恢复性质”。
**易错点**：对称情况（父节点是祖父左 / 右孩子）的处理，避免遗漏；调整后必须将根节点设为黑色。

#### 26. 哈夫曼树的构建（小根堆选最小节点， O (nlogn)）

**场景**：输入 `n` 个权值，构建哈夫曼树（无度为 1 的节点，`n` 个叶子节点对应 `n` 个权值）

```c
// 哈夫曼树节点定义（ weight=权值， parent/lchild/rchild=父/子节点索引，用数组存储便于操作）
typedef struct {
    int weight;
    int parent, lchild, rchild;
} HuffmanNode;

// 构建哈夫曼树（ n 个叶子节点，总节点数=2n-1）
void BuildHuffmanTree(HuffmanNode *HT, int *weights, int n) {
    if (n <= 1) return;
    int m = 2 * n - 1; // 哈夫曼树总节点数
    // 1. 初始化叶子节点（前 n 个节点）
    for (int i = 0; i < n; i++) {
        HT[i].weight = weights[i];
        HT[i].parent = HT[i].lchild = HT[i].rchild = -1;
    }
    // 2. 初始化非叶子节点（ n~m-1）
    for (int i = n; i < m; i++) {
        HT[i].weight = 0;
        HT[i].parent = HT[i].lchild = HT[i].rchild = -1;
    }
    // 3. 循环合并两个最小权值节点（构建非叶子节点）
    for (int i = n; i < m; i++) {
        // 找两个权值最小且父节点为-1 的节点（ s1<s2， s1 是更小的）
        int s1 = 0, s2 = 0;
        // 先找第一个最小节点 s1
        // 找到第一个未被合并的节点作为初始 s1
        int k = 0;
        while(k < i && HT[k].parent != -1) k++;
        s1 = k;
        for (int j = k + 1; j < i; j++) {
            if (HT[j].parent == -1 && HT[j].weight < HT[s1].weight) {
                s1 = j;
            }
        }
        // 再找第二个最小节点 s2（排除 s1）
        // 找到第一个未被合并且不是 s1 的节点作为初始 s2
        k = 0;
        while(k < i && (HT[k].parent != -1 || k == s1)) k++;
        s2 = k;
        for (int j = k + 1; j < i; j++) {
            if (HT[j].parent == -1 && j != s1 && HT[j].weight < HT[s2].weight) {
                s2 = j;
            }
        }
        // 合并 s1 和 s2 到节点 i
        HT[s1].parent = i;
        HT[s2].parent = i;
        // 确保左孩子权值≤右孩子 (通常是这样约定，实际顺序不影响WPL)
        if (HT[s1].weight < HT[s2].weight) {
            HT[i].lchild = s1;
            HT[i].rchild = s2;
        } else {
            HT[i].lchild = s2;
            HT[i].rchild = s1;
        }
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}
```

**考点**：哈夫曼树的构建步骤，核心是 “每次选两个最小权值节点合并”；用数组存储节点（静态结构），符合 408 备考需求。
**易错点**：找最小节点时需排除已合并（ `parent≠-1`）的节点；左孩子权值≤右孩子，确保编码唯一。

#### 27. 哈夫曼编码的生成（左 0 右 1， O (nlogn)）

**场景**：基于哈夫曼树生成每个叶子节点的哈夫曼编码（前缀编码，无歧义）

```c
// 生成哈夫曼编码（ code 数组存储编码， start 是编码起始索引，从叶子到根回溯）
void GenerateHuffmanCode(HuffmanNode *HT, char **code, int n) {
    char *tempCode = (char*)malloc(n * sizeof(char)); // 临时存储单个编码（最长 n-1 位）
    int start = n - 1; // 从末尾开始存储（回溯时逆序）
    tempCode[start] = '\0'; // 编码结束符
    for (int i = 0; i < n; i++) { // 遍历每个叶子节点
        int c = i; // 当前节点索引
        int p = HT[c].parent; // 父节点索引
        while (p != -1) { // 回溯到根节点（ parent=-1）
            start--;
            if (HT[p].lchild == c) { // 左孩子→编码 0
                tempCode[start] = '0';
            } else { // 右孩子→编码 1
                tempCode[start] = '1';
            }
            c = p;
            p = HT[c].parent;
        }
        // 复制临时编码到 code[i]
        code[i] = (char*)malloc((n - start) * sizeof(char));
        strcpy(code[i], tempCode + start);
        start = n - 1; // 重置 start，处理下一个叶子
    }
    free(tempCode);
}

// 哈夫曼编码使用示例
void HuffmanCodeExample() {
    int weights[] = {5, 3, 8, 2}; // 4 个权值
    int n = 4;
    int m = 2 * n - 1;
    HuffmanNode *HT = (HuffmanNode*)malloc(m * sizeof(HuffmanNode));
    BuildHuffmanTree(HT, weights, n);
    // 生成编码（ code 是二维数组， code[i]是第 i 个权值的编码）
    char **code = (char**)malloc(n * sizeof(char*));
    GenerateHuffmanCode(HT, code, n);
    // 打印编码
    for (int i = 0; i < n; i++) {
        printf("权值%d 的哈夫曼编码： %s\n", weights[i], code[i]);
    }
    // 释放内存
    for (int i = 0; i < n; i++) free(code[i]);
    free(code);
    free(HT);
}
```

**核心**：通过 “从叶子到根回溯” 生成编码，左 0 右 1（或左 1 右 0，需统一约定）；编码是前缀码，确保解码无歧义。
**考点**：哈夫曼编码的生成逻辑，408 常考 “给定权值，写出哈夫曼编码” 或 “计算编码长度”。

#### 28. 哈夫曼树的带权路径长度（ WPL）计算（ O (n)）

**场景**：WPL=Σ（叶子节点权值 × 路径长度），是哈夫曼树的核心评价指标

```c
// 方法 1：遍历叶子节点计算（路径长度=从叶子到根的边数）
int CalculateWPL(HuffmanNode *HT, int n) {
    int wpl = 0;
    for (int i = 0; i < n; i++) { // 遍历叶子节点
        int pathLen = 0;
        int c = i;
        int p = HT[c].parent;
        while (p != -1) { // 计算路径长度
            pathLen++;
            c = p;
            p = HT[c].parent;
        }
        wpl += HT[i].weight * pathLen;
    }
    return wpl;
}

// 方法 2：利用非叶子节点权值求和（哈夫曼树特性： WPL=所有非叶子节点权值之和）
int CalculateWPLByNonLeaf(HuffmanNode *HT, int n) {
    if (n <= 1) return 0;
    int m = 2 * n - 1;
    int wpl = 0;
    for (int i = n; i < m; i++) { // 非叶子节点是 n~m-1
        wpl += HT[i].weight;
    }
    return wpl;
}
```

**考点**：哈夫曼树的特性 ——WPL 等于所有非叶子节点权值之和，此方法比遍历叶子更高效（ O (n) vs O (nlogn)）；408 常考 WPL 计算，需熟记此特性。
**易错点**：非叶子节点的范围是 `n~2n-2`（数组索引从 0 开始），避免遍历错误。

#### 29. 中缀表达式转逆波兰式（基于表达式树思路， O (n)）

**场景**：中缀表达式（如 `3*(4+5)`）转逆波兰式（ `3 4 5 + *`），用栈处理运算符优先级

```c
// 辅助函数：判断是否为运算符
bool isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/';
}

// 辅助函数：获取运算符优先级（ +/-=1， */=2，括号=0）
int getPriority(char c) {
    if (c == '+' || c == '-') return 1;
    if (c == '*' || c == '/') return 2;
    return 0; // 括号优先级最低
}

// 中缀表达式转逆波兰式（后缀表达式）
char* InfixToPostfix(char *infix) {
    int len = strlen(infix);
    char *postfix = (char*)malloc((2 * len) * sizeof(char)); // 后缀长度最多 2 倍中缀
    char stack[1000]; // 栈存运算符和括号
    int top = -1; // 栈顶指针
    int idx = 0; // 后缀表达式索引
    for (int i = 0; i < len; i++) {
        char c = infix[i];
        if (c == ' ') continue; // 跳过空格
        if (isdigit(c)) { // 数字：直接加入后缀
            while (i < len && isdigit(infix[i])) {
                postfix[idx++] = infix[i++];
            }
            postfix[idx++] = ' '; // 数字间用空格分隔（便于后续解析）
            i--; // 回退，处理下一个字符
        } else if (c == '(') { // 左括号：入栈
            stack[++top] = c;
        } else if (c == ')') { // 右括号：弹出栈顶直到左括号
            while (top != -1 && stack[top] != '(') {
                postfix[idx++] = stack[top--];
                postfix[idx++] = ' ';
            }
            top--; // 弹出左括号（不加入后缀）
        } else if (isOperator(c)) { // 运算符：按优先级弹出栈顶
            // 栈非空、栈顶不是左括号、栈顶优先级≥当前，弹出
            while (top != -1 && stack[top] != '(' && getPriority(stack[top]) >= getPriority(c)) {
                postfix[idx++] = stack[top--];
                postfix[idx++] = ' ';
            }
            stack[++top] = c; // 当前运算符入栈
        }
    }
    // 弹出栈中剩余运算符
    while (top != -1) {
        postfix[idx++] = stack[top--];
        postfix[idx++] = ' ';
    }
    postfix[idx-1] = '\0'; // 替换最后一个空格为结束符
    return postfix;
}
```

**核心逻辑**：数字直接输出，运算符按优先级入栈（高优先级先弹出），括号特殊处理（左入栈，右弹出到左括号）；本质是构建表达式树的 “后序遍历” 过程。
**考点**：运算符优先级处理、括号处理，408 常考含括号的中缀转后缀。
**易错点**：数字间用空格分隔，便于后续计算时解析多位数；最后需弹出栈中剩余运算符。

#### 30. 逆波兰式的计算（栈实现， O (n)）

**场景**：计算逆波兰式的值（如 `3 4 5 + *`→27），用栈存储操作数

```c
int EvaluatePostfix(char *postfix) {
    int stack[1000];
    int top = -1;
    int len = strlen(postfix);
    int num = 0; // 临时存储多位数
    for (int i = 0; i < len; i++) {
        char c = postfix[i];
        if (c == ' ') { // 空格：多位数结束，入栈
            if (i > 0 && isdigit(postfix[i-1])) {
                stack[++top] = num;
                num = 0;
            }
            continue;
        }
        if (isdigit(c)) { // 数字：累积多位数
            num = num * 10 + (c - '0');
        } else if (isOperator(c)) { // 运算符：弹出两个操作数计算
            if (top < 1) return 0; // 操作数不足，表达式非法
            int b = stack[top--]; // 后弹出的是右操作数
            int a = stack[top--]; // 先弹出的是左操作数
            int res;
            switch (c) {
                case '+': res = a + b; break;
                case '-': res = a - b; break;
                case '*': res = a * b; break;
                case '/': res = a / b; break; // 假设除数不为 0
                default: res = 0;
            }
            stack[++top] = res; // 结果入栈
        }
    }
    return top >= 0 ? stack[top] : 0; // 栈顶是最终结果
}
```

**考点**：栈的经典应用，操作数弹出顺序（先右后左），408 常考含多位数和括号的逆波兰式计算。
**易错点**：多位数的解析（累积 `num`）、操作数的弹出顺序（右操作数先弹），避免计算错误（如 `a-b` 误算为 `b-a`）。

### 二叉搜索树（ BST）模板

BST 核心特性：中序遍历有序，左子树值 < 根值 < 右子树值，基于此实现高效查找、插入、删除。

#### 1. BST 查找（ O (logn)，最坏 O (n)）

```c
BiTNode* BST_Search(BiTree T, int key) {
    while (T != NULL && T->data != key) {
        if (key < T->data) {
            T = T->lchild; // key 小，找左子树
        } else {
            T = T->rchild; // key 大，找右子树
        }
    }
    return T; // 找到返回节点，否则返回 NULL
}
```

**考点**：BST 查找无需递归，利用有序特性缩小范围，平均效率 O (logn)，最坏（退化为链表） O (n)。

#### 2. BST 插入（ O (logn)，最坏 O (n)）

```c
// 插入后仍为 BST，返回新树的根
BiTree BST_Insert(BiTree T, int key) {
    // 空树：创建新节点作为根
    if (T == NULL) {
        T = (BiTNode*)malloc(sizeof(BiTNode));
        T->data = key;
        T->lchild = T->rchild = NULL;
        return T;
    }
    // 非空树：找到插入位置
    if (key < T->data) {
        T->lchild = BST_Insert(T->lchild, key); // 插入左子树
    } else if (key > T->data) {
        T->rchild = BST_Insert(T->rchild, key); // 插入右子树
    }
    // key 相等： BST 不允许重复（或按题目要求处理）
    return T;
}
```

**考点**：插入需保持 BST 特性，递归找到空位置插入，408 常考 “构建 BST”（多次插入）。

#### 3. 验证 BST（中序遍历有序， O (n)）

```c
// 辅助变量：记录前一个节点值（初始为极小值）
int prevVal_global_bst = INT_MIN;

bool IsValidBSTHelper(BiTree T) {
    if (T == NULL) return true;
    // 中序遍历：先左子树
    if (!IsValidBSTHelper(T->lchild)) return false;
    // 访问根：当前值需>前一个值（保证有序）
    if (T->data <= prevVal_global_bst) return false;
    prevVal_global_bst = T->data;
    // 再右子树
    return IsValidBSTHelper(T->rchild);
}

bool IsValidBST(BiTree T) {
    prevVal_global_bst = INT_MIN; // 每次调用重置
    return IsValidBSTHelper(T);
}
```

**易错点**：不能仅比较 “根> 左、根 < 右”（如`[5,1,4,NULL,NULL,6]`），需通过中序遍历验证整体有序。

#### 4. BST 的第 k 小元素（ O (n)，中序遍历）

**场景**：找到 BST 中第 `k` 小的元素（中序遍历有序，第 `k` 个元素即目标）

```c
// 辅助变量：计数和结果
int count_global_kth = 0, result_global_kth = 0;

void kthSmallestHelper(BiTree T, int k) {
    if (T == NULL) return;
    // 1. 中序遍历左子树
    kthSmallestHelper(T->lchild, k);
    // 2. 访问根，计数+1
    count_global_kth++;
    if (count_global_kth == k) {
        result_global_kth = T->data;
        return;
    }
    // 3. 中序遍历右子树
    kthSmallestHelper(T->rchild, k);
}

int KthSmallest(BiTree T, int k) {
    count_global_kth = 0; // 每次调用重置
    kthSmallestHelper(T, k);
    return result_global_kth;
}
```

**易错点**：计数变量需每次调用重置，避免多次调用相互影响。

#### 5. BST 的第 k 大元素（ O (n)，中序逆序）

**场景**：找到 BST 中第 `k` 大的元素（中序 “右→根→左” 遍历，第 `k` 个元素）

```c
int countK_global_kth = 0, resK_global_kth = 0;

void kthLargestHelper(BiTree T, int k) {
    if (T == NULL) return;
    // 1. 逆序中序：先右子树
    kthLargestHelper(T->rchild, k);
    // 2. 访问根，计数+1
    countK_global_kth++;
    if (countK_global_kth == k) {
        resK_global_kth = T->data;
        return;
    }
    // 3. 再左子树
    kthLargestHelper(T->lchild, k);
}

int KthLargest(BiTree T, int k) {
    countK_global_kth = 0; // 每次调用重置
    kthLargestHelper(T, k);
    return resK_global_kth;
}
```

**考点**：BST 删除的核心是 “保持有序性”，后继节点（右子树最小）替代后仍满足 BST 特性。

#### 6. BST 的删除节点（ O (logn)，三种情况）

**场景**：删除 BST 中值为 `key` 的节点，保持 BST 特性（比普通二叉树删除更高效）

```c
// 辅助函数：找右子树最小节点（后继）
BiTNode* findMinBST(BiTree T) {
    while (T->lchild != NULL) T = T->lchild;
    return T;
}

BiTree BST_DeleteNode(BiTree T, int key) {
    if (T == NULL) return NULL;
    // 1. 找待删除节点
    if (key < T->data) {
        T->lchild = BST_DeleteNode(T->lchild, key);
    } else if (key > T->data) {
        T->rchild = BST_DeleteNode(T->rchild, key);
    } else {
        // 2. 处理删除：三种情况
        if (T->lchild == NULL) { // 无左孩子：返回右孩子
            BiTNode *temp = T->rchild;
            free(T);
            return temp;
        } else if (T->rchild == NULL) { // 无右孩子：返回左孩子
            BiTNode *temp = T->lchild;
            free(T);
            return temp;
        }
        // 3. 有两个孩子：用右子树最小节点替代
        BiTNode *minNode = findMinBST(T->rchild);
        T->data = minNode->data; // 复制值
        T->rchild = BST_DeleteNode(T->rchild, minNode->data); // 删除后继
    }
    return T;
}
```

**考点**：BST 删除的核心是 “保持有序性”，后继节点（右子树最小）替代后仍满足 BST 特性。

#### 7. BST 的最近公共祖先（O (logn)）

**场景**：利用 BST 有序性，高效找 `p` 和 `q` 的 LCA（无需递归遍历整树）

```c
BiTNode* BST_LCA(BiTree T, BiTNode *p, BiTNode *q) {
    while (T != NULL) {
        if (p->data < T->data && q->data < T->data) {
            T = T->lchild; // 都在左子树， LCA 在左
        } else if (p->data > T->data && q->data > T->data) {
            T = T->rchild; // 都在右子树， LCA 在右
        } else {
            return T; // 分属左右或其中一个是根，当前节点是 LCA
        }
    }
    return NULL;
}
```

**优势**：时间复杂度 O (logn)（BST 高度），比普通二叉树 LCA（ O (n)）更高效，408 必考。

#### 8. BST 转化为有序双向循环链表（ O (n)）

**场景**：将 BST 转化为 “头节点前驱是尾，尾节点后继是头” 的循环双向链表

```c
BiTNode *prevCir_global_bst = NULL, *headCir_global_bst = NULL;

void BSTToCirDLLHelper(BiTree T) {
    if (T == NULL) return;
    // 1. 中序遍历左子树
    BSTToCirDLLHelper(T->lchild);
    // 2. 处理当前节点
    if (prevCir_global_bst == NULL) {
        headCir_global_bst = T; // 头节点
    } else {
        prevCir_global_bst->rchild = T;
        T->lchild = prevCir_global_bst;
    }
    prevCir_global_bst = T;
    // 3. 中序遍历右子树
    BSTToCirDLLHelper(T->rchild);
}

BiTNode* BSTToCircularDLL(BiTree T) {
    prevCir_global_bst = NULL; // 重置全局变量
    headCir_global_bst = NULL; // 重置全局变量
    BSTToCirDLLHelper(T);
    // 4. 连接头尾，形成循环
    if (headCir_global_bst != NULL) {
        headCir_global_bst->lchild = prevCir_global_bst;
        prevCir_global_bst->rchild = headCir_global_bst;
    }
    return headCir_global_bst;
}
```

**核心**：在普通双向链表基础上，最后连接头尾节点，形成循环结构。

#### 9. BST 的范围和（ O (n)）

**场景**：计算 BST 中值在 `[low, high]` 之间的所有节点值之和

```c
int rangeSum_global_bst = 0;

void rangeSumBSTHelper(BiTree T, int low, int high) {
    if (T == NULL) return;
    // 利用 BST 有序性剪枝
    if (T->data >= low) rangeSumBSTHelper(T->lchild, low, high); // 左子树可能有符合条件的
    if (T->data >= low && T->data <= high) rangeSum_global_bst += T->data; // 当前节点符合
    if (T->data <= high) rangeSumBSTHelper(T->rchild, low, high); // 右子树可能有符合条件的
}

int RangeSumBST(BiTree T, int low, int high) {
    rangeSum_global_bst = 0; // 重置全局变量
    rangeSumBSTHelper(T, low, high);
    return rangeSum_global_bst;
}
```

**核心**：BST 中序有序，最小差必在相邻节点间，无需比较所有节点对（ O (n²)）。

#### 10. BST 的最小绝对差（ O (n)）

**场景**：找到 BST 中任意两不同节点值之间的最小绝对差（中序有序，最小差在相邻节点间）

```c
int minDiff_global_bst = INT_MAX;
BiTNode *prevDiff_global_bst = NULL;

void minDiffBSTHelper(BiTree T) {
    if (T == NULL) return;
    // 1. 中序遍历左子树
    minDiffBSTHelper(T->lchild);
    // 2. 计算当前节点与前驱的差
    if (prevDiff_global_bst != NULL) {
        int diff = abs(T->data - prevDiff_global_bst->data);
        if (diff < minDiff_global_bst) minDiff_global_bst = diff;
    }
    prevDiff_global_bst = T; // 更新前驱
    // 3. 中序遍历右子树
    minDiffBSTHelper(T->rchild);
}

int GetMinimumDifference(BiTree T) {
    minDiff_global_bst = INT_MAX; // 重置全局变量
    prevDiff_global_bst = NULL;   // 重置全局变量
    minDiffBSTHelper(T);
    return minDiff_global_bst;
}
```

**核心**：BST 中序有序，最小差必在相邻节点间，无需比较所有节点对（ O (n²)）。

### 堆（优先队列）模板

堆是完全二叉树，分为大根堆（父≥子）和小根堆（父≤子），408 常考堆化、建堆、堆排序。

#### 1. 大根堆堆化（自上而下， O (logn)）

```c
// 堆用数组存储：父节点 i，左孩子 2i+1，右孩子 2i+2
void HeapifyMax(int heap[], int n, int i) {
    int largest = i; // 初始最大为父节点
    int left = 2 * i + 1; // 左孩子
    int right = 2 * i + 2; // 右孩子
    // 找父、左、右中的最大值
    if (left < n && heap[left] > heap[largest]) {
        largest = left;
    }
    if (right < n && heap[right] > heap[largest]) {
        largest = right;
    }
    // 若最大值不是父节点，交换并递归堆化
    if (largest != i) {
        int temp = heap[i];
        heap[i] = heap[largest];
        heap[largest] = temp;
        HeapifyMax(heap, n, largest); // 递归处理子树
    }
}
```

**考点**：堆化是堆操作的核心，大根堆堆化找最大值，小根堆找最小值，408 常考 “建堆” 和 “堆排序”。

#### 2. 构建大根堆（ O (n)）

```c
void BuildMaxHeap(int heap[], int n) {
    // 从最后一个非叶子节点开始（索引 n/2-1），自下而上堆化
    for (int i = n / 2 - 1; i >= 0; i--) {
        HeapifyMax(heap, n, i);
    }
}
```

**考点**：最后一个非叶子节点索引为 `n/2-1`，无需处理叶子节点（已满足堆特性），建堆时间复杂度 O (n)（非 O (nlogn)）。

#### 3. 堆排序（大根堆→升序， O (nlogn)）

```c
void HeapSort(int arr[], int n) {
    // 1. 构建大根堆
    BuildMaxHeap(arr, n);
    // 2. 依次将堆顶（最大值）交换到末尾，再堆化
    for (int i = n - 1; i > 0; i--) {
        // 堆顶（ arr[0]）与当前末尾交换
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        // 对剩余 n-i 个元素堆化（堆大小变为 i）
        HeapifyMax(arr, i, 0);
    }
}
```

**考点**：堆排序利用 “大根堆顶是最大值” 的特性，交换后堆化剩余元素，最终得到升序数组，408 常考排序算法对比（堆排序 vs 快排）。

#### 4. 小根堆的堆化（自上而下， O (logn)）

**场景**：维护小根堆（父≤子），用于 TopK、中位数等场景

```c
void HeapifyMin(int heap[], int n, int i) {
    int smallest = i; // 初始最小为父节点
    int left = 2 * i + 1; // 左孩子
    int right = 2 * i + 2; // 右孩子
    // 找父、左、右中的最小值
    if (left < n && heap[left] < heap[smallest]) {
        smallest = left;
    }
    if (right < n && heap[right] < heap[smallest]) {
        smallest = right;
    }
    // 若最小值不是父节点，交换并递归堆化
    if (smallest != i) {
        int temp = heap[i];
        heap[i] = heap[smallest];
        heap[smallest] = temp;
        HeapifyMin(heap, n, smallest);
    }
}
```

**考点**：小根堆与大根堆的堆化逻辑对称，仅比较方向不同，408 常考堆化方向。

#### 5. 堆的插入（小根堆， O (logn)）

**场景**：向小根堆插入元素，保持堆特性（自下而上调整）

```c
void HeapInsertMin(int heap[], int *size, int val) {
    // 1. 插入到堆尾
    heap[*size] = val;
    int i = *size;
    (*size)++;
    // 2. 自下而上调整（与父节点比较，小则交换）
    while (i > 0) {
        int parent = (i - 1) / 2; // 父节点索引
        if (heap[i] < heap[parent]) {
            int temp = heap[i];
            heap[i] = heap[parent];
            heap[parent] = temp;
            i = parent;
        } else {
            break; // 满足堆特性，停止调整
        }
    }
}
```

**核心**：插入后从叶子向根调整，确保父节点始终≤子节点（小根堆）。

#### 6. 堆的删除（删除堆顶，小根堆， O (logn)）

**场景**：删除小根堆的堆顶（最小值），保持堆特性（自上而下调整）

```c
void HeapDeleteTopMin(int heap[], int *size) {
    if (*size == 0) return; // 空堆
    // 1. 堆尾元素覆盖堆顶
    heap[0] = heap[*size - 1];
    (*size)--;
    // 2. 自上而下堆化
    HeapifyMin(heap, *size, 0);
}
```

**易错点**：必须用堆尾元素覆盖堆顶，避免堆结构破坏，再调用堆化函数调整。

#### 7. 最小堆实现 TopK 问题（找最大的 k 个元素， O (nlogk)）

**场景**：从 `n` 个元素中找最大的 `k` 个元素（用大小为 `k` 的最小堆，效率高于大根堆）

```c
int* TopKMax(int arr[], int n, int k, int *returnSize) {
    *returnSize = 0;
    if (k <= 0 || n == 0) return NULL;
    k = (k > n) ? n : k; // k 不能超过 n
    // 1. 构建大小为 k 的最小堆
    int *heap = (int*)malloc(k * sizeof(int));
    for (int i = 0; i < k; i++) heap[i] = arr[i];
    for (int i = k / 2 - 1; i >= 0; i--) HeapifyMin(heap, k, i);
    // 2. 遍历剩余元素，比堆顶大则替换并堆化
    for (int i = k; i < n; i++) {
        if (arr[i] > heap[0]) {
            heap[0] = arr[i];
            HeapifyMin(heap, k, 0);
        }
    }
    *returnSize = k;
    return heap;
}
```

**优势**：时间复杂度 O (nlogk)，空间 O (k)，适合 `n` 极大（如数据流）的场景，408 必考。

#### 8. 最大堆实现 TopK 问题（找最小的 k 个元素， O (nlogk)）

**场景**：从 `n` 个元素中找最小的 `k` 个元素（用大小为 `k` 的最大堆）

```c
// 先实现大根堆堆化 (此处已在前面定义，为了独立性再次包含)
void HeapifyMax_for_TopKMin(int heap[], int n, int i) {
    int largest = i;
    int left = 2*i+1, right = 2*i+2;
    if (left < n && heap[left] > heap[largest]) largest = left;
    if (right < n && heap[right] > heap[largest]) largest = right;
    if (largest != i) {
        int temp = heap[i];
        heap[i] = heap[largest];
        heap[largest] = temp;
        HeapifyMax_for_TopKMin(heap, n, largest);
    }
}

int* TopKMin(int arr[], int n, int k, int *returnSize) {
    *returnSize = 0;
    if (k <= 0 || n == 0) return NULL;
    k = (k > n) ? n : k;
    // 1. 构建大小为 k 的最大堆
    int *heap = (int*)malloc(k * sizeof(int));
    for (int i = 0; i < k; i++) heap[i] = arr[i];
    for (int i = k / 2 - 1; i >= 0; i--) HeapifyMax_for_TopKMin(heap, k, i);
    // 2. 遍历剩余元素，比堆顶小则替换并堆化
    for (int i = k; i < n; i++) {
        if (arr[i] < heap[0]) {
            heap[0] = arr[i];
            HeapifyMax_for_TopKMin(heap, k, 0);
        }
    }
    *returnSize = k;
    return heap;
}
```

**考点**：TopK 问题的核心是 “用小堆找最大 `k` 个，用大堆找最小 `k` 个”，需明确堆的选择逻辑。

#### 9. 数据流的中位数（双堆实现， O (logn)）

**场景**：动态数据流中，随时获取当前中位数（小根堆存右半部分，大根堆存左半部分）

```c
// 全局堆（小根堆存右半，大根堆存左半）
int maxHeap_global[1000], minHeap_global[1000];
int maxSize_global = 0, minSize_global = 0;

// 大根堆堆化 (此处已在前面定义，为了独立性再次包含)
void heapifyMax_global(int i) {
    int largest = i, left = 2*i+1, right = 2*i+2;
    if (left < maxSize_global && maxHeap_global[left] > maxHeap_global[largest]) largest = left;
    if (right < maxSize_global && maxHeap_global[right] > maxHeap_global[largest]) largest = right;
    if (largest != i) {
        int temp = maxHeap_global[i];
        maxHeap_global[i] = maxHeap_global[largest];
        maxHeap_global[largest] = temp;
        heapifyMax_global(largest);
    }
}

// 小根堆堆化 (此处已在前面定义，为了独立性再次包含)
void heapifyMin_global(int i) {
    int smallest = i, left = 2*i+1, right = 2*i+2;
    if (left < minSize_global && minHeap_global[left] < minHeap_global[smallest]) smallest = left;
    if (right < minSize_global && minHeap_global[right] < minHeap_global[smallest]) smallest = right;
    if (smallest != i) {
        int temp = minHeap_global[i];
        minHeap_global[i] = minHeap_global[smallest];
        minHeap_global[smallest] = temp;
        heapifyMin_global(smallest);
    }
}

// 插入数据流
void AddNum(int num) {
    // 1. 先插入大根堆（左半部分）
    maxHeap_global[maxSize_global++] = num;
    // 调整大根堆（自下而上）
    int i = maxSize_global - 1;
    while (i > 0) {
        int parent = (i-1)/2;
        if (maxHeap_global[i] > maxHeap_global[parent]) {
            int temp = maxHeap_global[i];
            maxHeap_global[i] = maxHeap_global[parent];
            maxHeap_global[parent] = temp;
            i = parent;
        } else break;
    }
    // 2. 平衡两个堆的大小（大根堆 size = 小根堆 size 或 size+1）
    if (maxSize_global - minSize_global > 1) {
        // 大根堆太大，移堆顶到小根堆
        int top = maxHeap_global[0];
        maxHeap_global[0] = maxHeap_global[--maxSize_global];
        heapifyMax_global(0);
        // 插入小根堆
        minHeap_global[minSize_global++] = top;
        i = minSize_global - 1;
        while (i > 0) {
            int parent = (i-1)/2;
            if (minHeap_global[i] < minHeap_global[parent]) {
                int temp = minHeap_global[i];
                minHeap_global[i] = minHeap_global[parent];
                minHeap_global[parent] = temp;
                i = parent;
            } else break;
        }
    }
    // 3. 确保大根堆顶 ≤ 小根堆顶
    if (maxSize_global > 0 && minSize_global > 0 && maxHeap_global[0] > minHeap_global[0]) {
        // 交换堆顶
        int temp = maxHeap_global[0];
        maxHeap_global[0] = minHeap_global[0];
        minHeap_global[0] = temp;
        // 重新堆化
        heapifyMax_global(0);
        heapifyMin_global(0);
    }
}

// 获取中位数
double FindMedian() {
    if (maxSize_global == 0) return 0.0; // 空数据流
    if (maxSize_global == minSize_global) {
        // 偶数个元素：两堆顶平均值
        return (maxHeap_global[0] + minHeap_global[0]) / 2.0;
    } else {
        // 奇数个元素：大根堆顶（左半最大）
        return (double)maxHeap_global[0];
    }
}
```

**核心**：双堆平衡策略（大根堆存左半，小根堆存右半），确保中位数可通过堆顶快速获取，408 高频难点。

#### 10. 两个大根堆的合并（ O (n+m)）

**场景**：合并两个大根堆，形成新的大根堆（先合并数组，再建堆）

```c
int* MergeTwoMaxHeaps(int heap1[], int size1, int heap2[], int size2, int *returnSize) {
    *returnSize = size1 + size2;
    if (*returnSize == 0) return NULL;
    // 1. 合并两个堆的数组
    int *mergedHeap = (int*)malloc(*returnSize * sizeof(int));
    for (int i = 0; i < size1; i++) mergedHeap[i] = heap1[i];
    for (int i = 0; i < size2; i++) mergedHeap[size1 + i] = heap2[i];
    // 2. 构建大根堆
    for (int i = (*returnSize) / 2 - 1; i >= 0; i--) {
        HeapifyMax(mergedHeap, *returnSize, i);
    }
    return mergedHeap;
}
```

---

## 三、树模板使用技巧

树算法的高效应用，核心在于 “抓准递归逻辑、善用辅助结构、依托树性优化、规避典型陷阱”。以下结合 408 考点，将模板使用技巧拆解为四大关键维度，助力快速解题。

### 一、递归终止条件：树递归的 “安全阀”

树的递归操作（遍历、构建、 LCA 等）若缺乏明确终止条件，极易陷入无限递归。需根据场景精准定义终止边界：

*   **遍历类操作（前 / 中 / 后序）**：以 “`T == NULL`” 为基础终止条件，例如前序遍历中，遇到空节点直接返回，避免后续指针访问错误。
*   **构建类操作（如前序 + 中序建树）**：需叠加 “序列长度为 0” 的终止条件，当 `preLen == 0` 或 `inLen == 0` 时返回 `NULL`，防止数组越界。
*   **LCA 问题**：终止条件更复杂，需兼顾 “`T == NULL`”（空树无祖先）和 “`T == p || T == q`”（节点自身即为祖先），确保递归能在找到目标节点时及时回溯。

这些终止条件不仅是递归的 “出口”，更是避免逻辑混乱的核心。

### 二、非递归实现：栈与队列的 “定向应用”

树的非递归操作依赖线性结构辅助，需根据遍历逻辑选择栈（DFS）或队列（BFS），并严格控制入栈 / 入队顺序：

*   **前 / 中 / 后序遍历（ DFS）**：用**栈**。
    *   **前序**：需按 “根→右→左” 入栈（栈先进后出，确保出栈为 “根→左→右”），例如遍历 1→2→3 时，先入 1，再入 3、 2，出栈顺序为 1、 2、 3。
    *   **中序**：需 “左到底再出栈”，用 `cur` 指针追踪左子树，待左子树全入栈后，出栈访问根再处理右子树。
    *   **后序**：常用双栈法，栈 1 按 “根→左→右” 入栈，栈 2 存出栈节点，最终栈 2 出栈即为 “左→右→根”。
*   **层序遍历（BFS）**：用**队列**。需注意 “先左后右” 入队以保证层序顺序，若需分层处理（如打印每层节点），还需记录 `levelSize`（当前层节点数），避免不同层节点混淆。

### 三、树性利用：简化操作的 “金钥匙”

不同树结构的特性是优化算法的关键，需针对性调用：

*   **BST**：依赖 “中序遍历有序” 特性。
    *   **验证 BST**：中序遍历需保证 “当前值 > 前值”，避免仅比较 “根 > 左、根 < 右” 的片面判断（如`[5,1,4,null,null,6]`，仅父子比较会误判为 BST）。
    *   **找 BST 第 k 小元素**：中序遍历第 `k` 次访问的节点即为目标，无需遍历整树。
    *   **范围和问题**：利用有序性剪枝（`T->data < low` 则不遍历左子树），减少无效操作。
*   **平衡二叉树**：用 “后序剪枝”。判断平衡时，后序遍历先计算左右子树高度，若某子树不平衡直接返回 -1，避免重复计算高度（暴力法 O (n²)→优化为 O (n)）。
*   **堆**：依托 “完全二叉树的数组存储”。父节点 `i` 的左子树为 `2i+1`、右子树为 `2i+2`，建堆时从 `n/2-1`（最后一个非叶子节点）自下而上堆化，无需处理叶子节点，效率更高。

### 四、易错点规避：确保代码正确的 “底线”

树算法的错误多源于细节疏忽，需重点规避三类问题：

*   **空节点判断**：是基础，所有操作（如计算树高、删除节点）前需先判断 `T == NULL`，例如求树高时，空树返回 0，避免访问 `T->lchild` 导致空指针崩溃。
*   **内存泄漏**：需关注，动态分配的节点（如构建树时 `malloc` 的节点）需在使用后 `free`，尤其递归构建场景，需在删除树或函数结束前释放，体现代码完整性。
*   **BST 验证**：需警惕 “局部有序陷阱”，仅比较父子节点无法保证整体有序，中序遍历验证有序性是唯一可靠方法，需通过全局变量记录前值，确保遍历过程严格递增。

**总结**
掌握以上技巧，可覆盖 408 树算法题 90% 以上考点。备考时需重点练习二叉树遍历的递归 / 非递归转换、 BST 特性应用、堆化操作，结合真题强化边界处理能力，即可高效应对考试。
```