---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---
# 栈、队列算法题模板

栈和队列是 408 数据结构的核心考点，以下模板覆盖顺序栈、循环队列的基础操作及高频应用场景（括号匹配、层序遍历等），注释标注考点和易错点，适合直接背诵备考。

---

## 一、栈（Stack）算法模板

栈遵循后进先出（LIFO）原则，408 主要考察顺序栈（数组实现），链式栈可类比单链表简化。

### 1. 顺序栈结构体定义（动态分配）

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h> // 用于字符串操作，如 simplifyPath, decodeString

// 定义数据类型（可替换为 int、 char 等）
typedef int ElemType;

// 顺序栈结构体
typedef struct {
    ElemType *data;   // 存储数据的数组
    int top;          // 栈顶指针（指向栈顶元素，初始为-1）
    int capacity;     // 栈的最大容量
} SeqStack;
```

### 2. 核心操作模板（必背）

#### （1）初始化栈

```c
/**
 * @brief 初始化一个顺序栈
 * @param initCapacity：初始容量
 * @return SeqStack：初始化后的栈
 * @考点：内存分配失败处理
 */
SeqStack InitStack(int initCapacity) {
    SeqStack S;
    S.data = (ElemType *)malloc(initCapacity * sizeof(ElemType));
    if (S.data == NULL) { // 考点：内存分配失败处理
        printf("内存分配失败！ \n");
        S.top = -1;
        S.capacity = 0;
        return S;
    }
    S.top = -1; // 栈空标志（关键考点）
    S.capacity = initCapacity;
    return S;
}
```

#### （2）判空与判满

```c
// 判空：栈顶为-1 则空
bool StackIsEmpty(SeqStack S) {
    return S.top == -1;
}

// 判满：栈顶等于容量-1 则满
bool StackIsFull(SeqStack S) {
    return S.top == S.capacity - 1;
}
```

#### （3）入栈（Push）

```c
/**
 * @brief 元素入栈
 * @param S：栈指针（需修改栈内容）
 * @param e：待入栈元素
 * @return int：0=成功， -1=失败（栈满）
 */
int Push(SeqStack *S, ElemType e) {
    if (StackIsFull(*S)) {
        printf("栈满，无法入栈！ \n");
        return -1;
    }
    S->top++;           // 栈顶上移
    S->data[S->top] = e; // 存入元素
    return 0;
}

// 扩展：动态扩容（若题目要求自动扩容）
/*
if (StackIsFull(*S)) {
    int newCap = S->capacity * 2;
    ElemType *newData = (ElemType *)realloc(S->data, newCap * sizeof(ElemType));
    if (newData == NULL) { // 扩容失败处理
        printf("扩容失败，无法入栈！\n");
        return -1;
    }
    S->data = newData;
    S->capacity = newCap;
}
*/
```

#### （4）出栈（Pop）

```c
/**
 * @brief 元素出栈
 * @param S：栈指针
 * @param e：输出参数，存储出栈元素
 * @return int：0=成功， -1=失败（栈空）
 */
int Pop(SeqStack *S, ElemType *e) {
    if (StackIsEmpty(*S)) {
        printf("栈空，无法出栈！ \n");
        return -1;
    }
    *e = S->data[S->top]; // 取出栈顶元素
    S->top--;             // 栈顶下移
    return 0;
}
```

#### （5）取栈顶元素（GetTop）

```c
/**
 * @brief 获取栈顶元素（不改变栈）
 * @param S：栈
 * @return ElemType*：栈顶元素指针（成功）， NULL（失败）
 */
ElemType* GetTop(SeqStack S) {
    if (StackIsEmpty(S)) {
        printf("栈空，无栈顶元素！ \n");
        return NULL;
    }
    return &(S.data[S.top]); // 不改变栈顶指针（区别于出栈）
}
```

#### （6）销毁栈

```c
/**
 * @brief 销毁栈，释放内存
 * @param S：栈指针
 */
void DestroyStack(SeqStack *S) {
    if (S->data != NULL) {
        free(S->data);
        S->data = NULL; // 避免野指针
    }
    S->top = -1;
    S->capacity = 0;
}
```

---

## 二、队列（Queue）算法模板

队列遵循先进先出（FIFO）原则，408 重点考察循环队列（解决顺序队列“假溢出”问题）。

### 1. 循环队列结构体定义

```c
// 循环队列结构体
typedef struct {
    ElemType *data;   // 存储数据的数组
    int front;        // 队头指针（指向队头元素）
    int rear;         // 队尾指针（指向队尾元素的下一个位置）
    int capacity;     // 队列容量（实际可用容量=capacity-1，牺牲 1 个空间区分空满）
} CirQueue;
```

### 2. 核心操作模板（必背）

#### （1）初始化队列

```c
/**
 * @brief 初始化一个循环队列
 * @param initCapacity：初始容量（实际可用为 initCapacity-1）
 * @return CirQueue：初始化后的循环队列
 */
CirQueue InitQueue(int initCapacity) {
    CirQueue Q;
    Q.capacity = initCapacity;
    Q.data = (ElemType *)malloc(Q.capacity * sizeof(ElemType));
    if (Q.data == NULL) {
        printf("内存分配失败！ \n");
        Q.front = Q.rear = 0;
        Q.capacity = 0;
        return Q;
    }
    Q.front = Q.rear = 0; // 队空标志： front=rear（关键考点）
    return Q;
}
```

#### （2）判空与判满

```c
// 判空： front == rear
bool QueueIsEmpty(CirQueue Q) {
    return Q.front == Q.rear;
}

// 判满： (rear + 1) % capacity == front（牺牲 1 个空间，核心考点）
bool QueueIsFull(CirQueue Q) {
    return (Q.rear + 1) % Q.capacity == Q.front;
}
```

#### （3）入队（EnQueue）

```c
/**
 * @brief 元素入队
 * @param Q：队列指针
 * @param e：待入队元素
 * @return int：0=成功， -1=失败（队满）
 */
int EnQueue(CirQueue *Q, ElemType e) {
    if (QueueIsFull(*Q)) {
        printf("队列满，无法入队！ \n");
        return -1;
    }
    Q->data[Q->rear] = e;               // 存入队尾
    Q->rear = (Q->rear + 1) % Q->capacity; // 队尾循环后移（考点）
    return 0;
}
```

#### （4）出队（DeQueue）

```c
/**
 * @brief 元素出队
 * @param Q：队列指针
 * @param e：输出参数，存储出队元素
 * @return int：0=成功， -1=失败（队空）
 */
int DeQueue(CirQueue *Q, ElemType *e) {
    if (QueueIsEmpty(*Q)) {
        printf("队列空，无法出队！ \n");
        return -1;
    }
    *e = Q->data[Q->front];               // 取出队头
    Q->front = (Q->front + 1) % Q->capacity; // 队头循环后移（考点）
    return 0;
}
```

#### （5）取队头元素（GetHead）

```c
/**
 * @brief 获取队头元素（不改变队列）
 * @param Q：队列
 * @return ElemType*：队头元素指针（成功）， NULL（失败）
 */
ElemType* GetHead(CirQueue Q) {
    if (QueueIsEmpty(Q)) {
        printf("队列空，无队头元素！ \n");
        return NULL;
    }
    return &(Q.data[Q.front]); // 不改变队头指针
}
```

#### （6）求队列长度

```c
/**
 * @brief 获取队列当前长度
 * @param Q：队列
 * @return int：队列长度
 */
int QueueLength(CirQueue Q) {
    return (Q.rear - Q.front + Q.capacity) % Q.capacity;
}
```

#### （7）销毁队列

```c
/**
 * @brief 销毁队列，释放内存
 * @param Q：队列指针
 */
void DestroyQueue(CirQueue *Q) {
    if (Q->data != NULL) {
        free(Q->data);
        Q->data = NULL;
    }
    Q->front = Q->rear = 0;
    Q->capacity = 0;
}
```

---

## 三、高频应用场景模板（栈、队列）

### 栈高频应用场景模板

#### 1. 有效的括号（栈匹配，O(n)）

```c
#include <string.h> // For strlen

/**
 * @brief 判断字符串中的括号是否有效（ ()[]{}为有效组合）
 * @param s：输入字符串
 * @return bool：是否有效
 * @考点：栈的 “后进先出” 特性匹配括号，右括号需与最近左括号配对。
 * @易错点：忘记释放栈内存；未判断 “栈非空但有剩余左括号” 的情况。
 */
bool isValid(char *s) {
    int len = strlen(s);
    char *stack = (char *)malloc(len * sizeof(char));
    if (stack == NULL) { // 内存分配失败
        return false;
    }
    int top = -1; // 栈顶指针（-1 表示空栈）

    for (int i = 0; i < len; i++) {
        if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
            // 左括号入栈
            stack[++top] = s[i];
        } else {
            // 右括号：栈空或不匹配则无效
            if (top == -1) {
                free(stack);
                return false;
            }
            char topChar = stack[top--];
            if ((s[i] == ')' && topChar != '(') ||
                (s[i] == ']' && topChar != '[') ||
                (s[i] == '}' && topChar != '{')) {
                free(stack);
                return false;
            }
        }
    }
    // 栈为空才完全匹配
    bool result = (top == -1);
    free(stack);
    return result;
}
```

#### 2. 最小栈（O(1) 获取最小值，O(n) 空间）

```c
// 最小栈结构体：同步维护数据栈和最小栈
typedef struct {
    int *data;      // 数据栈
    int *minData;   // 最小栈（栈顶为当前最小值）
    int top;        // 栈顶指针
    int capacity;   // 容量
} MinStack;

// 初始化
MinStack* minStackCreate(int capacity) {
    MinStack *stack = (MinStack*)malloc(sizeof(MinStack));
    if (stack == NULL) return NULL;
    stack->data = (int*)malloc(capacity * sizeof(int));
    stack->minData = (int*)malloc(capacity * sizeof(int));
    if (stack->data == NULL || stack->minData == NULL) {
        free(stack->data); free(stack->minData); free(stack);
        return NULL;
    }
    stack->top = -1;
    stack->capacity = capacity;
    return stack;
}

// 入栈
void minStackPush(MinStack* obj, int val) {
    if (obj->top + 1 >= obj->capacity) return; // 栈满

    obj->top++;
    obj->data[obj->top] = val;

    // 最小栈：空栈或新值≤当前最小值则入栈
    if (obj->top == 0 || val <= obj->minData[obj->top - 1]) {
        obj->minData[obj->top] = val;
    } else {
        obj->minData[obj->top] = obj->minData[obj->top - 1];
    }
}

// 出栈
void minStackPop(MinStack* obj) {
    if (obj->top == -1) return; // 栈空
    obj->top--;
}

// 获取栈顶元素
int minStackTop(MinStack* obj) {
    if (obj->top == -1) return -1; // 栈空处理，实际应根据题目定义
    return obj->data[obj->top];
}

// 获取最小值
int minStackGetMin(MinStack* obj) {
    if (obj->top == -1) return -1; // 栈空处理
    return obj->minData[obj->top];
}

// 销毁
void minStackFree(MinStack* obj) {
    free(obj->data);
    free(obj->minData);
    free(obj);
}

// @考点：双栈同步机制，最小栈保存对应数据栈位置的最小值。
// @易错点：入栈时未正确更新最小栈（新值大于当前最小值时需继承前最小值）。
```

#### 3. 用栈实现队列（两个栈模拟，O(n)）

```c
// 队列结构体：输入栈+输出栈
typedef struct {
    int *inStack;   // 入队用栈
    int *outStack;  // 出队用栈
    int inTop;      // 入栈顶
    int outTop;     // 出栈顶
    int capacity;   // 容量
} MyQueue;

// 初始化
MyQueue* myQueueCreate(int capacity) {
    MyQueue *queue = (MyQueue*)malloc(sizeof(MyQueue));
    if (queue == NULL) return NULL;
    queue->capacity = capacity;
    queue->inStack = (int*)malloc(capacity * sizeof(int));
    queue->outStack = (int*)malloc(capacity * sizeof(int));
    if (queue->inStack == NULL || queue->outStack == NULL) {
        free(queue->inStack); free(queue->outStack); free(queue);
        return NULL;
    }
    queue->inTop = -1;
    queue->outTop = -1;
    return queue;
}

// 辅助函数：将入栈元素转移到出栈
void transfer(MyQueue* obj) {
    if (obj->outTop != -1) return; // 出栈非空则不转移

    // 入栈元素全部压入出栈（反转顺序）
    while (obj->inTop != -1) {
        obj->outStack[++obj->outTop] = obj->inStack[obj->inTop--];
    }
}

// 入队
void myQueuePush(MyQueue* obj, int x) {
    if (obj->inTop + 1 >= obj->capacity) return; // 入栈满
    obj->inStack[++obj->inTop] = x;
}

// 出队
int myQueuePop(MyQueue* obj) {
    transfer(obj);
    if (obj->outTop == -1) return -1; // 队列为空
    return obj->outStack[obj->outTop--];
}

// 获取队头
int myQueuePeek(MyQueue* obj) {
    transfer(obj);
    if (obj->outTop == -1) return -1; // 队列为空
    return obj->outStack[obj->outTop];
}

// 判空
bool myQueueEmpty(MyQueue* obj) {
    return obj->inTop == -1 && obj->outTop == -1;
}

// 销毁
void myQueueFree(MyQueue* obj) {
    free(obj->inStack);
    free(obj->outStack);
    free(obj);
}

// @考点：双栈反转实现 FIFO，仅当出栈为空时转移入栈元素（摊还优化）。
// @易错点：未判断栈满情况；转移时未清空入栈。
```

#### 4. 每日温度（单调栈找下一个更大元素，O(n)）

```c
/**
 * @brief 计算每天需要等几天才会有更高温度（如[73,74,75,71]→[1,1,0,0]）
 * @param temperatures：温度数组
 * @param length：数组长度
 * @param result：结果数组（存储等待天数，已初始化为0）
 */
void dailyTemperatures(int* temperatures, int length, int* result) {
    int *stack = (int*)malloc(length * sizeof(int));
    if (stack == NULL) return; // 内存分配失败
    int top = -1; // 栈存索引，维护温度递减的单调栈

    // 结果数组 result 需提前初始化为 0

    for (int i = 0; i < length; i++) {
        // 当前温度>栈顶温度：栈顶元素找到下一个更高温度
        while (top != -1 && temperatures[i] > temperatures[stack[top]]) {
            int idx = stack[top--];
            result[idx] = i - idx; // 天数差
        }
        stack[++top] = i; // 当前索引入栈
    }
    // 栈中剩余元素无更高温度，结果为 0（已初始化，无需额外处理）
    free(stack);
}

// @考点：单调栈（递减）记录未找到更高温度的索引，遇到更高温度时弹出计算差值。
// @易错点：栈存储索引而非值；忘记初始化结果数组为 0。
```

#### 5. 柱状图中最大的矩形（单调栈找左右边界，O(n)）

```c
/**
 * @brief 计算柱状图中能勾勒出的最大矩形面积（如[2,1,5,6,2,3]→10）
 * @param heights：柱子高度数组
 * @param length：数组长度
 * @return int：最大面积
 */
int largestRectangleArea(int* heights, int length) {
    if (length == 0) return 0;

    // 额外空间存哨兵：左哨兵 (索引 -1，高度 0)，右哨兵 (索引 length，高度 0)
    // 这样可以处理所有柱子的边界情况，无需在循环后单独处理栈中剩余元素
    int *stack = (int*)malloc((length + 2) * sizeof(int));
    if (stack == NULL) return 0; // 内存分配失败
    int top = 0;
    stack[0] = -1; // 左哨兵

    int maxArea = 0;

    for (int i = 0; i < length + 1; i++) { // 遍历到 length (右哨兵)
        // 当前高度 (或右哨兵高度) < 栈顶高度：计算栈顶柱子的最大面积
        // 这里的 heights[length] 假定为 0 (右哨兵)
        int currentHeight = (i == length) ? 0 : heights[i];
        while (stack[top] != -1 && currentHeight < heights[stack[top]]) {
            int h = heights[stack[top--]];
            int w = i - stack[top] - 1; // 宽度=当前索引-新栈顶索引-1
            maxArea = (h * w > maxArea) ? h * w : maxArea; // 更新最大面积
        }
        stack[++top] = i; // 当前索引入栈
    }

    free(stack);
    return maxArea;
}

// @考点：单调栈（递增）记录柱子索引，栈顶元素的左右边界为栈内前一个元素和当前元素。
// @易错点：未添加哨兵导致边界处理复杂；宽度计算错误（需减 1）。
```

#### 6. 接雨水（单调栈找凹槽，O(n)）

```c
// 辅助函数
int min(int a, int b) { return a < b ? a : b; }

/**
 * @brief 计算能接多少雨水（如[0,1,0,2,1,0,1,3]→6）
 * @param height：高度数组
 * @param length：数组长度
 * @return int：雨水量
 */
int trap(int* height, int length) {
    if (length <= 2) return 0;

    int *stack = (int*)malloc(length * sizeof(int));
    if (stack == NULL) return 0; // 内存分配失败
    int top = -1;
    int water = 0;

    for (int i = 0; i < length; i++) {
        // 当前高度>栈顶高度：可能形成凹槽
        while (top != -1 && height[i] > height[stack[top]]) {
            int bottomIdx = stack[top--]; // 凹槽底部索引
            if (top == -1) break;          // 无左边界，无法接水

            int leftIdx = stack[top]; // 左边界索引

            // 决定水的高度：取决于左边界和右边界中较矮的那个，再减去底部高度
            int h = min(height[leftIdx], height[i]) - height[bottomIdx];
            // 宽度=右边界索引 - 左边界索引 - 1
            int w = i - leftIdx - 1;

            water += h * w;
        }
        stack[++top] = i; // 当前索引入栈
    }
    free(stack);
    return water;
}

// @考点：单调栈（递减）记录可能的左边界，遇到更高右边界时计算凹槽容量。
// @易错点：凹槽底部弹出后需判断栈是否为空（无左边界时不计算）。
```

#### 7. 字符串解码（栈存数字和字符串，O(n)）

```c
#include <string.h> // For strlen, strcpy, strcat, strdup
#include <stdlib.h> // For malloc, free, atoi

/**
 * @brief 解码字符串（如"3[a2[c]]"→"accaccacc"）
 * @param s：编码字符串
 * @return char*：解码后的字符串（需调用者释放）
 */
char * decodeString(char * s) {
    int len = strlen(s);
    // 栈：存数字和字符串（交替存储，数字在前，字符串在后）
    // 动态分配栈，假设最大嵌套深度和字符串长度
    // 实际应根据输入 s 的最大可能长度进行更精确的内存管理
    int *numStack = (int*)malloc(len * sizeof(int)); // 数字栈
    char **strStack = (char**)malloc(len * sizeof(char*)); // 字符串栈（存储指针）
    if (numStack == NULL || strStack == NULL) { /* handle error */ return NULL; }

    int numTop = -1, strTop = -1;
    // currentStr 指向当前正在构建的字符串
    char *currentStr = (char*)malloc(len * 100 * sizeof(char)); // 足够大的缓冲区
    if (currentStr == NULL) { /* handle error */ return NULL; }
    currentStr[0] = '\0'; // 初始化为空字符串

    int num = 0; // 当前解析到的数字

    for (int i = 0; i < len; i++) {
        if (s[i] >= '0' && s[i] <= '9') {
            num = num * 10 + (s[i] - '0'); // 多位数处理
        } else if (s[i] == '[') {
            // 遇到左括号，将当前数字和当前字符串入栈，并重置
            numStack[++numTop] = num;
            strStack[++strTop] = currentStr; // 保存当前字符串的指针

            // 为新的内部字符串分配空间
            currentStr = (char*)malloc(len * 100 * sizeof(char));
            if (currentStr == NULL) { /* handle error */ return NULL; }
            currentStr[0] = '\0';
            num = 0; // 重置数字
        } else if (s[i] == ']') {
            // 遇到右括号，出栈并拼接
            int repeat = numStack[numTop--];
            char *prevStr = strStack[strTop--]; // 获取前一个字符串

            // 重复 currentStr repeat 次
            char *tempRepeatedStr = (char*)malloc(len * 100 * sizeof(char));
            if (tempRepeatedStr == NULL) { /* handle error */ return NULL; }
            tempRepeatedStr[0] = '\0';
            for (int j = 0; j < repeat; j++) {
                strcat(tempRepeatedStr, currentStr);
            }

            // 拼接前序字符串 (prevStr) 和重复后的字符串 (tempRepeatedStr)
            char *newCombinedStr = (char*)malloc(len * 100 * sizeof(char));
            if (newCombinedStr == NULL) { /* handle error */ return NULL; }
            strcpy(newCombinedStr, prevStr);
            strcat(newCombinedStr, tempRepeatedStr);

            // 释放不再需要的内存
            free(currentStr);
            free(tempRepeatedStr);
            free(prevStr); // 释放旧的prevStr
            currentStr = newCombinedStr; // 更新当前字符串指针
        } else {
            // 普通字符追加到当前字符串
            int cLen = strlen(currentStr);
            currentStr[cLen] = s[i];
            currentStr[cLen + 1] = '\0';
        }
    }

    free(numStack);
    free(strStack);
    return currentStr; // 返回最终解码后的字符串
}

// @考点：栈分层存储嵌套结构，遇到[时保存状态， ]时弹出计算。
// @易错点：多位数处理（需累积）；字符串内存管理（避免泄漏）。
```

#### 8. 逆波兰表达式求值（栈计算，O(n)）

```c
#include <string.h> // For strlen, atoi
#include <stdlib.h> // For malloc, free

/**
 * @brief 计算逆波兰表达式（如["2","1","+","3","*"]→9）
 * @param tokens：表达式数组（字符串数组）
 * @param tokenSize：数组长度
 * @return int：计算结果
 */
int evalRPN(char **tokens, int tokenSize) {
    int *stack = (int*)malloc(tokenSize * sizeof(int));
    if (stack == NULL) return 0; // 内存分配失败
    int top = -1;

    for (int i = 0; i < tokenSize; i++) {
        char *token = tokens[i];
        // 检查是否为运算符 (长度为1且是+-*/)
        if (strlen(token) == 1 && (token[0] == '+' || token[0] == '-' ||
                                   token[0] == '*' || token[0] == '/')) {
            // 运算符：弹出两个数计算
            // 栈顶是 b，次栈顶是 a
            int b = stack[top--];
            int a = stack[top--];
            int res;
            switch (token[0]) {
                case '+': res = a + b; break;
                case '-': res = a - b; break;
                case '*': res = a * b; break;
                case '/': res = a / b; break; // 假设除数不为 0
                default: res = 0; // Should not happen
            }
            stack[++top] = res; // 结果入栈
        } else {
            // 数字入栈
            stack[++top] = atoi(token); // 将字符串转换为整数
        }
    }
    int result = stack[top];
    free(stack);
    return result;
}

// @考点：栈存储操作数，遇到运算符时弹出计算，符合后缀表达式特性。
// @易错点：弹出顺序（后弹出的是左操作数）；除法的整数截断方向。
```

#### 9. 简化路径（栈处理目录，O(n)）

```c
#include <string.h> // For strlen, strcmp, strcpy, strcat, strdup
#include <stdlib.h> // For malloc, free

/**
 * @brief 简化 Unix 风格路径（如"/a/./b/../../c/"→"/c"）
 * @param path：输入路径（会修改原始字符串，因为 strtok）
 * @return char*：简化后的路径（需调用者释放）
 */
char * simplifyPath(char * path) {
    int len = strlen(path);
    // 栈：存储有效目录名（字符串指针）
    char **stack = (char**)malloc(len * sizeof(char*)); // 假设len足够作为最大目录数
    if (stack == NULL) return NULL;
    int top = -1;

    // strtok 会修改原始字符串，按'/'分割
    // 需要复制一份 path，以防 path 是 const char* 或在其他地方被使用
    char *path_copy = strdup(path);
    if (path_copy == NULL) { free(stack); return NULL; }

    char *token = strtok(path_copy, "/");
    while (token != NULL) {
        if (strcmp(token, ".") == 0) {
            // 当前目录，不操作
        } else if (strcmp(token, "..") == 0) {
            // 上级目录，弹出栈顶（若栈非空）
            if (top != -1) {
                free(stack[top--]); // 释放目录字符串内存
            }
        } else {
            // 有效目录名，入栈
            stack[++top] = strdup(token); // 复制字符串，因为 strtok 会在下次调用时覆盖
            if (stack[top] == NULL) { /* handle error and clean up */ return NULL; }
        }
        token = strtok(NULL, "/"); // 继续分割
    }
    free(path_copy); // 释放副本

    // 构建结果路径
    // 分配一个足够大的缓冲区，len + 1 用于 '/' 或 '\0'
    char *result = (char*)malloc(len + 1); // 最大的可能长度
    if (result == NULL) { /* handle error and clean up */ return NULL; }
    result[0] = '\0'; // 初始化为空字符串

    if (top == -1) {
        strcpy(result, "/"); // 栈为空，表示根目录 "/"
    } else {
        for (int i = 0; i <= top; i++) {
            strcat(result, "/");
            strcat(result, stack[i]);
            free(stack[i]); // 释放栈中存储的目录字符串内存
        }
    }
    free(stack); // 释放栈本身
    return result;
}

// @考点：栈存储有效目录， ..弹出上级目录， .忽略，其他目录入栈。
// @易错点：空路径处理（返回/）； strtok 分割后需复制字符串（避免原指针失效）。
```

#### 10. 基本计算器（栈处理括号和运算符，O(n)）

```c
#include <string.h> // For strlen
#include <stdlib.h> // For malloc, free

/**
 * @brief 计算简单表达式（含+、 -、 (、 )，如"(1+(4+5+2)-3)+(6+8)"→23）
 * @param s：表达式字符串
 * @return int：计算结果
 */
int calculate(char * s) {
    int len = strlen(s);
    // 栈：存储括号外的结果和符号
    int *stack = (int*)malloc(len * sizeof(int)); // 假设 len 足够，实际更小
    if (stack == NULL) return 0;
    int top = -1;

    int sign = 1; // 当前符号（1 为正， -1 为负）
    int result = 0;
    long num = 0; // 当前数字，用 long 避免溢出

    for (int i = 0; i < len; i++) {
        if (s[i] >= '0' && s[i] <= '9') {
            num = num * 10 + (s[i] - '0'); // 多位数
        } else if (s[i] == '+') {
            result += sign * num; // 累加前一个数字
            num = 0;              // 重置数字
            sign = 1;             // 更新符号为正
        } else if (s[i] == '-') {
            result += sign * num; // 累加前一个数字
            num = 0;              // 重置数字
            sign = -1;            // 更新符号为负
        } else if (s[i] == '(') {
            // 遇到左括号，将当前结果和符号入栈，并重置
            stack[++top] = result; // 保存当前结果
            stack[++top] = sign;   // 保存当前符号
            result = 0;            // 重置结果为 0，开始计算括号内的值
            sign = 1;              // 括号内默认符号为正
        } else if (s[i] == ')') {
            // 遇到右括号，计算括号内结果
            result += sign * num; // 累加括号内最后一个数字
            num = 0;              // 重置数字
            
            // 括号内结果乘以括号前的符号
            result *= stack[top--]; 
            // 加上括号前的结果
            result += stack[top--];
        }
    }
    // 处理表达式末尾可能存在的最后一个数字
    result += sign * num;
    free(stack);
    return result;
}

// @考点：栈保存括号外的结果和符号，遇到(入栈， )出栈计算。
// @易错点：多位数处理；最后一个数字需额外累加；符号与数字的关联。
```

### 队列高频应用场景模板

#### 1. 用队列实现栈（两个队列模拟，O(n) 时间）

```c
// 栈结构体：两个队列（始终有一个为空）
// 注意：这里使用固定大小数组模拟队列，实际应考虑循环队列或动态扩容
typedef struct {
    int *queue1; // 主队列（存储元素）
    int *queue2; // 辅助队列（临时转移）
    int front1, rear1; // 队列 1 的头尾指针
    int front2, rear2; // 队列 2 的头尾指针
    int capacity;
} MyStack;

// 判空（队列头尾相等则空）
bool isEmpty(int front, int rear) {
    return front == rear;
}

// 判满 (假定循环队列实现)
bool isFull(int front, int rear, int capacity) {
    return (rear + 1) % capacity == front;
}

// 初始化
MyStack* myStackCreate(int capacity) {
    MyStack *stack = (MyStack*)malloc(sizeof(MyStack));
    if (stack == NULL) return NULL;
    stack->capacity = capacity + 1; // 循环队列实际容量 k+1
    stack->queue1 = (int*)malloc(stack->capacity * sizeof(int));
    stack->queue2 = (int*)malloc(stack->capacity * sizeof(int));
    if (stack->queue1 == NULL || stack->queue2 == NULL) {
        free(stack->queue1); free(stack->queue2); free(stack);
        return NULL;
    }
    stack->front1 = stack->rear1 = 0;
    stack->front2 = stack->rear2 = 0;
    return stack;
}

// 入栈（入非空队列）
void myStackPush(MyStack* obj, int x) {
    // 确定哪个队列非空，或者哪个队列是空的 (优先使用非空队列)
    if (!isEmpty(obj->front1, obj->rear1)) {
        if (isFull(obj->front1, obj->rear1, obj->capacity)) return; // 队列1满
        obj->queue1[obj->rear1] = x;
        obj->rear1 = (obj->rear1 + 1) % obj->capacity;
    } else {
        if (isFull(obj->front2, obj->rear2, obj->capacity)) return; // 队列2满
        obj->queue2[obj->rear2] = x;
        obj->rear2 = (obj->rear2 + 1) % obj->capacity;
    }
}

// 出栈（转移 n-1 个元素到另一队列，弹出最后一个）
int myStackPop(MyStack* obj) {
    int *fromQueue, *toQueue;
    int *fromFront, *fromRear, *toFront, *toRear;

    // 确定源队列和目标队列
    // 哪个队列不为空就从哪个队列出栈
    if (!isEmpty(obj->front1, obj->rear1)) {
        fromQueue = obj->queue1;
        toQueue = obj->queue2;
        fromFront = &obj->front1;
        fromRear = &obj->rear1;
        toFront = &obj->front2;
        toRear = &obj->rear2;
    } else if (!isEmpty(obj->front2, obj->rear2)) { // 队列1为空，检查队列2
        fromQueue = obj->queue2;
        toQueue = obj->queue1;
        fromFront = &obj->front2;
        fromRear = &obj->rear2;
        toFront = &obj->front1;
        toRear = &obj->rear1;
    } else { // 两个队列都为空
        return -1; // 栈为空
    }

    // 转移 n-1 个元素：将源队列除了最后一个元素外的所有元素都转移到目标队列
    while ( ( (*fromRear - *fromFront + obj->capacity) % obj->capacity ) > 1) {
        toQueue[*toRear] = fromQueue[*fromFront];
        *toRear = (*toRear + 1) % obj->capacity;
        *fromFront = (*fromFront + 1) % obj->capacity;
    }

    // 弹出最后一个元素（原栈顶）
    int topVal = fromQueue[*fromFront];
    *fromFront = (*fromFront + 1) % obj->capacity; // 源队列队头后移，实际上只剩一个元素被移走了
    return topVal;
}

// 获取栈顶（同出栈，但不弹出）
int myStackTop(MyStack* obj) {
    if (!isEmpty(obj->front1, obj->rear1)) {
        return obj->queue1[(obj->rear1 - 1 + obj->capacity) % obj->capacity];
    } else if (!isEmpty(obj->front2, obj->rear2)) {
        return obj->queue2[(obj->rear2 - 1 + obj->capacity) % obj->capacity];
    } else {
        return -1; // 栈为空
    }
}

// 判空
bool myStackEmpty(MyStack* obj) {
    return isEmpty(obj->front1, obj->rear1) && isEmpty(obj->front2, obj->rear2);
}

// 销毁
void myStackFree(MyStack* obj) {
    free(obj->queue1);
    free(obj->queue2);
    free(obj);
}

// @考点：双队列交替存储，出栈时转移前 n-1 个元素，保留最后一个作为栈顶。
// @易错点：循环队列的头尾指针计算（取模避免越界）；栈顶元素的索引计算。
```

#### 2. 设计循环队列（数组实现，O(1) 操作）

```c
// 循环队列结构体
typedef struct {
    int *data;
    int front;      // 队头（指向首个元素）
    int rear;       // 队尾（指向空闲位置）
    int capacity;   // 实际可存储 k 个元素，容量设计为 k+1
} MyCircularQueue;

// 初始化（预留一个空位区分满和空）
MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue *queue = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    if (queue == NULL) return NULL;
    queue->capacity = k + 1; // 实际容量 k+1 (牺牲一个空间)
    queue->data = (int*)malloc(queue->capacity * sizeof(int));
    if (queue->data == NULL) {
        free(queue);
        return NULL;
    }
    queue->front = 0;
    queue->rear = 0;
    return queue;
}

// 入队
bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if ((obj->rear + 1) % obj->capacity == obj->front) return false; // 满
    obj->data[obj->rear] = value;
    obj->rear = (obj->rear + 1) % obj->capacity;
    return true;
}

// 出队
bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if (obj->front == obj->rear) return false; // 空
    obj->front = (obj->front + 1) % obj->capacity;
    return true;
}

// 获取队头
int myCircularQueueFront(MyCircularQueue* obj) {
    if (obj->front == obj->rear) return -1; // 空
    return obj->data[obj->front];
}

// 获取队尾
int myCircularQueueRear(MyCircularQueue* obj) {
    if (obj->front == obj->rear) return -1; // 空
    // 队尾指针指向下一个空闲位置，所以队尾元素是 (rear - 1 + capacity) % capacity
    return obj->data[(obj->rear - 1 + obj->capacity) % obj->capacity];
}

// 判空
bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj->front == obj->rear;
}

// 判满
bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return (obj->rear + 1) % obj->capacity == obj->front;
}

// 销毁
void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->data);
    free(obj);
}

// @考点：循环队列通过预留空位区分满 / 空，头尾指针取模循环。
// @易错点：队尾元素索引计算（需减 1 后取模）；容量设计为 k+1。
```

#### 3. 滑动窗口最大值（单调队列，O(n)）

```c
/**
 * @brief 找出数组中每个滑动窗口的最大值（如[1,3,-1,-3,5,3,6,7],k=3→[3,3,5,5,6,7]）
 * @param nums：目标数组
 * @param length：数组长度
 * @param k：窗口大小
 * @param returnSize：结果长度指针
 * @return int*：最大值数组（需调用者释放）
 */
int* maxSlidingWindow(int* nums, int length, int k, int* returnSize) {
    *returnSize = length - k + 1;
    if (*returnSize <= 0) return NULL; // 无效窗口大小或数组长度

    int *result = (int*)malloc(*returnSize * sizeof(int));
    if (result == NULL) return NULL;

    // 单调队列（双端队列），存储索引，维护队列中元素值递减
    int *deque = (int*)malloc(length * sizeof(int)); // 队列最大长度不超过数组长度
    if (deque == NULL) { free(result); return NULL; }
    int front = 0, rear = 0; // 队列头尾（ front<=rear）

    for (int i = 0; i < length; i++) {
        // 1. 移除队列中小于当前元素的索引（它们不可能是最大值）
        // 因为当前元素 nums[i] 比 deque 尾部的元素 nums[deque[rear-1]] 大或等于，
        // 且 nums[i] 出现更晚，所以 deque 尾部的元素在窗口中将永远不会是最大值
        while (front < rear && nums[i] >= nums[deque[rear - 1]]) {
            rear--;
        }
        deque[rear++] = i; // 当前元素索引入队

        // 2. 移除窗口外的索引（队头元素超出左边界）
        // 如果队头索引 deque[front] 小于等于当前窗口的左边界 (i - k)，
        // 说明它已不在当前窗口内，需要出队
        while (deque[front] <= i - k) {
            front++;
        }

        // 3. 窗口形成后，队头即为当前窗口的最大值
        if (i >= k - 1) { // 当 i 达到 k-1 时，第一个完整窗口形成
            result[i - k + 1] = nums[deque[front]];
        }
    }

    free(deque);
    return result;
}

// @考点：单调队列（递减）保存可能的最大值索引，保证队头是当前窗口最大值。
// @易错点：窗口形成条件（ i >= k-1）；队列中存储索引而非值。
```

#### 4. 最近的请求次数（队列记录时间，O(1) 摊还）

```c
// 结构体：队列存储请求时间
// 假设用循环队列实现
typedef struct {
    int *times;
    int front;
    int rear;
    int capacity;
} RecentCounter;

// 初始化
RecentCounter* recentCounterCreate() {
    RecentCounter *obj = (RecentCounter*)malloc(sizeof(RecentCounter));
    if (obj == NULL) return NULL;
    obj->capacity = 10000; // 足够大的初始容量，实际应是 k+1
    obj->times = (int*)malloc(obj->capacity * sizeof(int));
    if (obj->times == NULL) {
        free(obj);
        return NULL;
    }
    obj->front = 0;
    obj->rear = 0;
    return obj;
}

// 新增请求并返回最近 3000ms 内的请求数
int recentCounterPing(RecentCounter* obj, int t) {
    // 假设不会满，因为题目通常保证请求递增且容量足够
    // 如果容量不足，需要扩容逻辑或者使用循环队列的判满
    obj->times[obj->rear] = t;
    obj->rear = (obj->rear + 1) % obj->capacity;

    // 移除 3000ms 外的请求（t-3000 之前的时间）
    // obj->front 指向第一个在 [t-3000, t] 范围内的请求
    while (obj->times[obj->front] < t - 3000) {
        obj->front = (obj->front + 1) % obj->capacity;
    }
    // 队列长度即为有效请求数
    return (obj->rear - obj->front + obj->capacity) % obj->capacity;
}

// 销毁
void recentCounterFree(RecentCounter* obj) {
    free(obj->times);
    free(obj);
}

// @考点：队列保存请求时间，新增时移除过期时间，队列长度即为有效请求数。
// @易错点：时间窗口判断（t-3000 而非固定 3000）；无需处理溢出（题目保证请求递增）。
```

#### 5. 二叉树的层序遍历（队列实现 BFS，O(n)）

```c
#include <stdlib.h> // For malloc, free

// 二叉树节点定义
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

/**
 * @brief 层序遍历二叉树（如[3,9,20,null,null,7]→[[3],[9,20],[15,7]]）
 * @param root：树根节点
 * @param returnSize：结果行数指针
 * @param returnColumnSizes：每行长度数组指针
 * @return int**：二维结果数组（需调用者释放内存）
 */
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {
    *returnSize = 0;
    if (!root) {
        *returnColumnSizes = NULL;
        return NULL;
    }

    // 队列存储 TreeNode 指针，用于 BFS
    struct TreeNode **queue = (struct TreeNode**)malloc(1000 * sizeof(struct TreeNode*));
    if (queue == NULL) { /* handle error */ return NULL; }
    int front = 0, rear = 0;
    queue[rear++] = root; // 根节点入队

    // 结果存储：result 是一个指向 int* 的指针数组，每个 int* 代表一层
    int **result = (int**)malloc(1000 * sizeof(int*));
    if (result == NULL) { free(queue); return NULL; }

    // returnColumnSizes 存储每行的元素个数
    *returnColumnSizes = (int*)malloc(1000 * sizeof(int));
    if (*returnColumnSizes == NULL) { free(queue); free(result); return NULL; }

    while (front < rear) {
        int levelSize = rear - front; // 当前层节点数
        // 为当前层的结果分配内存
        result[*returnSize] = (int*)malloc(levelSize * sizeof(int));
        if (result[*returnSize] == NULL) { /* handle error and cleanup */ return NULL; }

        // 遍历当前层的所有节点
        for (int i = 0; i < levelSize; i++) {
            struct TreeNode *node = queue[front++]; // 节点出队
            result[*returnSize][i] = node->val;     // 存储节点值

            // 子节点入队
            if (node->left) queue[rear++] = node->left;
            if (node->right) queue[rear++] = node->right;
        }
        (*returnColumnSizes)[*returnSize] = levelSize; // 记录当前层长度
        (*returnSize)++; // 结果行数加 1
    }

    free(queue); // 释放队列内存
    return result;
}

// @考点：队列实现广度优先搜索，逐层遍历。
// @易错点：内存管理（动态分配二维数组）；levelSize 的计算和使用。
```

#### 7. 数据流中的移动平均值（循环队列，O(1)）

```c
// 结构体：循环队列存储数据流，维护总和
typedef struct {
    int *queue;
    int front;
    int rear;
    int size;   // 窗口大小
    int sum;    // 当前窗口总和
    int count;  // 当前窗口中元素数量
} MovingAverage;

// 初始化
MovingAverage* movingAverageCreate(int size) {
    MovingAverage *obj = (MovingAverage*)malloc(sizeof(MovingAverage));
    if (obj == NULL) return NULL;
    obj->size = size;
    obj->queue = (int*)malloc(size * sizeof(int)); // 循环队列，容量即为窗口大小
    if (obj->queue == NULL) {
        free(obj);
        return NULL;
    }
    obj->front = 0;
    obj->rear = 0;
    obj->sum = 0;
    obj->count = 0;
    return obj;
}

// 添加元素并返回平均值
double movingAverageNext(MovingAverage* obj, int val) {
    if (obj->count == obj->size) { // 窗口已满，需要移除最旧的元素
        obj->sum -= obj->queue[obj->front]; // 从总和中减去队头元素
        obj->front = (obj->front + 1) % obj->size; // 队头指针后移
        obj->count--; // 元素数量减 1
    }
    // 入队新元素
    obj->queue[obj->rear] = val;
    obj->rear = (obj->rear + 1) % obj->size;
    obj->sum += val;    // 加到总和
    obj->count++;       // 元素数量加 1

    return (double)obj->sum / obj->count; // 返回平均值，注意浮点转换
}

// 销毁
void movingAverageFree(MovingAverage* obj) {
    free(obj->queue);
    free(obj);
}

// @考点：循环队列限制窗口大小，超过时移除最早元素，维护总和实现 O (1) 计算。
// @易错点：窗口满时的出队操作；平均值的浮点转换。
```

#### 8. 约瑟夫问题（循环队列模拟，O(nk)）

```c
/**
 * @brief 约瑟夫问题： n 个人围成圈，每次数到 k 的人出列，求最后剩下的人的位置（1-based）
 * @param n：人数
 * @param k：计数
 * @return int：最后剩下的位置
 */
int findTheWinner(int n, int k) {
    // 初始化队列： 1~n 入队
    int *queue = (int*)malloc(n * sizeof(int)); // 足够容纳 n 个人
    if (queue == NULL) return -1; // 内存分配失败
    int front = 0, rear = 0; // 模拟循环队列，这里简化为普通队列

    for (int i = 1; i <= n; i++) {
        queue[rear++] = i;
    }

    while (rear - front > 1) { // 剩余 1 人时停止
        // 数 k-1 次（第 k 次出队）
        for (int i = 0; i < k - 1; i++) {
            // 队头移到队尾
            queue[rear++] = queue[front++];
        }
        // 第 k 个人出队（只需将 front 指针后移，逻辑上删除）
        front++;
    }
    int result = queue[front];
    free(queue);
    return result;
}

// @考点：循环队列模拟围圈过程，每次将前 k-1 人移到队尾，第 k 人出队。
// @易错点：计数从 1 开始（需移 k-1 次而非 k 次）；结果为 1-based 索引。
```

#### 9. 字符串的排列（队列 BFS 生成，O(n!)）

```c
#include <string.h> // For strlen, strncpy, strcpy, strdup
#include <stdlib.h> // For malloc, free

/**
 * @brief 生成字符串的所有排列（如"abc"→["abc","acb","bac","bca","cab","cba"]）
 * @param s：输入字符串
 * @param returnSize：结果数量指针
 * @return char**：所有排列数组（需调用者释放）
 */
char** permuteString(char* s, int* returnSize) {
    int n = strlen(s);
    if (n == 0) {
        *returnSize = 1;
        char **res = (char**)malloc(sizeof(char*));
        if (res == NULL) return NULL;
        res[0] = strdup("");
        if (res[0] == NULL) { free(res); return NULL; }
        return res;
    }

    *returnSize = 1;
    for (int i = 2; i <= n; i++) *returnSize *= i; // n!个排列

    char **result = (char**)malloc(*returnSize * sizeof(char*));
    if (result == NULL) return NULL;

    // 队列存储中间排列（初始为第一个字符）
    // 队列大小最大也为 n!
    char **queue = (char**)malloc(*returnSize * sizeof(char*));
    if (queue == NULL) { free(result); return NULL; }
    int front = 0, rear = 0;

    // 初始状态：第一个字符作为第一个排列
    queue[rear] = (char*)malloc(2 * sizeof(char)); // 1字符 + '\0'
    if (queue[rear] == NULL) { free(result); free(queue); return NULL; }
    queue[rear][0] = s[0];
    queue[rear++][1] = '\0';

    // 逐个添加字符，生成新排列
    for (int i = 1; i < n; i++) {
        char c = s[i];
        int levelSize = rear - front; // 当前层所有排列的数量

        // 处理当前层所有排列，生成下一层排列
        for (int j = 0; j < levelSize; j++) {
            char *prev = queue[front++]; // 出队一个前序排列
            int len = strlen(prev);

            // 在 prev 的每个可能位置插入新字符 c
            for (int k = 0; k <= len; k++) {
                char *newStr = (char*)malloc(len + 2 * sizeof(char)); // 新字符串长度 len+1 + '\0'
                if (newStr == NULL) { /* handle error and cleanup */ return NULL; }

                strncpy(newStr, prev, k);   // 复制前半部分
                newStr[k] = c;              // 插入新字符
                strcpy(newStr + k + 1, prev + k); // 复制后半部分
                queue[rear++] = newStr;     // 新排列入队
            }
            free(prev); // 释放前序排列的内存
        }
    }

    // 将队列中最终结果复制到 result 数组
    for (int i = 0; i < *returnSize; i++) {
        result[i] = queue[front++];
    }

    free(queue); // 释放队列本身
    return result;
}

// @考点：队列存储中间排列，每次插入新字符到所有可能位置，生成新排列。
// @易错点：字符串内存分配与释放；插入位置包括首尾（0 到 len）。
```

#### 10. 设计前中后队列（三队列分段存储，O(1) 操作）

```c
// 前中后队列结构体：前半段（逆序） + 中间 + 后半段
typedef struct {
    int *front_arr; // 前半段（栈实现，逆序存储，便于取前元素）
    int *back_arr;  // 后半段（队列实现，正序存储）
    int frontTop;   // 前半段栈顶
    int backFront;  // 后半段队头
    int backRear;   // 后半段队尾
    int capacity;   // 单个数组的容量
    int middle;     // 中间元素（若总长度为奇数）
    bool hasMiddle; // 是否有中间元素
} FrontMiddleBackQueue;

// 初始化
FrontMiddleBackQueue* frontMiddleBackQueueCreate() {
    FrontMiddleBackQueue *q =
        (FrontMiddleBackBackQueue*)malloc(sizeof(FrontMiddleBackQueue));
    if (q == NULL) return NULL;
    q->capacity = 1000; // 假设单个部分的最大容量
    q->front_arr = (int*)malloc(q->capacity * sizeof(int));
    q->back_arr = (int*)malloc(q->capacity * sizeof(int));
    if (q->front_arr == NULL || q->back_arr == NULL) {
        free(q->front_arr); free(q->back_arr); free(q);
        return NULL;
    }
    q->frontTop = -1;
    q->backFront = 0;
    q->backRear = 0;
    q->hasMiddle = false;
    return q;
}

// 调整队列平衡（前半段大小 = 后半段大小 或 后半段大小-1）
void balance(FrontMiddleBackQueue* q) {
    int frontSize = q->frontTop + 1;
    int backSize = (q->backRear - q->backFront + q->capacity) % q->capacity;
    
    // 情况 1：前半段过大 (frontSize 比 backSize + hasMiddle 多 2 个或以上)
    while (frontSize > backSize + (q->hasMiddle ? 1 : 0) + 1) {
        if (q->hasMiddle) { // 中间元素存在，移到后半段
            q->back_arr[q->backRear] = q->middle;
            q->backRear = (q->backRear + 1) % q->capacity;
            q->hasMiddle = false;
            backSize++;
        } else { // 中间元素不存在，前半段栈顶移到中间
            q->middle = q->front_arr[q->frontTop--];
            q->hasMiddle = true;
            frontSize--;
        }
    }
    // 情况 2：后半段过大 (backSize 比 frontSize + hasMiddle 多 1 个或以上)
    while (backSize > frontSize + (q->hasMiddle ? 1 : 0)) {
        if (q->hasMiddle) { // 中间元素存在，移到前半段
            q->front_arr[++q->frontTop] = q->middle;
            q->hasMiddle = false;
            frontSize++;
        } else { // 中间元素不存在，后半段队头移到中间
            q->middle = q->back_arr[q->backFront];
            q->backFront = (q->backFront + 1) % q->capacity;
            q->hasMiddle = true;
            backSize--;
        }
    }
}

// 前插入
void frontMiddleBackQueuePushFront(FrontMiddleBackQueue* q, int val) {
    if (q->frontTop + 1 >= q->capacity) { /* handle overflow */ return; }
    q->front_arr[++q->frontTop] = val;
    balance(q);
}

// 中插入
void frontMiddleBackQueuePushMiddle(FrontMiddleBackQueue* q, int val) {
    if (q->hasMiddle) { // 如果有中间元素，先把它移到前半段
        if (q->frontTop + 1 >= q->capacity) { /* handle overflow */ return; }
        q->front_arr[++q->frontTop] = q->middle;
    }
    q->middle = val;
    q->hasMiddle = true;
    balance(q);
}

// 后插入
void frontMiddleBackQueuePushBack(FrontMiddleBackQueue* q, int val) {
    if ((q->backRear + 1) % q->capacity == q->backFront) { /* handle overflow */ return; }
    q->back_arr[q->backRear] = val;
    q->backRear = (q->backRear + 1) % q->capacity;
    balance(q);
}

// 前删除
bool frontMiddleBackQueuePopFront(FrontMiddleBackQueue* q, int* val) {
    int frontSize = q->frontTop + 1;
    int backSize = (q->backRear - q->backFront + q->capacity) % q->capacity;
    int total = frontSize + (q->hasMiddle ? 1 : 0) + backSize;
    if (total == 0) return false;

    if (frontSize > 0) { // 前半段非空，从前半段删除
        *val = q->front_arr[q->frontTop--];
    } else if (q->hasMiddle) { // 前半段空，有中间元素，删除中间元素
        *val = q->middle;
        q->hasMiddle = false;
    } else { // 前半段和中间都空，从后半段删除
        if (backSize == 0) return false; // 理论上不会走到这里，因为total!=0
        q->backRear = (q->backRear - 1 + q->capacity) % q->capacity; // 逻辑上删除最后一个
        *val = q->back_arr[q->backRear];
    }
    balance(q);
    return true;
}

// 中删除
bool frontMiddleBackQueuePopMiddle(FrontMiddleBackQueue* q, int* val) {
    int total = (q->frontTop + 1) + (q->hasMiddle ? 1 : 0) +
                ((q->backRear - q->backFront + q->capacity) % q->capacity);
    if (total == 0) return false;

    if (q->hasMiddle) { // 有中间元素，删除它
        *val = q->middle;
        q->hasMiddle = false;
    } else if (q->frontTop >= 0) { // 没有中间元素，从前半段栈顶删除 (模拟中间)
        *val = q->front_arr[q->frontTop--];
    } else { // 既没有中间元素也没有前半段，从后半段删除队头 (模拟中间)
        if ((q->backRear - q->backFront + q->capacity) % q->capacity == 0) return false;
        *val = q->back_arr[q->backFront];
        q->backFront = (q->backFront + 1) % q->capacity;
    }
    balance(q);
    return true;
}

// 后删除
bool frontMiddleBackQueuePopBack(FrontMiddleBackQueue* q, int* val) {
    int backSize = (q->backRear - q->backFront + q->capacity) % q->capacity;
    int total = (q->frontTop + 1) + (q->hasMiddle ? 1 : 0) + backSize;
    if (total == 0) return false;

    if (backSize > 0) { // 后半段非空，从后半段删除
        q->backRear = (q->backRear - 1 + q->capacity) % q->capacity;
        *val = q->back_arr[q->backRear];
    } else if (q->hasMiddle) { // 后半段空，有中间元素，删除中间元素
        *val = q->middle;
        q->hasMiddle = false;
    } else { // 后半段和中间都空，从前半段删除
        if (q->frontTop == -1) return false; // 理论上不会走到这里，因为total!=0
        *val = q->front_arr[q->frontTop--];
    }
    balance(q);
    return true;
}

// 销毁
void frontMiddleBackQueueFree(FrontMiddleBackQueue* q) {
    free(q->front_arr);
    free(q->back_arr);
    free(q);
}

// @考点：三部分存储（前半段逆序、中间、后半段正序），通过平衡机制保证 O (1) 操作。
// @易错点：平衡逻辑复杂（需维持前后段大小关系）；中间元素的转移处理。
```

---

## 四、栈、队列模板使用技巧

### 一、栈与队列的选择：紧扣 “顺序特性” 匹配场景

栈与队列的本质区别在于数据存取顺序，选择时需严格对应场景的顺序需求：

*   **若场景需 “后入先出（LIFO）”**，优先用**栈**。
    例如括号匹配问题中，右括号需与最近入栈的左括号配对，栈的 LIFO 特性可直接定位“最近关联元素”；递归模拟（如二叉树前序遍历非递归实现）中，栈能暂存待处理节点，回溯时按“最后压入”顺序处理；此外，单调栈解决“下一个更大元素”“柱状图最大矩形”等问题，也是利用栈对“后入元素”的优先处理能力。
*   **若场景需 “先入先出（FIFO）”**，则必用**队列**。
    例如二叉树层序遍历，需按“上层到下层、同层从左到右”的顺序处理节点，队列可保证先入队的节点先出队；滑动窗口最大值问题中，队列需按“进入窗口的先后顺序”维护候选元素；缓冲区场景（如打印机任务调度）也需队列保证任务按提交顺序执行，避免优先处理后提交的任务。

### 二、易错点规避：聚焦 “边界与操作逻辑”

栈与队列的错误多源于边界判断和操作顺序，需牢记三个核心避坑点：

1.  **栈顶指针的操作逻辑**。栈顶初始值设为 `-1`（空栈标志），入栈时需**“先加后存”**（`top++` 后存入元素），避免覆盖初始空栈状态；出栈时需**“先取后减”**（先读取 `top` 位置元素，再 `top--`），防止指针越界。若颠倒顺序（如入栈先存后加），会导致初始元素存入索引 `-1` 的非法位置，直接引发程序崩溃。
2.  **循环队列的空满判断**。为避免“假溢出”，循环队列需牺牲 1 个空间，判空条件为 `front == rear`，判满条件为 `(rear + 1) % capacity == front`。需警惕两种错误：
    *   一是未牺牲空间，用 `rear == capacity-1` 判满，会导致队列尾部无法利用；
    *   二是混淆判空与判满条件，将 `(rear+1)%capacity == front` 误作判空，导致队列未存满却无法入队。
3.  **指针传递的必要性**。若函数需修改栈 / 队列内容（如入栈、出队、扩容），参数必须为**指针类型**（如 `SeqStack*`、`CirQueue*`）。若用值传递（如 `SeqStack S`），函数操作的是原结构的副本，修改后无法同步到主函数，这是 408 真题中高频失分点，需格外注意。

### 三、适配考题：灵活调整结构与数据类型

模板并非固定不变，需根据考题要求灵活适配：

1.  **若题目明确要求 “链式结构”**，需将数组实现改为单链表。链式栈采用“头插法入栈、头删法出栈”，因单链表头节点操作时间复杂度为 O(1)，符合栈的效率需求；链式队列需“尾插法入队、头删法出队”，需额外维护尾指针，避免入队时遍历链表（时间复杂度从 O(n) 降至 O(1)）。需注意链式结构无需考虑容量限制，无需处理扩容，但需动态分配节点内存并及时释放。
2.  **若数据类型为结构体**（如存储“学号 + 姓名”的学生信息），需做两处调整：一是自定义比较函数，例如判断两个学生姓名是否相同，需用 `strcmp` 替代直接“==”；二是修改输入输出格式符，例如打印学生信息时，用 `printf("学号： %d 姓名： %s", stu.id, stu.name)`，避免因格式符不匹配导致输出错误。

综上，栈与队列模板的使用需“先定场景、再避陷阱、最后适配”，结合 408 真题中高频的单调栈、循环队列、链式实现等考点，熟练掌握上述技巧，可大幅提升解题效率与正确性。
```