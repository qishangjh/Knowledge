---
tags:
---

# 暴力解法模板 - 树

## 核心思想

树的暴力解法本质上是**完全遍历策略**，通过递归或迭代的方式访问树的每个结点，对每个结点执行问题特定的操作。这种方法虽然在时间复杂度上可能不是最优的，但具有逻辑清晰、实现简单、正确性易验证的优势。

### 常用树节点结构定义

在下面的实例中，假设树节点通常定义如下：

```c
// 假设树节点定义 (通常为二叉树节点)
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 如果涉及到其他类型的树或额外字段，会根据题目调整
```

## 暴力解法通用模板

### 1. 树结构验证类问题

*   **适用场景**：二叉搜索树验证、平衡树判断、完全二叉树判断、对称二叉树判断等。
*   **核心策略**：递归验证每个结点的局部性质，通过约束条件传递维护全局性质。

```c
// 结构验证模板
// ConstraintType 可能是 int, long long, bool 或自定义结构
bool validateTree(TreeNode* root, ConstraintType minConstraint, ConstraintType maxConstraint) {
    if (root == NULL) return true; // 空树通常视为满足条件

    // 验证当前结点约束条件 (根据具体问题实现 satisfyConstraint 函数)
    // 例如：对于 BST，检查 root->val 是否在 (minConstraint, maxConstraint) 之间
    // if (!satisfyConstraint(root->val, minConstraint, maxConstraint)) {
    //     return false;
    // }

    // 递归验证子树，更新约束条件
    // 对于 BST 验证，左子树的最大值变为 root->val，右子树的最小值变为 root->val
    // return validateTree(root->left, minConstraint, root->val) &&
    //        validateTree(root->right, root->val, maxConstraint);
    return true; // 占位符
}
```

### 2. 树的统计计算类问题

*   **适用场景**：带权路径长度计算、结点统计、深度计算、路径和、直径等。
*   **核心策略**：递归计算子问题结果，通过合并函数得到当前问题的解。

```c
// 统计计算模板
// currentLevel 可以是当前深度、当前路径和等
int calculateTreeMetric(TreeNode* root, int currentLevel) {
    if (root == NULL) return 0; // 根据问题返回0、最小值或特定值

    // 叶结点处理 (如果问题有特殊要求)
    // if (isLeafNode(root)) {
    //     return calculateLeafValue(root, currentLevel);
    // }

    // 递归计算子树结果
    int leftResult = calculateTreeMetric(root->left, currentLevel + 1);
    int rightResult = calculateTreeMetric(root->right, currentLevel + 1);

    // 合并结果 (根据左右子树结果和当前节点自身信息，计算当前节点的结果)
    // return combineResults(leftResult, rightResult, root, currentLevel);
    return leftResult + rightResult + 1; // 占位符，例如计算节点总数
}
```

### 3. 树遍历与转换类问题

*   **适用场景**：表达式树转中缀/后缀表达式、树的序列化、结构转换（如翻转、合并、重排）等。
*   **核心策略**：按照特定遍历顺序（前序、中序、后序、层序）访问结点，根据结点类型执行不同的处理逻辑。

```c
// 遍历转换模板
// OutputBuffer 可能是 char* 字符串，或其他数据结构用于收集结果
void traverseAndConvert(TreeNode* root, OutputBuffer* result) {
    if (root == NULL) return;

    // 前序位置处理 (Pre-order)
    // if (needPreProcess(root)) {
    //     preProcess(root, result);
    // }

    // 递归处理左子树
    traverseAndConvert(root->left, result);

    // 中序位置处理 (In-order)
    // if (needInOrderProcess(root)) {
    //     inOrderProcess(root, result);
    // }

    // 递归处理右子树
    traverseAndConvert(root->right, result);

    // 后序位置处理 (Post-order)
    // if (needPostProcess(root)) {
    //     postProcess(root, result);
    // }
}
```

## 暴力解法优化策略

暴力解法往往可以通过以下方式进行优化：

*   **剪枝策略**：减少不必要的递归调用，提前终止不符合条件的搜索路径。
*   **记忆化搜索 (Memoization)**：避免重复计算相同子问题，通常通过哈希表或数组存储中间结果。
*   **迭代替代递归**：使用栈或队列模拟递归，减少函数调用开销，避免栈溢出。
*   **特殊性质利用**：针对特定树结构（如二叉搜索树、完全二叉树）的特性，设计更高效的算法。

通过掌握这些暴力解法模板，可以为 408 考研中的树相关算法题提供坚实的解题基础，同时为进一步的算法优化奠定理论基础。

---

## 模板使用实例 - 树

### 题目 1：二叉树路径和验证（结构验证类）

**问题描述**：给定一棵二叉树和一个目标值 `target`，判断是否存在从根节点到叶子节点的路径，使得路径上所有节点值的和等于 `target`。

**问题形式化描述**：
*   输入：二叉树根节点 `root`，目标值 `target`
*   输出：存在路径和等于 `target` 返回 `true`，否则返回 `false`
*   约束：节点值可为负数，路径必须从根到叶

**暴力解法思路**：递归验证每条路径，累加当前路径和，到达叶节点时判断是否等于 `target`。

```c
#include <stdbool.h> // For bool type
#include <stdlib.h>  // For NULL

// 假设 TreeNode 结构已定义
// typedef struct TreeNode {
//     int val;
//     struct TreeNode *left;
//     struct TreeNode *right;
// } TreeNode;

bool hasPathSum(TreeNode* root, int target) {
    if (root == NULL) {
        // 如果当前节点为空，且它不是根节点（即是从非叶子节点往下走到的空），
        // 那么这条路径不合法，返回 false。
        // 特殊情况：如果根节点本身是 NULL，则直接返回 false。
        return false;
    }

    // 叶节点：检查路径和是否等于 target
    if (root->left == NULL && root->right == NULL) {
        return root->val == target; // 到达叶子节点，判断当前节点值是否等于剩余的 target
    }

    // 递归检查左右子树，更新目标值
    int newTarget = target - root->val; // 目标值减去当前节点值
    // 只要左子树或右子树存在一条满足条件的路径，就返回 true
    return hasPathSum(root->left, newTarget) ||
           hasPathSum(root->right, newTarget);
}
```

### 2. 题目 2：二叉树镜像判断（结构验证类）

**问题描述**：判断一棵二叉树是否是镜像对称的（即左右子树互为镜像）。

**问题形式化描述**：
*   输入：二叉树根节点 `root`
*   输出：树是镜像对称返回 `true`，否则返回 `false`
*   约束：空树视为对称

**暴力解法思路**：递归比较左右子树的镜像结构，左子树的左孩子对应右子树的右孩子，左子树的右孩子对应右子树的左孩子。

```c
#include <stdbool.h> // For bool type
#include <stdlib.h>  // For NULL

// 假设 TreeNode 结构已定义

// 辅助函数：判断两棵树是否镜像
bool isMirror(TreeNode* left, TreeNode* right) {
    // 两个节点都为空，视为对称
    if (left == NULL && right == NULL) return true;
    // 只有一个节点为空，不对称
    if (left == NULL || right == NULL) return false;

    // 验证当前节点值相等且子树镜像对称
    // 左子树的左孩子 与 右子树的右孩子 互为镜像
    // 左子树的右孩子 与 右子树的左孩子 互为镜像
    return (left->val == right->val) &&
           isMirror(left->left, right->right) &&
           isMirror(left->right, right->left);
}

bool isSymmetric(TreeNode* root) {
    if (root == NULL) return true; // 空树视为对称
    return isMirror(root->left, root->right); // 从根节点的左右子树开始比较
}
```

### 3. 题目 3：二叉树转括号表示（遍历转换类）

**问题描述**：将二叉树转换为带括号的字符串表示，格式为 `"节点值(左子树)(右子树)"`，空子树省略括号。

**问题形式化描述**：
*   输入：二叉树根节点 `root`
*   输出：括号表示的字符串
*   约束：仅当右子树存在且左子树为空时，左子树保留空括号 `()`

**暴力解法思路**：先序遍历，根据左右子树存在情况决定括号输出规则。

```c
#include <stdlib.h> // For malloc, NULL
#include <stdio.h>  // For sprintf
#include <string.h> // For strcat, strlen

// 假设 TreeNode 结构已定义

// 注意：result 字符串需要足够大，并且需要由调用者管理内存
void tree2strHelper(TreeNode* root, char* result) {
    if (root == NULL) return;

    // 添加当前节点值
    char temp[20]; // 足够存储 int 值的字符串表示
    sprintf(temp, "%d", root->val);
    strcat(result, temp);

    // 处理子树括号
    if (root->left != NULL || root->right != NULL) { // 只要有子树，就至少有左括号
        strcat(result, "(");
        tree2strHelper(root->left, result); // 递归处理左子树
        strcat(result, ")");

        // 仅当右子树存在时，才需要处理右子树的括号
        if (root->right != NULL) {
            strcat(result, "(");
            tree2strHelper(root->right, result); // 递归处理右子树
            strcat(result, ")");
        }
    }
}

char* tree2str(TreeNode* root) {
    // 分配一个足够大的缓冲区，这里假设最大字符串长度为 10000
    // 实际应根据树的节点数和节点值范围动态计算或调整
    char* result = (char*)malloc(10000 * sizeof(char));
    if (result == NULL) return NULL; // 内存分配失败
    result[0] = '\0'; // 初始化为空字符串

    tree2strHelper(root, result);
    return result;
}
```

### 4. 题目 4：二叉搜索树最小差值（统计计算类）

**问题描述**：给定一棵二叉搜索树，找出树中任意两个不同节点值之间的最小差值。

**问题形式化描述**：
*   输入：二叉搜索树根节点 `root`
*   输出：最小节点值差值
*   约束：树至少包含 2 个节点

**暴力解法思路**：中序遍历得到有序序列，然后计算相邻元素的最小差值。二叉搜索树中序遍历的结果是一个升序序列。

```c
#include <limits.h> // For INT_MAX
#include <stdlib.h> // For NULL

// 假设 TreeNode 结构已定义

// 辅助函数：中序遍历收集所有节点值
// values 数组需要足够大，index 用于记录当前已收集的元素数量
void inorderTraversal(TreeNode* root, int* values, int* index) {
    if (root == NULL) return;

    inorderTraversal(root->left, values, index);

    // 收集当前节点值，并增加索引
    // 需确保 values 数组有足够的空间
    values[(*index)++] = root->val;

    inorderTraversal(root->right, values, index);
}

int getMinimumDifference(TreeNode* root) {
    // 假设树中最多有 10000 个节点
    int values[10000];
    int index = 0; // 用于记录 values 数组的当前填充位置

    // 中序遍历收集所有值到 values 数组中
    inorderTraversal(root, values, &index);

    // 计算相邻元素最小差值
    int minDiff = INT_MAX; // 初始化为最大整数值
    for (int i = 1; i < index; i++) {
        int diff = values[i] - values[i - 1];
        if (diff < minDiff) {
            minDiff = diff;
        }
    }
    return minDiff;
}
```

### 5. 题目 5：完全二叉树节点计数（顺序存储类）

**问题描述**：给定一棵完全二叉树的顺序存储数组，计算树中节点总数。

**问题形式化描述**：
*   输入：完全二叉树的顺序存储数组 `arr`， `-1` 表示空节点
*   输出：树中实际节点个数
*   约束：数组按层序存储，空位用 `-1` 填充

**暴力解法思路**：遍历数组统计非 `-1` 元素个数。或者通过递归方式，利用数组索引计算子节点。

```c
#include <stdlib.h> // For NULL

// 假设 SequentialTree 结构已定义
typedef struct {
    int* nodes; // 指向存储节点的数组
    int size;   // 数组的实际大小
} SequentialTree;

// 解法一：遍历数组统计非-1元素
int countNodes(SequentialTree tree) {
    int count = 0;
    for (int i = 0; i < tree.size; i++) {
        if (tree.nodes[i] != -1) { // 检查是否为有效节点 (非空)
            count++;
        }
    }
    return count;
}

// 解法二：递归方式统计指定子树节点数 (基于数组索引)
// 这种方式更接近树的递归遍历思想
int countSubtreeNodes(SequentialTree tree, int index) {
    // 递归终止条件：
    // 1. 索引超出数组范围
    // 2. 当前位置的节点为空 (-1)
    if (index >= tree.size || tree.nodes[index] == -1) {
        return 0;
    }

    // 计算左右子节点的索引
    int leftChild = 2 * index + 1;
    int rightChild = 2 * index + 2;

    // 当前节点自身算1个，加上左子树和右子树的节点数
    return 1 + countSubtreeNodes(tree, leftChild) +
               countSubtreeNodes(tree, rightChild);
}

// 要使用递归方式，可以这样调用：
// int totalNodes = countSubtreeNodes(mySequentialTree, 0); // 从根节点索引 0 开始
```

---

## 模板使用练习 - 树

### 一、结构验证类（判断树的结构或特性是否符合特定定义）

1.  二叉搜索树验证
2.  完全二叉树判断
3.  平衡二叉树验证
4.  对称二叉树判断 (已在实例中提供)
5.  满二叉树验证
6.  根到叶路径存在判断 (已在实例中提供，路径和变是否存在)
7.  相同二叉树判断
8.  单值二叉树判断 (所有节点值都相同)

### 二、遍历转换类（基于遍历过程的结果转换或树结构转换）

1.  表达式树转后缀表达式
2.  二叉树序列化 (将树结构转换为字符串或数组)
3.  二叉树镜像转换 (原地修改树结构，使其变为镜像)
4.  中序遍历转数组 (已在实例中提供作为辅助函数)
5.  二叉树层序遍历 (广度优先遍历)
6.  二叉树前序遍历 (将结果收集到数组或列表中)
7.  二叉树后序遍历 (将结果收集到数组或列表中)
8.  二叉树所有路径 (返回所有从根到叶的路径字符串或列表)
9.  翻转二叉树
10. 二叉树右视图 (从右侧看到的节点序列)
11. 合并二叉树 (将两棵二叉树叠加合并)

### 三、统计计算类（计算树的数值特征或统计量）

1.  二叉树最大路径和 (任意两个节点间的路径和)
2.  二叉树的最大深度
3.  叶子结点路径和 (所有根到叶路径的和)
4.  二叉树结点个数统计 (已在实例中提供)
5.  二叉搜索树最小差值 (已在实例中提供)
6.  二叉树直径计算 (任意两个节点之间最长路径的长度)
7.  二叉树最小深度
8.  左叶子结点之和
9.  二叉搜索树范围和 (给定范围 [L, R] 内所有节点值的和)
10. 二叉树最大宽度 (层序遍历中，节点最多的那一层的宽度)
11. 二叉树坡 (类似平衡因子，统计每个节点左右子树的高度差)
```