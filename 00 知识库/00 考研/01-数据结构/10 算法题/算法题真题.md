---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
sticker: emoji//1f4af
banner: "![[99-Assets/background/2.jpg]]"
---

# 算法题真题
## 数组
---

### 【2013】 问题描述：查找数组中的主元素
**问题形式化描述：**
*   **输入：** 一个整数序列 `A(a0, a1, a2, …, an-1)`，保存在一个一维数组中。
*   **约束：** `0 <= ai <= n-1` (注意：原文是`0 <= ai <= n(0<i<n)`，此处修正为常见数组索引和元素范围定义，即元素值可能在`0`到`n-1`之间，或至少是`0`到`n`之间，且`n`是数组长度)。
*   **主元素定义：** 若存在一个元素 `x`，其在序列中出现的次数 `m` 满足 `m > n/2`，则称 `x` 为 `A` 的主元素。
*   **输出：** 如果存在主元素，则输出该元素；否则输出 `-1`。

**示例：**
*   `A = (0, 5, 5, 3, 5, 7, 5, 5)`，则 `5` 是主元素。
*   `A = (0, 5, 5, 3, 5, 1, 5, 7)`，则 `A` 中没有主元素。

---

解法一：摩尔投票法 (Moore's Voting Algorithm)

#(1) 算法基本设计思想：
**核心策略：** 摩尔投票法是一种高效的线性时间算法，用于在数组中查找可能的主元素。它基于一个关键观察：如果一个元素 `x` 是主元素，那么它的出现次数会比所有其他元素的总和还要多。因此，当 `x` 与另一个元素配对时，`x` 的“票数”仍然会领先。

**基本思想：**
1.  **筛选候选 (`candidate`)：**
    *   初始化一个 `candidate` 变量（候选主元素）和一个 `count` 变量（计数器）。
    *   遍历数组。
    *   如果 `count` 为 `0`，则将当前元素设置为 `candidate`，并将 `count` 设为 `1`。这表示我们开始考虑一个新的候选者。
    *   如果 `count` 不为 `0`：
        *   如果当前元素与 `candidate` 相同，则 `count` 加 `1`（视为得到一票）。
        *   如果当前元素与 `candidate` 不同，则 `count` 减 `1`（视为被抵消一票）。
    *   经过第一次遍历后，如果存在主元素，那么 `candidate` 变量将存储该主元素。这是因为主元素的出现次数超过 `n/2`，其“票数”不可能被完全抵消为 `0`。
2.  **验证候选：**
    *   第一次遍历结束后，`candidate` 可能是一个主元素，但并非一定。因为它也可能是数组中最后一个被选为 `candidate` 的元素，或者只是一个出现次数较多的非主元素。
    *   因此，需要进行第二次遍历。再次遍历整个数组，统计 `candidate` 在数组中实际出现的次数。
    *   如果统计出的次数确实大于 `n/2`，那么 `candidate` 才是真正的主元素，返回 `candidate`。
    *   否则，数组中不存在主元素，返回 `-1`。

#(2) C++ 算法实现：

```cpp
#include <iostream> // 用于标准输出，尽管本函数中未直接使用

/**
 * @brief 使用摩尔投票法查找数组中的主元素
 * @param A: 输入整数数组
 * @param n: 数组长度
 * @return: 主元素的值，若不存在则返回 -1
 */
int findMajority(int A[], int n) {
    int candidate = -1; // 候选主元素，初始化为-1
    int count = 0;      // 候选元素的计数器

    // 步骤 1：摩尔投票法筛选候选主元素
    for (int i = 0; i < n; ++i) {
        if (count == 0) {
            // 如果计数器为0，说明当前候选被完全抵消，
            // 或者这是第一次设置候选，将当前元素作为新的候选
            candidate = A[i];
            count = 1;
        } else {
            // 如果当前元素与候选相同，计数器加1
            // 如果不同，计数器减1（相互抵消）
            count += (A[i] == candidate) ? 1 : -1;
        }
    }

    // 步骤 2：验证候选元素的出现次数是否超过 n/2
    // （因为步骤1选出的candidate不一定是主元素，需要二次确认）
    count = 0; // 重置计数器
    for (int i = 0; i < n; ++i) {
        if (A[i] == candidate) {
            count++; // 统计候选元素实际出现的次数
        }
    }

    // 判断统计出的次数是否大于 n/2
    return (count > n / 2) ? candidate : -1; // 如果满足条件，返回候选；否则返回-1
}
```

(3) 复杂度分析：
*   **时间复杂度：** **O(N)**
    *   第一次遍历数组（筛选候选）需要 O(N) 时间。
    *   第二次遍历数组（验证候选）需要 O(N) 时间。
    *   总时间复杂度为 O(N) + O(N) = O(N)，是线性时间。
*   **空间复杂度：** **O(1)**
    *   算法只使用了两个额外的变量 (`candidate` 和 `count`)，它们的存储空间是常数级别的，不随输入数组大小 `N` 的变化而变化。

---

解法二：暴力解法（逐个统计）

(1) 算法基本设计思想：
**核心策略：** 对数组中的每个元素，都将其视为潜在的主元素，然后遍历整个数组来统计它的出现次数，并判断是否满足主元素的条件。

**基本思想：**
1.  **外层循环 (`i`)：** 遍历数组中的每一个位置 `i`，将 `A[i]` 作为当前的候选主元素 (`candidate`)。
2.  **内层循环 (`j`)：** 对于每个 `candidate`，再次遍历整个数组（从头到尾），统计 `candidate` 在数组中出现的总次数 (`count`)。
3.  **判断与返回：** 统计完成后，检查 `count` 是否大于 `n/2`。如果满足条件，说明 `candidate` 是主元素，立即返回 `candidate`。
4.  **未找到：** 如果外层循环结束后仍然没有返回任何主元素，说明数组中不存在主元素，此时返回 `-1`。

(2) C++ 算法实现：

```cpp
#include <iostream> // 用于标准输出，尽管本函数中未直接使用

/**
 * @brief 暴力解法：逐个统计每个元素的出现次数来查找主元素
 * @param A: 输入整数数组
 * @param n: 数组长度
 * @return: 主元素的值，若不存在则返回 -1
 */
int findMajorityElement_BruteForce(int A[], int n) {
    // 遍历数组中的每个元素，将其作为潜在的主元素
    for (int i = 0; i < n; i++) {
        int candidate = A[i]; // 当前的候选主元素
        int count = 0;        // 统计 candidate 的出现次数

        // 内层循环：遍历整个数组，统计 candidate 的出现次数
        for (int j = 0; j < n; j++) {
            if (A[j] == candidate) {
                count++;
            }
        }

        // 检查统计出的次数是否大于 n/2
        if (count > n / 2) {
            return candidate; // 找到主元素，立即返回
        }
    }
    return -1; // 遍历完所有元素都不是主元素，返回-1
}
```

#(3) 复杂度分析：
*   **时间复杂度：** **O(N^2)**
    *   外层循环遍历 `N` 次。
    *   内层循环也遍历 `N` 次。
    *   因此，总的时间复杂度为 O(N * N) = O(N^2)，是平方时间。
*   **空间复杂度：** **O(1)**
    *   算法只使用了几个固定的额外变量 (`i`, `candidate`, `count`, `j`)，不随输入数组大小 `N` 的变化而变化。

#算法正确性分析：
*   **完备性：** 外层循环遍历了数组中的每一个元素作为候选，确保不会遗漏任何可能的主元素。
*   **准确性：** 内层循环准确地统计了每个候选元素在整个数组中的出现次数。
*   **判断正确性：** 条件 `count > n/2` 完全符合主元素的定义，因此判断是正确的。

---

复杂度对比

| 算法版本         | 时间复杂度 | 空间复杂度 | 优缺点分析                                                                        |
| :--------------- | :--------- | :--------- | :---------------------------------------------------------------------------------- |
| **摩尔投票法**   | **O(N)**   | **O(1)**   | **理论最优解**，效率高，空间占用少，但思想相对巧妙。                                |
| **暴力解法**     | O(N^2)     | O(1)       | 简单直观，易于理解和实现，但效率低下，不适合处理大规模数据。                        |
| 哈希计数法       | O(N)       | O(N)       | 利用哈希表（或频率数组）存储计数，效率高，但需要额外 O(N) 空间。                     |
| 排序扫描法       | O(N log N) | O(1) / O(N) | 先排序（如快排 O(N log N) 时间，O(log N) 空间；归并 O(N log N) 时间，O(N) 空间），再扫描一遍找到中位数（主元素必然是中位数）。 |

**总结：** 摩尔投票法是解决“查找主元素”问题的**最优解**，它在保持常数空间复杂度的同时，实现了线性的时间复杂度，非常高效。暴力解法虽然易于理解，但其平方级的时间复杂度使其在处理大数据量时效率极低。



---
## 链表
### 【2009】查找链表中倒数第 K 个节点 (单链表，带头结点)

问题描述

已知一个带表头结点的单链表，结点结构为：`data` `link`。假设该链表只给出了头指针 `list`。在不改变链表的前提下，设计一个尽可能高效的算法，查找链表中倒数第 `k` 个位置上的结点（`k` 为正整数）。若查找成功，算法输出该结点 `data` 域的值，并返回 1；否则，只返回 0。

结点结构定义

```cpp
// C++ 结构体定义
typedef struct Node {
    int data;
    struct Node* link; // 指向下一个结点的指针
} Node;
```

---

解法一：双指针法（快慢指针）

#(1) 算法的基本设计思想

**核心策略**：利用两个指针，一个快指针 `fast` 和一个慢指针 `slow`，通过控制它们之间的距离来定位目标结点。

**基本思想**：
1.  **快指针先行**：让快指针 `fast` 先向链表尾部移动 `k` 步。这样，`fast` 和 `slow` 之间就相隔了 `k` 个结点。
2.  **同步后移**：然后，快指针 `fast` 和慢指针 `slow` 同时以相同的速度（一步一步）向后移动。
3.  **定位目标**：当快指针 `fast` 移动到链表的末尾（即 `fast` 指向 `NULL`）时，慢指针 `slow` 恰好就指向了链表中倒数第 `k` 个位置上的结点。
4.  **异常处理**：若快指针在先行 `k` 步的过程中，或 `k` 步后恰好指向 `NULL`，则说明链表中的数据结点总数不足 `k` 个，此时倒数第 `k` 个结点不存在。

#(2) 算法的详细实现步骤

1.  **初步校验**：
    *   检查 `k` 值是否合法 (`k <= 0`)。
    *   检查链表是否为空，即 `list == NULL` 或 `list->link == NULL`（只包含头结点或头结点本身无效）。
    *   如果任一条件不满足，直接返回 `0`（查找失败）。
2.  **初始化指针**：
    *   创建两个 `Node*` 指针 `slow` 和 `fast`。
    *   将它们都初始化为指向链表的**第一个数据结点**（即 `list->link`）。
3.  **快指针先行 `k` 步**：
    *   使用一个 `for` 循环，从 `i = 0` 到 `k-1`，每次循环让 `fast = fast->link`。
    *   **关键校验**：在每次移动 `fast` 之前，需要判断 `fast` 是否已经为 `NULL`。如果 `fast` 在移动 `k` 步的过程中（或恰好在第 `k` 步之后）变为 `NULL`，则说明链表数据结点数量不足 `k` 个，倒数第 `k` 个结点不存在，此时返回 `0`。
4.  **快慢指针同步后移**：
    *   使用一个 `while` 循环，循环条件为 `fast != NULL`。
    *   在循环体内，同时执行 `slow = slow->link` 和 `fast = fast->link`。
    *   这个循环会一直执行，直到 `fast` 指针越过链表最后一个结点，最终指向 `NULL`。
5.  **输出结果**：
    *   当 `while` 循环结束时，`slow` 指针将指向倒数第 `k` 个结点。
    *   输出 `slow->data` 的值。
    *   返回 `1`，表示查找成功。

#(3) C++ 算法实现

```cpp
#include <iostream> // For std::cout, std::endl

// 假设 Node 结构体已定义
// typedef struct Node {
//     int data;
//     struct Node* link;
// } Node;

int findKthFromEnd_DoublePointer(Node* list, int k) {
    // 1. 初步校验 k 值或链表是否为空
    if (k <= 0 || list == NULL || list->link == NULL) {
        std::cout << "查找失败：链表无效或 k 值无效 (k=" << k << ")。\n";
        return 0; // 查找失败
    }

    // 2. 初始化 slow、fast 均指向链表的首数据结点 (list->link)
    Node *slow = list->link; // 慢指针
    Node *fast = list->link; // 快指针

    // 3. 快指针先行 k 步，从而在 fast 和 slow 之间建立 k 个结点的距离
    for (int i = 0; i < k; ++i) {
        // 关键校验：在 fast 移动前检查其是否为 NULL
        if (fast == NULL) { 
            std::cout << "查找失败：链表数据结点数量不足 " << k << " 个。\n";
            return 0; // 查找失败
        }
        fast = fast->link; // fast 指针向前移动一步
    }

    // 4. 快慢指针同步后移，直到快指针 fast 到达链表末尾 (即 fast 指向 NULL)
    while (fast != NULL) { 
        slow = slow->link; // 慢指针向前移动一步
        fast = fast->link; // 快指针也向前移动一步
    }

    // 5. 输出结点数据并返回 1
    std::cout << "查找成功！倒数第 " << k << " 个结点的数据域值为：" << slow->data << std::endl;
    return 1; // 查找成功
}
```

#复杂度分析
*   **时间复杂度**：O(N)
    *   快指针先行 `k` 步。
    *   随后快慢指针同步移动，最多再移动 `N-k` 步。
    *   总共对链表进行了一次完整的遍历，操作次数与链表长度 `N` 成正比，因此为 O(N)。
*   **空间复杂度**：O(1)
    *   算法只使用了两个额外的指针变量 (`slow` 和 `fast`)，没有使用与链表长度相关的额外存储空间，因此空间复杂度为 O(1)。

---

解法二：暴力解法（两次遍历）

#(1) 算法的基本设计思想

**核心策略**：两次遍历链表，第一次计算链表长度，第二次定位目标节点。

**基本思想**：

1.  **第一次遍历**：计算链表总长度 `n`（不包括头结点）。
2.  **合法性检查**：判断 `k` 是否在有效范围 `[1, n]` 内。
3.  **第二次遍历**：根据链表长度 `n` 和 `k`，计算出倒数第 `k` 个结点在正数位置上的索引 `(n-k+1)`，然后从头开始遍历到该位置。

#(2) 算法的详细实现步骤

1.  **初步校验**：
    *   检查链表头指针 `list` 是否为 `NULL`。
    *   检查 `k` 值是否为正整数 (`k <= 0`)。
    *   如果任一条件不满足，直接返回 `0`（查找失败）。
2.  **第一次遍历 - 计算链表长度**：
    *   初始化一个整数变量 `length = 0`，用于存储链表的长度。
    *   创建一个 `Node*` 指针 `current`，并将其初始化为指向链表的**第一个数据结点**（即 `list->link`，跳过头结点）。
    *   使用一个 `while` 循环，当 `current != NULL` 时，每次循环执行 `length++` 并 `current = current->link`。
    *   循环结束后，`length` 将存储链表中实际数据结点的总数。
3.  **合法性检查**：
    *   判断 `k` 是否大于 `length`。
    *   如果 `k > length`，说明倒数第 `k` 个结点不存在，此时返回 `0`（查找失败）。
4.  **第二次遍历 - 定位目标结点**：
    *   计算目标结点在正数位置上的索引：`targetPosition = length - k + 1`。
    *   将 `current` 指针**重新**初始化为指向链表的**第一个数据结点**（即 `list->link`）。
    *   使用一个 `for` 循环，从 `i = 1` 到 `targetPosition - 1`，每次循环执行 `current = current->link`。
    *   循环结束后，`current` 指针将指向倒数第 `k` 个数据结点。
5.  **输出结果**：
    *   输出 `current->data` 的值。
    *   返回 `1`，表示查找成功。

#(3) C++ 算法实现

```cpp
#include <iostream> // For std::cout, std::endl

// 假设 Node 结构体已定义
// typedef struct Node {
//     int data;
//     struct Node* link;
// } Node;

int findKthFromEnd_BruteForce(Node* list, int k) {
    // 1. 初步校验 k 值或链表是否为空
    if (list == NULL || k <= 0 || list->link == NULL) {
        std::cout << "查找失败：链表无效或 k 值无效 (k=" << k << ")。\n";
        return 0; // 查找失败
    }

    // 2. 第一次遍历：计算链表长度
    int length = 0;
    Node* current = list->link; // 从第一个数据结点开始遍历，跳过头结点
    while (current != NULL) {
        length++;
        current = current->link;
    }

    // 3. 合法性检查：判断 k 是否超出链表长度
    if (k > length) {
        std::cout << "查找失败：链表数据结点数量不足 " << k << " 个 (链表长度为 " << length << ")。\n";
        return 0; // 查找失败
    }

    // 4. 第二次遍历：定位倒数第 k 个结点
    //    倒数第 k 个结点，相当于从头开始的第 (length - k + 1) 个结点
    int targetPosition = length - k + 1;
    current = list->link; // 重新从第一个数据结点开始

    // 移动 current 指针到目标位置
    // 因为 current 已经指向第 1 个结点，所以只需移动 targetPosition - 1 次
    for (int i = 1; i < targetPosition; i++) {
        current = current->link;
    }

    // 5. 输出结果
    std::cout << "查找成功！倒数第 " << k << " 个结点的数据域值为：" << current->data << std::endl;
    return 1; // 查找成功
}
```

#复杂度分析

*   **时间复杂度**：O(N)
    *   第一次遍历链表需要 O(N) 时间（计算长度）。
    *   第二次遍历链表需要 O(N-K+1) 时间（定位目标结点）。
    *   总时间复杂度为 O(N) + O(N-K+1) = O(N)。
*   **空间复杂度**：O(1)
    *   算法只使用了几个固定的额外变量（`length`，`k`，`current`），没有使用与链表长度相关的额外存储空间，因此空间复杂度为 O(1)。

---

两种解法对比

| 特性         | 双指针法（快慢指针） | 暴力解法（两次遍历） |
| :----------- | :------------------- | :------------------- |
| **核心思想** | 保持两指针固定距离     | 先算总长，再定位     |
| **遍历次数** | 1 次                 | 2 次                 |
| **时间复杂度** | O(N)                 | O(N)                 |
| **空间复杂度** | O(1)                 | O(1)                 |
| **实现复杂性** | 稍复杂，需理解指针距离 | 直观，易于理解和实现 |
| **实际效率** | 理论上更快（少一次循环开销） | 稍慢（多一次循环开销） |
| **推荐度**   | **更优解**，面试/考试常考 | 基本解法，易于理解 |

**总结**：虽然两种方法在渐进时间复杂度上都是 O(N)，但**双指针法**由于只进行一次遍历，在实际运行中通常更高效。暴力解法逻辑更直观，适合初学者理解问题。在面试或考试中，通常会期望考生能给出双指针的更优解。


### 【2012】问题描述：查找两个链表的共同后缀 (2012年算法题)

**问题形式化描述：**
*   **输入：** 两个带头结点的单链表 `str1` 和 `str2`，每个结点保存一个字符，代表一个单词的字符序列。
*   **输出：** 共同后缀的起始位置指针。如果两个链表没有共同的后缀（即没有物理上共享的结点），则返回 `NULL`。
*   **约束：** 时间复杂度应尽可能高效。

**结点结构定义：**
```cpp
typedef struct Node {
    char data;      // 字符数据
    struct Node* next; // 指向下一个结点的指针
} Node;
```

---

 解法一：暴力解法（双重循环匹配）

(1) 算法基本设计思想：
**核心策略：** 采用双重循环进行暴力匹配，对于 `str1` 中的每一个结点，都检查从该结点开始的后缀是否能与 `str2` 中某个结点开始的后缀完全相同。

**基本思想：**
1.  **外层遍历 (`p1`)：** 遍历 `str1` 中的每一个数据结点（从 `str1->next` 开始），将其作为潜在的共同后缀起始点。
2.  **内层遍历 (`p2`)：** 对于 `str1` 中的每个 `p1`，重新将 `p2` 指针设置为 `str2` 的第一个数据结点（`str2->next`），然后遍历 `str2` 中的每一个数据结点，将其作为与 `p1` 对应的潜在共同后缀起始点。
3.  **后缀比较 (`temp1`, `temp2`)：** 从当前的 `p1` 和 `p2` 位置开始，使用一对临时指针 (`temp1` 和 `temp2`) 同步向后遍历，逐个字符地比较这两个子链表（后缀）是否完全匹配。这个比较过程持续到发现不匹配的字符，或者两个后缀都同时到达链表末尾 (`NULL`)。
4.  **返回结果：** 如果 `temp1` 和 `temp2` 同时到达 `NULL`，则说明找到了一个完全匹配的共同后缀。此时，`p1` 指向的就是 `str1` 中共同后缀的起始结点，算法返回 `p1`。如果遍历完所有 `p1` 和 `p2` 的组合后仍未找到完全匹配的后缀，则说明不存在共同后缀，返回 `NULL`。

(2) C++ 算法实现：

```cpp
#include <iostream> // 用于标准输出，尽管本函数中未直接使用

// Node 结构体定义 (同问题描述)
// typedef struct Node {
//     char data;
//     struct Node* next;
// } Node;

Node* findCommonSuffix_BruteForce(Node* str1, Node* str2) {
    // 初始校验：链表是否为空
    if (str1 == NULL || str2 == NULL) {
        return NULL;
    }

    // p1 初始化为 str1 的第一个数据结点 (跳过头结点)
    Node* p1 = str1->next;
    
    // 外层循环：遍历 str1 的每个潜在后缀起始点
    while (p1 != NULL) {
        // p2 每次在外层循环开始时重置为 str2 的第一个数据结点
        Node* p2 = str2->next;
        
        // 内层循环：遍历 str2 的每个潜在后缀起始点
        while (p2 != NULL) {
            // temp1 和 temp2 用于比较从 p1 和 p2 开始的后缀
            Node* temp1 = p1;
            Node* temp2 = p2;
            
            // 最内层循环：比较后缀的字符
            while (temp1 != NULL && temp2 != NULL && temp1->data == temp2->data) {
                temp1 = temp1->next;
                temp2 = temp2->next;
            }
            
            // 如果两个临时指针都同时到达 NULL，说明找到了一个完整的共同后缀
            if (temp1 == NULL && temp2 == NULL) {
                return p1; // 返回 str1 中共同后缀的起始结点
            }
            p2 = p2->next; // p2 移动到 str2 的下一个潜在起始点
        }
        p1 = p1->next; // p1 移动到 str1 的下一个潜在起始点
    }
    return NULL; // 遍历所有可能后，未找到共同后缀
}
```

(3) 复杂度分析：
*   **时间复杂度：** **O(M^2 * N^2)**
    *   外层循环遍历 `str1` 的 `M` 个结点。
    *   内层循环遍历 `str2` 的 `N` 个结点。
    *   最内层循环（后缀比较）在最坏情况下需要遍历 `min(M, N)` 个结点。
    *   因此，总的时间复杂度为 O(M * N * min(M, N))。根据原文描述，此处直接采用 **O(M^2 * N^2)**。
*   **空间复杂度：** O(1)
    *   算法只使用了固定数量的辅助指针变量 (`p1`, `p2`, `temp1`, `temp2`)，不随链表长度的增加而增加额外存储空间。

---

 解法二：最优解（双指针法 / 长度对齐法）

(1) 算法基本设计思想：
**核心策略：** 该方法利用了单链表如果存在共同后缀，则它们必然会在某个结点处物理地合并（即指向同一个内存地址）这一特性。通过先计算两链表长度，然后将较长链表的指针提前移动，使两指针到链表末尾的距离相等，从而同步遍历寻找合并点。

**基本思想：**
1.  **计算长度：** 首先，分别遍历 `str1` 和 `str2`，计算出它们各自的有效数据结点长度 `len1` 和 `len2`（不包括头结点）。
2.  **对齐指针：** 将两个指针 (`p1` 和 `p2`) 都重置回各自链表的第一个数据结点。然后，让长度较长的链表的指针向前移动 `|len1 - len2|` 步。经过这一步，两个指针现在与各自链表末尾的距离是相等的，也等同于与共同后缀起始点的距离相等。
3.  **同步遍历：** 两个指针 `p1` 和 `p2` 以相同的速度（一步一步）同步向后移动。当 `p1` 与 `p2` 首次相等时（即它们指向了同一个内存地址的结点），这个结点就是共同后缀的起始结点。如果两个指针在到达 `NULL` 之前一直不相等，或者同时到达 `NULL`，则表示没有共同后缀，此时返回 `NULL`。

(2) C++ 算法实现：

```cpp
#include <iostream> // 用于标准输出，尽管本函数中未直接使用

// Node 结构体定义 (同问题描述)
// typedef struct Node {
//     char data;
//     struct Node* next;
// } Node;

Node* findCommonSuffix_Optimal(Node* str1, Node* str2) {
    // 初始校验：链表是否为空
    if (str1 == NULL || str2 == NULL) {
        return NULL;
    }

    // 步骤 1：计算两链表的长度 (跳过头结点，只计算数据结点)
    int len1 = 0;
    int len2 = 0;
    Node *p1 = str1->next; // 从 str1 的第一个数据结点开始
    Node *p2 = str2->next; // 从 str2 的第一个数据结点开始

    // 统计 str1 的长度
    while (p1 != NULL) {
        len1++;
        p1 = p1->next;
    } 

    // 统计 str2 的长度
    while (p2 != NULL) {
        len2++;
        p2 = p2->next;
    } 

    // 步骤 2：重置指针并对齐
    p1 = str1->next; 
    p2 = str2->next;

    // 让较长链表的指针先移动，使得两个指针到链表末尾的距离相等
    if (len1 > len2) {
        // str1 更长，p1 先移动 (len1 - len2) 步
        for (int i = 0; i < len1 - len2; i++) {
            p1 = p1->next;
        }
    } else { // len2 >= len1
        // str2 更长或长度相等，p2 先移动 (len2 - len1) 步
        for (int i = 0; i < len2 - len1; i++) {
            p2 = p2->next;
        }
    }

    // 步骤 3：同步遍历，直到找到地址相同的结点 (共同后缀起点) 或都到达 NULL
    while (p1 != p2) { // 结点地址相同则退出循环
        p1 = p1->next;
        p2 = p2->next;
    }

    // p1 (或 p2，因为它们此时相等) 指向共同后缀的起始结点，
    // 如果没有共同后缀，它们会同时到达 NULL。
    return p1;
}
```

(4) 复杂度分析：
*   **时间复杂度：** **O(M + N)**
    *   **求长度：** 遍历 `str1` 需要 O(M) 时间，遍历 `str2` 需要 O(N) 时间。总计 O(M + N)。
    *   **对齐指针：** 最多遍历 `|M - N|` 步，即 O(max(M, N))。
    *   **同步遍历：** 最多遍历 `min(M, N)` 步，即 O(min(M, N))。
    *   总的时间复杂度由以上各项之和决定，主导项是 O(M + N)，因此是线性的。
*   **空间复杂度：** O(1)
    *   算法只使用了固定数量的额外变量 (`len1`, `len2`, `p1`, `p2`, `i`)，不随链表长度的增加而增加额外存储空间。

---

两种解法对比

| 特性         | 暴力解法（双重循环）       | 最优解（双指针 / 长度对齐）  |
| :----------- | :--------------------------- | :--------------------------- |
| **核心思想** | 穷举所有后缀组合并逐一比较   | 计算长度，对齐指针，同步遍历寻找物理合并点 |
| **遍历次数** | 多重嵌套遍历，高度冗余       | 2 次完整遍历（求长） + 最多 2 次部分遍历（对齐、找交点） |
| **时间复杂度** | **O(M^2 * N^2)** （根据原文） | **O(M + N)**                 |
| **空间复杂度** | O(1)                         | O(1)                         |
| **实际效率** | 非常低效，不适用于较大链表   | 高效，线性时间，适用于任意链表长度 |
| **实现复杂性** | 概念直观，容易理解如何检查所有可能 | 需要理解链表物理结构（共享结点）和指针巧妙操作，相对复杂一些 |
| **推荐度**   | 适用于初步理解问题，但非实际应用 | **强烈推荐**，效率高且优雅，面试/考试常考 |

**总结：** 尽管两种方法在概念上都能解决问题，但暴力解法因其过高的时间复杂度而不可取。最优解通过长度对齐的双指针策略，将时间复杂度优化到线性（O(M+N)），在实际应用和考察中是更受青睐和推崇的解决方案。




### 【2015】删除单链表中绝对值相等的重复结点 
![[算法题真题-1764918230464.png]]
**问题形式化描述：**
*   **输入：**
    *   `head`: 指向单链表头结点的指针，链表中包含 `m` 个整数。
    *   每个结点的 `data` 字段是一个整数，满足 `|data| ≤ n` (其中 `n` 是一个给定的正整数，表示 `data` 绝对值的最大可能范围)。
*   **输出：**
    *   修改后的单链表，其中对于任意绝对值相同的整数，仅保留第一次出现的结点，删除其余所有绝对值相等的重复结点。
*   **约束：**
    *   设计一个时间复杂度尽可能高效的算法。

**结点结构定义：**
```cpp
typedef struct Node {
    int data;       // 数据域，存储整数
    struct Node* link; // 指针域，指向下一个结点
} Node;
```

---

解法一·：哈希标记法 (使用单级指针处理链表)

**(1) 算法基本设计思想：**
该方法利用哈希标记的思想，通过一个布尔型数组来记录已经出现过的结点的绝对值。由于题目明确 `|data| ≤ n`，我们可以创建一个大小为 `n+1` 的布尔数组 `mark` (或 `visited`)。

算法步骤如下：
1.  首先处理链表的头结点：计算其 `data` 的绝对值，并在 `mark` 数组中标记为已出现。
2.  接着，遍历链表的其余部分，同时维护一个 `pre` 指针指向当前结点 `cur` 的前驱结点。
3.  对于当前结点 `cur`：
    *   计算 `abs_val = abs(cur->data)`。
    *   如果 `mark[abs_val]` 为 `true`，表示该绝对值已经出现过，说明 `cur` 是一个重复结点，需要将其删除。删除操作为：`pre->link = cur->link`，然后释放 `cur` 结点内存，并将 `cur` 更新为 `pre->link` (即原 `cur->link`)。
    *   如果 `mark[abs_val]` 为 `false`，表示该绝对值是首次出现，将其在 `mark` 数组中标记为 `true`，然后将 `pre` 更新为 `cur`，`cur` 更新为 `cur->link`。
4.  遍历完成后，链表将仅保留各绝对值首次出现的结点。

**(2) C++ 算法实现：**
```cpp
#include <cstdlib> // For abs()
#include <vector>  // For std::vector<bool> if preferred over raw array

// 结点结构定义已在问题描述中给出

void removeDuplicateAbs_SinglePtr(Node* head, int n) {
    if (!head) { // 空链表
        return;
    }

    // 使用动态布尔数组作为哈希标记，初始化为false
    // std::vector<bool> mark(n + 1, false); // C++风格，更安全易用
    bool* mark = new bool[n + 1](); // C风格动态数组，注意初始化为0 (false)

    // 标记头结点的绝对值
    mark[abs(head->data)] = true;

    Node *pre = head;          // pre指向当前结点的前一个结点
    Node *cur = head->link;    // cur指向当前待处理的结点

    while (cur) {
        int abs_val = abs(cur->data);
        if (mark[abs_val]) {
            // 该绝对值已出现，删除当前结点
            pre->link = cur->link; // 前驱结点直接跳过当前结点
            Node* temp = cur;      // 保存当前结点以便释放内存
            cur = cur->link;       // cur移动到下一个待处理结点
            delete temp;           // 释放被删除结点的内存
        } else {
            // 该绝对值首次出现，标记并移动指针
            mark[abs_val] = true;
            pre = cur;             // pre移动到当前结点
            cur = cur->link;       // cur移动到下一个待处理结点
        }
    }

    delete[] mark; // 释放标记数组内存
}
```

**(3) 复杂度分析：**
*   **时间复杂度：** O(m)。算法对链表进行了一次完整的遍历，每个结点被访问和处理（标记或删除）的次数是常数级别的。因此，时间复杂度与链表中的结点数量 `m` 成正比。
*   **空间复杂度：** O(n)。算法使用了一个布尔数组 `mark` 来记录绝对值的出现情况，其大小与 `data` 的最大绝对值 `n` 相关。因此，空间复杂度为 O(n)。

---

解法二：哈希标记法 (使用二级指针处理链表)

**(1) 算法基本设计思想：**
该解法与解法一的核心思想完全相同，同样利用布尔数组进行哈希标记。主要区别在于函数参数使用了二级指针 `Node** head`，这使得函数能够直接修改外部传入的头指针（例如，如果链表的第一个结点被删除），但对于本问题“仅保留第一次出现的结点”，头结点本身不会被删除，所以 `Node**` 在此处的直接作用不大，但体现了更通用的链表删除模式。

算法步骤如下：
1.  检查链表是否为空。
2.  创建一个布尔型数组 `mark` 来记录已出现的绝对值。
3.  初始化 `pre` 指针为 `NULL`，`cur` 指针为 `*head` (即链表的第一个数据结点)。
4.  遍历链表：
    *   对于当前结点 `cur`，计算 `abs_val = abs(cur->data)`。
    *   如果 `mark[abs_val]` 为 `true`，表示该绝对值已出现，删除 `cur` 结点。这里需要注意：如果 `pre` 为 `NULL` (即 `cur` 是链表头结点)，则需要更新 `*head`。但在本问题中，第一个结点 `cur` 的绝对值必然是首次出现，所以 `pre` 不会是 `NULL`。正常执行 `pre->link = cur->link`，并释放 `cur` 内存。
    *   如果 `mark[abs_val]` 为 `false`，则标记 `mark[abs_val] = true`，并将 `pre` 更新为 `cur`。
    *   更新 `cur` 为 `pre->link`。
5.  遍历结束后，释放 `mark` 数组内存。

**(2) C++ 算法实现：**
```cpp
#include <cstdlib> // For abs()
// 结点结构定义已在问题描述中给出

void removeDuplicateAbs_DoublePtr(Node** head, int n) {
    if (!(*head)) { // 空链表
        return;
    }

    bool* mark = new bool[n + 1](); // 动态布尔数组，初始化为false

    Node *pre = NULL;          // 前驱指针，初始为NULL
    Node *cur = *head;         // 当前结点，从链表头开始

    while (cur) {
        int abs_val = abs(cur->data);
        if (mark[abs_val]) {
            // 该绝对值已出现，删除当前结点
            // 由于“仅保留第一次出现的结点”的规则，第一个结点永远不会被删除
            // 因此，当执行到此分支时，pre一定不为NULL
            pre->link = cur->link;
            Node* temp = cur;
            cur = cur->link;
            delete temp;
        } else {
            // 该绝对值首次出现，标记并移动指针
            mark[abs_val] = true;
            pre = cur;
            cur = cur->link;
        }
    }

    delete[] mark; // 释放标记数组内存
}
```

**(3) 复杂度分析：**
*   **时间复杂度：** O(m)。与解法一相同，算法对链表进行了一次完整的遍历，每个结点被访问和处理的次数是常数级别。因此，时间复杂度与链表中的结点数量 `m` 成正比。
*   **空间复杂度：** O(n)。与解法一相同，算法使用了一个布尔数组 `mark`，其大小与 `data` 的最大绝对值 `n` 相关。因此，空间复杂度为 O(n)。

---

两种解法对比

| 特性     | 解法一：哈希标记法 (使用单级指针)                | 解法二：哈希标记法 (使用二级指针)                     |
| :------- | :------------------------------------------- | :------------------------------------------------ |
| **功能** | 删除单链表中绝对值相等的重复结点，保留首次出现。   | 功能相同，删除单链表中绝对值相等的重复结点。            |
| **效率** | 渐进时间复杂度 O(m)，渐进空间复杂度 O(n)。          | 渐进时间复杂度 O(m)，渐进空间复杂度 O(n)。              |
| **代码实现** | 函数参数为 `Node* head`。需要特殊处理头结点的标记，然后从 `head->link` 开始迭代。对链表头部的修改（如删除头结点）需要通过返回值或额外逻辑处理。 | 函数参数为 `Node** head`。理论上能更方便地修改链表头部，使删除逻辑更通用。但对于本问题，其优势未完全体现，因为首个结点不会被删除。 |
| **健壮性** | 若需删除原始链表的第一个结点，此接口需要调用者额外处理或更改返回值。 | 理论上更通用，能直接修改链表头指针，适用于任何位置的结点删除，包括头部。 |
| **推荐度** | 在确定链表头结点不会被删除时，此写法更简洁直观。 | 若需要实现一个更通用的链表删除函数，能够删除包括头结点在内的任意结点，则二级指针更推荐。对于本特定问题，两者效率相同，单级指针实现稍显简洁。 |

## 树

### 【2014】计算二叉树的带权路径长度 (WPL)

**问题形式化描述：**
*   **输入：** 一棵二叉树 `T` 的根结点指针 `root`。
*   **特性：** 采用二叉链表存储，结点结构包含 `left`（左子树指针）、`weight`（结点权值）、`right`（右子树指针）。其中，**叶结点的 `weight` 域保存该结点的非负权值**。
*   **输出：** 二叉树的带权路径长度 (WPL)。WPL 定义为二叉树中所有叶结点的带权路径长度之和。一个叶结点的带权路径长度 = 该叶结点的权值 × 从根结点到该叶结点的路径长度（即深度）。
*   **约束：** 要求设计高效算法。

**二叉树结点的数据类型定义：**
```cpp
typedef struct BTNode {
    struct BTNode *left;   // 左子树指针
    int weight;            // 结点权值（仅叶结点有效，非叶结点可忽略或设为0）
    struct BTNode *right;  // 右子树指针
} BTNode;
```

---

解法一：递归后序遍历 (使用全局变量累加 WPL)

(1) 算法基本设计思想：
**核心策略：** 采用递归的深度优先搜索（DFS）遍历策略，通常是后序遍历的变体，同时在递归过程中维护当前结点的**深度**。WPL 的计算需要累加所有叶结点的“权值 * 深度”，因此当访问到叶结点时进行累加操作。

**基本思想：**
1.  **参数传递：** 递归函数 `calcWPL` 接受当前结点指针 `root` 和当前结点的深度 `depth` 作为参数。根结点的初始深度为 `0`。
2.  **空结点处理：** 如果当前结点 `root` 为 `NULL`，则直接返回（终止递归）。
3.  **叶结点判断与累加：** 如果当前结点 `root` 是叶结点（即 `root->left == NULL && root->right == NULL`），则计算该叶结点的带权路径长度 (`root->weight * depth`)，并将其累加到一个**全局变量** `wpl` 中。然后返回。
4.  **非叶结点递归：** 如果当前结点 `root` 是非叶结点，则递归调用 `calcWPL` 处理其左子树和右子树，同时将深度 `depth` 增加 `1` (`depth + 1`)，以反映向下一层。

(2) C++ 算法实现：

```cpp
#include <iostream> // For std::cout, std::endl

// 二叉树结点的数据类型定义 (同问题描述)
// typedef struct BTNode {
//     struct BTNode *left;
//     int weight;
//     struct BTNode *right;
// } BTNode;

// 全局变量：用于存储带权路径长度总和。
// 在调用 calcWPL 函数之前必须将其初始化为 0。
int global_wpl_sum = 0;

/**
 * @brief 递归计算二叉树的带权路径长度 (WPL)，使用全局变量累加。
 * @param root: 当前子树的根结点指针。
 * @param depth: 当前结点的深度（根结点深度为 0）。
 */
void calcWPL(BTNode *root, int depth) {
    // 1. 基本情况：如果当前结点为空，直接返回
    if (root == NULL) {
        return;
    }

    // 2. 叶结点判断：如果当前结点是叶结点（左右子树均为空）
    if (root->left == NULL && root->right == NULL) {
        // 累加该叶结点的带权路径长度到全局变量
        global_wpl_sum += root->weight * depth;
        return; // 叶结点处理完毕，返回
    }

    // 3. 非叶结点：递归处理左右子树，深度加 1
    // 遍历左子树
    calcWPL(root->left, depth + 1);
    // 遍历右子树
    calcWPL(root->right, depth + 1);
}

// 示例调用函数 (用于封装，使接口更清晰)
int getWPL_Global(BTNode *root) {
    global_wpl_sum = 0; // 每次计算前务必初始化全局变量
    calcWPL(root, 0);   // 从根结点开始，深度为 0
    return global_wpl_sum;
}
```

(3) 复杂度分析：
*   **时间复杂度：** **O(N)**
    *   每个结点在递归过程中仅被访问一次。对每个结点，都进行常数时间的判断和操作（检查是否为空、是否是叶结点、累加、递归调用）。
    *   因此，总的操作次数与二叉树的结点总数 `N` 成正比。
*   **空间复杂度：** **O(H)**
    *   递归算法的空间开销主要来自函数调用栈。栈的深度等于二叉树的高度 `H`。
    *   在最坏情况下（例如，链状树），`H` 可以等于 `N`，空间复杂度为 O(N)。
    *   在最优情况下（例如，完全平衡二叉树），`H` 等于 `log N`，空间复杂度为 O(log N)。

---

解法二：递归后序遍历 (不使用全局变量，直接返回子树 WPL)

(1) 算法基本设计思想：
**核心策略：** 同样采用递归的深度优先搜索，维护当前结点的深度。与解法一不同的是，此方法不使用全局变量，而是让递归函数直接**返回**当前子树中所有叶结点的 WPL 之和。

**基本思想：**
1.  **辅助函数：** 设计一个辅助递归函数 `calculateWPL`，它接受当前结点 `root` 和当前深度 `depth`。
2.  **空结点处理：** 如果 `root` 为 `NULL`，则表示该子树没有叶结点，返回 `0`。
3.  **叶结点判断与计算：** 如果当前结点 `root` 是叶结点，则计算其带权路径长度 (`root->weight * depth`) 并直接返回此值。
4.  **非叶结点递归累加：** 如果 `root` 是非叶结点，则递归调用 `calculateWPL` 处理其左子树和右子树，深度同样加 `1`。将左子树返回的 WPL 和右子树返回的 WPL 相加，作为当前结点的子树 WPL 总和返回。
5.  **主函数调用：** 主函数 `getWPL` 负责调用 `calculateWPL`，并传入根结点和初始深度 `0`。

(2) C++ 算法实现：

```cpp
#include <iostream> // For std::cout, std::endl

// 二叉树结点数据类型定义 (同问题描述)
// typedef struct BiTNode {
//     struct BiTNode *left;
//     int weight;
//     struct BiTNode *right;
// } BiTNode, *BiTree;

// 辅助函数：判断结点是否为叶结点
bool isLeaf(BTNode *node) {
    return (node != NULL && node->left == NULL && node->right == NULL);
}

/**
 * @brief 递归计算二叉树的带权路径长度 (WPL)，直接返回子树的 WPL。
 * @param root: 当前子树的根结点指针。
 * @param depth: 当前结点的深度（根结点深度为 0）。
 * @return: 当前子树中所有叶结点的带权路径长度之和。
 */
int calculateWPL_Recursive(BTNode *root, int depth) {
    // 1. 基本情况：如果当前结点为空，该子树没有叶结点，返回 0
    if (root == NULL) {
        return 0;
    }

    // 2. 叶结点判断：如果当前结点是叶结点
    if (isLeaf(root)) { // 调用辅助函数判断是否为叶结点
        // 返回该叶结点的带权路径长度
        return root->weight * depth;
    }

    // 3. 非叶结点：递归计算左右子树的 WPL 并相加
    int leftWPL = calculateWPL_Recursive(root->left, depth + 1);
    int rightWPL = calculateWPL_Recursive(root->right, depth + 1);

    return leftWPL + rightWPL; // 返回左右子树 WPL 之和
}

// 主函数：计算整个二叉树的 WPL
int getWPL_NonGlobal(BTNode *root) {
    // 如果根结点为空，直接返回 0
    if (root == NULL) {
        return 0;
    }
    // 从根结点开始，初始深度为 0
    return calculateWPL_Recursive(root, 0);
}
```

(3) 复杂度分析：
*   **时间复杂度：** **O(N)**
    *   与解法一相同，每个结点访问一次，进行常数时间操作。总时间复杂度与结点总数 `N` 成正比。
*   **空间复杂度：** **O(H)**
    *   与解法一相同，递归栈深度等于树高 `H`。最坏 O(N)，最优 O(log N)。

---

两种解法对比

| 特性         | 解法一：递归 (全局变量)      | 解法二：递归 (返回值累加)    |
| :----------- | :--------------------------- | :--------------------------- |
| **核心思想** | DFS 遍历，叶结点处计算 `weight * depth` 累加到全局变量 | DFS 遍历，叶结点处返回 `weight * depth`，非叶结点累加子树返回值 |
| **变量管理** | 依赖全局变量，需要在调用前手动初始化 | 无需全局变量，通过返回值自然累加，封装性更好 |
| **实现复杂性** | 直观，容易理解，但需注意全局变量初始化 | 稍显函数式编程风格，更符合递归“分而治之”的思想，通常被认为是更健壮的实现 |
| **效率 (渐进)** | 时间 O(N)，空间 O(H)         | 时间 O(N)，空间 O(H)         |
| **推荐度**   | 可行，但在多线程或多次调用时需谨慎处理全局变量 | **更推荐**，代码更简洁，可重用性高，避免全局变量带来的副作用 |

**总结：** 两种递归解法在渐进时间复杂度和空间复杂度上是完全相同的。解法二（通过返回值累加）通常被认为是更优秀的实现，因为它避免了使用全局变量，使得函数更加纯粹、可重用性更强，且不易引入副作用。在实际编程和考试中，这两种方法都是可接受的正确解法。