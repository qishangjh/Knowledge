---
科目: "408"
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 06 图
## **6.1 图的基本概念**

### 1. 图的定义
图（Graph）是由**顶点集合 V（Vertex）和边集合 E（Edge）组成的一种数据结构，记作 G = (V, E)。

- $V(G)$表示图 G 中顶点的有限非空集；
- $E(G)$表示图 G 中顶点之间的关系（边）集合。
- 若 $V =\{ V_1,V_2,…,V_n\}$，则用$[V]$表示图 G 中顶点的个数
- $E=\{(u, v)| u∈V ,v∈V\}$, 用$[E]$表示图 G 中边的条数。
---
 - **有向图**：边有方向（如 A → B）。有向边E$<v,w>$的集合 #有向图
 - v,w 是定点
 - v是弧尾，w是弧头
 - **无向图**：边无方向（如 A - B）。无向边E$(v,w)$ #无向图
 - w,v 互为邻接点，边依附于w和v
 - **简单图**：不含自环、多重边的图。#简单图
 - 反之为多重图。
 - **完全图**：任意两个顶点之间都有边相连的图。#完全图
 - **度、出度、入度**：
- 无向图中**顶点的度**：与该顶点相连的边数。#度
- 有向图中：
- 出度：从该顶点出发的边数。#出度
- 入度：指向该顶点的边数。#入度
- 路径、**路径长度和回路**：
 - **路径**：顶点$v_p$到顶点$V_q$之间的顶点序列 $v_P,v_{i_1},v_{i_2},v_{i_m},v_{q}$
 - **路径长度**：路径上边的数目
 - **路径回路**：第一个顶点和最后一个顶点相同
 - 简单路径：顶点不重复出现
 - **简单回路**：除去第一个和最后一个，其余顶点不重复出现
- **距离**：最短路径存在时的最短路径；不存在路径距离记作$\infty$
- **子图**：图中部分顶点和边组成的图。
- 连通、连通图和连通分量
 - **连通**：在无向图里，有路径
 - **连通图**：任意两个点都连通 #连通图
 - **连通分量**：极大连通子图

---

## **6.2 图的存储及基本操作**

### 1. 邻接矩阵法（稠密图）
#邻接矩阵 用于表示图中顶点之间的连接关系，使用二维数组实现。![[考研学习笔记01-数据结构 06 图 2025-10-09 31.png]]
#无向图 的邻接矩阵表示:
    特点无向图的边无方向，每条边在矩阵中对应两个位置为1。
    例如：A与B相连，则A行B列和B行A列均为1。非连接情况A与E不相连，对应矩阵元素为0。
    总结：1表示顶点之间相连，0表示不连。
#有向图 的邻接矩阵表示：
    **方向性**：有向边只在一个方向表示为1，反方向为0。
    例如：A→B存在，A行B列为1；B→A不存在，B行A列为0。

区别总结无向图每条边对应两个1，有向图每条边对应一个1。

**求度**：#度
  - #无向图：行中的1的数
  - #有向图：入度+出度 行中的1+列中的1

时间复杂度：
- 优点：结构简单，易于实现。
- 缺点：空间复杂度为 O(n²)，空间复杂度太高。不适合稀疏图。

```c
#define MaxVertexNum 100 //顶点数目的最大值
typedef struct {
    char Vex[MaxVertexNum];// 顶点表
    int Edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵
    int vexnum, edgeNum; // 顶点数、边数
} MGraph;
```

#带权图：
![[6.2.1 邻接矩阵法.pdf#page=6&rect=256,214,476,437|6.2.1 邻接矩阵法, p.6]]

```c
//带权图
#define MaxVertexNum 100 //顶点数目的最大值
#define INFIITY 最大的int值//宏定义常量“无穷”
typedef char VertexType; //定点的数据类型
typedef int EdgeType ;  //带权图中边上权值的权值
typedef struct {
    VertexType Vex[MaxVertexNum];// 顶点
    EdgeType Edge[MaxVertexNum][MaxVertexNum]; //边的权
    int vexnum, arcnum; // 顶点数、弧数
} MGraph;
```

**性能分析**：
$O(n)+O(n^2)=O(|V|^2)$

```c
// 初始化图
void initGraph(MGraph *G, int n) {
G->vertexNum = n;
G->edgeNum = 0;
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
G->adjMatrix[i][j] = (i == j) ? 0 : INF;
}

// 添加边
void addEdge(MGraph *G, int u, int v, int weight) {
G->adjMatrix[u][v] = weight;
G->adjMatrix[v][u] = weight;
G->edgeNum++;
}

// 打印邻接矩阵
void printGraph(MGraph *G) {
for (int i = 0; i < G->vertexNum; i++) {
for (int j = 0; j < G->vertexNum; j++) {
if (G->adjMatrix[i][j] == INF)
printf("INF ");
else
printf("%3d ", G->adjMatrix[i][j]);
}
printf("\n");
}
}
```

- 邻接矩阵的n次方中，元素(i, j)表示从顶点i到j长度为n的路径数目。
### 2. 邻接表法
#邻接表 顺序存储+链式存储
- 每个顶点对应一个链表，链表中存储与该顶点相连的其他顶点。
- 优点：节省空间，适合稀疏图。
- 缺点：查找边效率较低。

```c
typedef struct EdgeNode {
int adjvex;
int weight;
struct EdgeNode *next;
} EdgeNode;

typedef struct VertexNode {
char data;
EdgeNode *first;
} VertexNode, AdjList[MAX_VERTEX_NUM];

typedef struct {
AdjList adjList;
int vertexNum, edgeNum;
} ALGraph;

// 创建邻接表图
void createALGraph(ALGraph *G, int n) {
G->vertexNum = n;
G->edgeNum = 0;

for (int i = 0; i < n; i++) {
G->adjList[i].data = 'A' + i;
G->adjList[i].first = NULL;
}
}

// 添加边
void addEdge_AL(ALGraph *G, int u, int v, int weight) {
EdgeNode *e1 = (EdgeNode *)malloc(sizeof(EdgeNode));
EdgeNode *e2 = (EdgeNode *)malloc(sizeof(EdgeNode));

e1->adjvex = v;
e1->weight = weight;
e1->next = G->adjList[u].first;
G->adjList[u].first = e1;

e2->adjvex = u;
e2->weight = weight;
e2->next = G->adjList[v].first;
G->adjList[v].first = e2;

G->edgeNum++;
}
```

### 3. 十字链表
- 适用于 #有向图，结合了 #邻接表 和逆邻接表的优点。
- 每条边用一个结点表示，包含起点、终点、指向下一个出边和入边的指针。

### 4. 邻接多重表
- 适用于 #无向图，边只存储一次，避免重复。
- 每条边被多个顶点共享。

### 5. 图的基本操作
- 创建图
- 插入/删除顶点或边
- 查找邻接点
- 获取顶点信息
- 判断是否连通等

---

## **6.3 图的遍历**
#遍历
### 1. 广度优先搜索（BFS）
- 类似树的层序遍历，使用 #队列 实现。
- 用于寻找 #最短路径（无权图）。

```c
#include <stdbool.h>
#include <queue>

void BFS(MGraph G, int start) {
bool visited[MAX_VERTEX_NUM] = {false};
int queue[MAX_VERTEX_NUM], front = 0, rear = 0;

visited[start] = true;
queue[rear++] = start;

while (front != rear) {
int u = queue[front++];
printf("%c ", 'A' + u);

for (int v = 0; v < G.vertexNum; v++) {
if (G.adjMatrix[u][v] != INF && !visited[v]) {
visited[v] = true;
queue[rear++] = v;
}
}
}
}
```

### 2. 深度优先搜索（DFS）
- 类似树的[[05 树与二叉树#1. 二叉树的遍历|先序遍历]]，使用 #栈 或 #递归 实现。
- 用于探索图的结构、寻找连通分量。

```c
void DFS(MGraph G, int u, bool visited[]) {
visited[u] = true;
printf("%c ", 'A' + u);

for (int v = 0; v < G.vertexNum; v++) {
if (G.adjMatrix[u][v] != INF && !visited[v])
DFS(G, v, visited);
}
}

void DFSTraverse(MGraph G) {
bool visited[MAX_VERTEX_NUM] = {false};

for (int i = 0; i < G.vertexNum; i++) {
if (!visited[i])
DFS(G, i, visited);
}
}
```

### 3. 图的遍历与图的连通性
- #无向图 中，从一个顶点出发能访问所有顶点 → 图是**连通图**。
- #有向图 中，若任意两个顶点之间都可相互到达 → 图是**强连通图**。

---

哈喽！你这份关于 **图的应用** 的笔记整理得非常全面和到位啊！从最小生成树、最短路径到拓扑排序、关键路径，核心算法和思想都涵盖了，还把相关的代码和时间复杂度都列出来了。太棒了！这正是 408 考研数据结构部分的重中之重，你抓得很准！

来，咱们再一起过一遍这份笔记，我帮你补充一些考研的侧重点、易混淆点和一些小细节，确保你不仅理解，还能灵活应用，拿捏大题！

## 6.4 图的应用
图的应用是数据结构中非常重要且常考的部分，特别是最小生成树、最短路径、拓扑排序和关键路径，几乎每年都会以选择题或大题的形式出现。理解它们的适用场景、算法原理及复杂度是高分必备！
#### 1. 最小生成树（MST - Minimum Spanning Tree）
*   **概念:** 对于一个带权连通 **无向图** `G`，连接所有顶点，且边的**权值之和**（代价）最小的子图，这棵树就是最小生成树。
    *   **强调:** 必须是 **无向图** 且 **连通**。
    *   **性质 (重要考点):**
        *   是图的连通子图
        * 不包含任何环
        * 边数等于顶点数减 1 (即 $|V|-1$ 条边)。
        * 如果图中各边权值互不相等，则最小生成树唯一（权值最小的边确实一定会出现在唯一的最小生成树中）；否则可能不唯一 (树形不唯一，但总权值唯一且最小)。
        *   当图 `G` 本身就是一棵树时，其最小生成树就是它本身。
*   **目标:** 构造一棵包含所有顶点的树，边的总权值最小。
*   **常用算法:**
    *   **Prim（普利姆）算法**[^1]：
        *   **核心思想:** **“加点法”**。从一个起始顶点开始，逐步向已生成的 MST 中添加顶点。每次都选择连接“已加入 MST 的顶点集合”和“未加入 MST 的顶点集合”之间权值最小的边。
        *   **适用场景:** **稠密图** (边数 $|E|$ 接近 $|V|^2$) 效率更高。
        *   **C 代码解析 (邻接矩阵实现):**
            *   `lowcost[i]`: 存储顶点 `i` 到当前 MST 中顶点的最小连接权值。
            *   `closest[i]`: 存储与顶点 `i` 建立 `lowcost[i]` 最小连接的 MST 中的顶点。
            *   `visited[i]`: 标记顶点 `i` 是否已加入 MST。
            *   **外层循环 (`for (int i = 1; i < G.vertexNum; i++)`):** 每次确定一个新加入 MST 的顶点。
            *   **内层循环 (`for (int j = 0; j < G.vertexNum; j++)`):** 寻找与当前 MST 连接的最小权值边所对应的未访问顶点 `u`。
            *   **更新 (`for (int v = 0; v < G.vertexNum; v++)`):** 发现新的顶点 `u` 后，以 `u` 为中介更新所有未访问顶点 `v` 到 MST 的最小连接权值。
        *   **时间复杂度:** $O(|V|^2)$ (使用邻接矩阵和数组实现)；若使用邻接表和最小堆/优先队列优化，可达 $O(|E|\log|V|)$ 或 $O(|E| + |V|\log|V|)$。
    *   **Kruskal（克鲁斯卡尔）算法**：
        *   **核心思想:** **“加边法”**。将图中所有边按权值从小到大排序，依次选择边。每次选择一条当前权值最小的边，如果加入这条边不形成环，则将其加入 MST。
        *   **如何判断是否形成环:** 通常使用 **并查集 (Union-Find Set)** 数据结构。
        *   **适用场景:** **稀疏图** (边数 $|E|$ 接近 $|V|$) 效率更高。
        *   **时间复杂度:** $O(|E|\log_2|E|)$ (主要消耗在边的排序和并查集操作)。

#### 2. 最短路径
*   **1. 单源最短路径 (从一个源点到所有其他顶点的最短路径)**
    *   **Dijkstra（迪杰斯特拉）算法**[^2]：
        *   **适用性:** **不能处理带负权值的边**。适用于边权值均为非负的图。
        *   **核心思想:** 贪心算法。与 Prim 算法类似，维护一个 `dist` 数组记录源点到各顶点的最短距离估计值，并每次从“未确定最短路径”的顶点中选择距离源点最近的顶点加入已确定集合，然后用该顶点松弛其邻接点。
        *   **C 代码解析 (邻接矩阵实现):**
            *   `dist[i]`: 存储源点 `start` 到顶点 `i` 的当前最短距离。
            *   `visited[i]`: 标记顶点 `i` 的最短路径是否已确定。
            *   **外层循环 (`for (int i = 0; i < G.vertexNum - 1; i++)`):** 每次确定一个顶点的最短路径。
            *   **内层循环 (`for (int j = 0; j < G.vertexNum; j++)`):** 寻找当前未访问顶点中 `dist` 最小的顶点 `u`。
            *   **松弛操作 (`if (dist[u] + G.adjMatrix[u][v] < dist[v])`):** 以 `u` 为中介，更新其邻接点 `v` 的 `dist` 值。
        *   **时间复杂度:** $O(|V|^2)$ (使用邻接矩阵和数组实现)；若使用邻接表和最小堆/优先队列优化，可达 $O(|E|\log|V|)$ 或 $O(|E| + |V|\log|V|)$。
    *   **Bellman-Ford（贝尔曼-福特）算法**：
        *   **适用性:** 可以处理 **带负权值的边**。
        *   **特点:** 还能 **检测图中是否存在负权环**（若存在负权环，则某些最短路径无意义）。
        *   **时间复杂度:** $O(|V||E|)$。
*   **2. 多源最短路径 (所有顶点对之间的最短路径)**
    *   **Floyd-Warshall（弗洛伊德-沃沙尔）算法**：
        *   **核心思想:** 动态规划。通过中间顶点 `k` 来更新任意两点 `i` 和 `j` 之间的最短路径。
        *   **适用性:** 可以处理 **带负权值的边** (但不能有负权环)。
        *   **时间复杂度:** $O(|V|^3)$。

#### 三、有向无环图（DAG - Directed Acyclic Graph）
*   **概念:** 没有环路的有向图。
*   **应用:**
    *   **表示表达式:** 如笔记中所述，可以用于优化编译、表达式求值，通过共享子表达式减少重复计算。
    *   **任务调度、课程先修关系:** 自然地表示带有先后顺序的任务流。
    *   **拓扑排序和关键路径** 的前提。

#### **四、拓扑排序**
*   **概念:** 对 **有向无环图 (DAG)** 的所有顶点进行线性排序，使得对于图中的任意一条有向边 `(u, v)`，顶点 `u` 在排序中都出现在顶点 `v` 之前。
*   **AOV 网 (Activity On Vertex Network - 顶点表示活动):** 拓扑排序主要应用于 AOV 网，其中顶点表示活动，有向边表示活动的先驱关系（即 `u -> v` 表示活动 `u` 必须在活动 `v` 之前完成）。
*   **实现方法:**
    *   **Kahn（卡恩）算法 (基于入度)**[^3]：
        *   **核心思想:**
            1.  计算所有顶点的入度 (指向该顶点的边数)。
            2.  将所有入度为 0 的顶点入队。
            3.  从队列中取出一个顶点并输出。
            4.  移除该顶点及其所有出边，并将其邻接点的入度减 1。
            5.  若邻接点入度变为 0，则入队。
            6.  重复 3-5 步，直到队列为空。
            7.  如果最后输出的顶点数小于总顶点数，则图中存在环，无法进行拓扑排序。
        *   **C++ 代码解析:**
            *   `inDegree` 数组存储每个顶点的入度。
            *   使用 `queue` 存储入度为 0 的顶点。
            *   循环直到队列为空，每次出队一个顶点并处理其邻接点。
        *   **时间复杂度:** $O(|V|+|E|)$ (使用邻接表和队列实现)。
    *   **DFS 逆序法 (基于深度优先遍历)**：
        *   对图进行 DFS 遍历，在每个顶点 **回溯 (所有邻接点都访问完毕)** 时，将其加入一个栈或列表。最终栈中元素的逆序或列表的顺序就是拓扑排序结果。
*   **应用:** 任务调度、课程安排、编译器的依赖分析等。

#### **五、关键路径**
*   **概念:** 针对 **AOE 网 (Activity On Edge Network - 边表示活动)**。在 AOE 网中，从源点到汇点的所有路径中，**路径长度最长** 的那条路径称为关键路径。
    *   **AOE 网与 AOV 网的区别:**
        *   **AOV 网 (Activity On Vertex):** 顶点代表活动，边代表活动间的优先关系 (拓扑排序)。
        *   **AOE 网 (Activity On Edge):** 边代表活动，边的权值代表活动持续时间；顶点代表事件 (活动的开始或结束)。
*   **关键路径的意义:** 决定了整个工程的最短完成时间。关键路径上的活动称为 **关键活动**，任何一个关键活动的延迟都会导致整个工程的延迟。
*   **求解步骤 (5 个核心值):**
    1.  **求所有事件的最早发生时间 `ve(i)`：** 从源点开始，进行拓扑排序式的正向计算。`ve(i)` 表示事件 `i` 能够发生的最早时间。
    2.  **求所有事件的最迟发生时间 `vl(i)`：** 从汇点开始，进行逆拓扑排序式的反向计算。`vl(i)` 表示在不延迟整个工程的前提下，事件 `i` 最迟必须发生的时间。
    3.  **求所有活动的最早发生时间 `e(k)`：** 对于活动 `k=(i, j)`（从事件 `i` 到事件 `j`，权值为 `weight(k)`），`e(k) = ve(i)`。
    4.  **求所有活动的最迟发生时间 `l(k)`：** 对于活动 `k=(i, j)`，`l(k) = vl(j) - weight(k)`。
    5.  **求所有活动的时间余量 `d(k)`：** `d(k) = l(k) - e(k)`。时间余量为 `0` 的活动就是 **关键活动**。所有关键活动组成的路径就是关键路径。
*   **时间复杂度:** 通常需要两次拓扑排序（正向计算 `ve`，逆向计算 `vl`），因此是 $O(|V|+|E|)$。
*   **考点提示:** 大题常考，要求计算所有 `ve`, `vl`, `e`, `l`, `d` 值，并找出关键路径。

---
## ✅ 示例主函数

```c
int main() {
MGraph G;
initGraph(&G, 5);
addEdge(&G, 0, 1, 1);
addEdge(&G, 0, 2, 5);
addEdge(&G, 1, 2, 3);
addEdge(&G, 1, 3, 7);
addEdge(&G, 2, 4, 1);
addEdge(&G, 3, 4, 2);

printf("邻接矩阵表示：\n");
printGraph(&G);

printf("BFS遍历：");
BFS(G, 0);
printf("\n");

printf("DFS遍历：");
DFSTraverse(G);
printf("\n");

printf("Prim最小生成树（从A开始）：\n");
prim(G, 0);

printf("Dijkstra最短路径（从A开始）：\n");
dijkstra(G, 0);

return 0;
}
```

---

## ✅ 小结

| 功能 | 函数名 | 说明 |
|------|--------|------|
| 图的创建 | `initGraph` / `createALGraph` | 邻接矩阵 / 邻接表 |
| 添加边 | `addEdge` / `addEdge_AL` | 添加图的边 |
| 遍历 | `BFS` / `DFSTraverse` | 广度优先 / 深度优先 |
| 最小生成树 | `prim` | Prim算法 |
| 最短路径 | `dijkstra` | Dijkstra算法 |
| 拓扑排序 | `topologicalSort` | Kahn算法 |

---
## 🧠 不同算法的时间复杂度

| 算法       | 时间复杂度      | 数据结构 | 适用场景         |
| -------- | ---------- | ---- | ------------ |
| BFS      | O(V + E)   | 邻接表  | 连通性、最短路径（无权） |
| DFS      | O(V + E)   | 邻接表  | 连通分量、环检测     |
| Prim     | O(V²)      | 邻接矩阵 | 稠密图最小生成树     |
| Kruskal  | O(E log E) | 邻接表  | 稀疏图最小生成树     |
| Dijkstra | O(E log V) | 邻接表  | 单源最短路径（无负权）  |
| 拓扑排序     | O(V + E)   | 邻接表  | 任务调度         |
| 关键路径     | O(V + E)   | 邻接表  | 工程计划优化       |

[^1]: ```c
    //最小生成树Prim算法
    // MGraph G 是图的邻接矩阵表示，start 是起始顶点索引
    void prim(MGraph G, int start) {
        int lowcost[MAX_VERTEX_NUM], closest[MAX_VERTEX_NUM]; // lowcost 记录到MST的最小边权，closest 记录该边的另一个顶点
        bool visited[MAX_VERTEX_NUM] = {false}; // 标记顶点是否已加入MST
    
        // 初始化：从起始顶点 start 出发，初始化所有顶点到 start 的距离
        for (int i = 0; i < G.vertexNum; i++) {
            lowcost[i] = G.adjMatrix[start][i]; // 顶点 i 到 start 的权值
            closest[i] = start;                 // 顶点 i 到 MST 的最近顶点是 start
        }
    
        visited[start] = true; // 将起始顶点标记为已访问，加入MST
    
        // 循环 |V|-1 次，每次找到一个新顶点加入MST
        for (int i = 1; i < G.vertexNum; i++) {
            int min = INF, u = -1; // min 记录当前最小权值，u 记录对应的顶点
    
            // 找到当前未加入MST的顶点中，lowcost最小的顶点 u
            for (int j = 0; j < G.vertexNum; j++) {
                if (!visited[j] && lowcost[j] < min) {
                    min = lowcost[j];
                    u = j;
                }
            }
    
            if (u == -1) break; // 如果没有找到，说明图不连通或已完成
    
            visited[u] = true; // 将顶点 u 加入MST
            // 打印新加入的边
            printf("Edge: %c-%c, Weight: %d\n", 'A' + closest[u], 'A' + u, lowcost[u]);
    
            // 更新所有未加入MST的顶点到 u 的距离
            for (int v = 0; v < G.vertexNum; v++) {
                // 如果 v 未访问，且 u-v 的边权值比 lowcost[v] 小，则更新
                if (!visited[v] && G.adjMatrix[u][v] < lowcost[v]) {
                    lowcost[v] = G.adjMatrix[u][v]; // 更新 v 到MST的最小边权
                    closest[v] = u;                 // 更新 v 到MST的最近顶点
                }
            }
        }
    }
    ```

[^2]: ```c
    // #Dijkstra算法
    // MGraph G 是图的邻接矩阵表示，start 是源点索引
    void dijkstra(MGraph G, int start) {
        int dist[MAX_VERTEX_NUM];         // dist[i] 记录源点到顶点 i 的最短距离
        bool visited[MAX_VERTEX_NUM] = {false}; // visited[i] 标记顶点 i 的最短路径是否已确定
    
        // 初始化：源点到自身距离为0，到其他顶点的距离为直接边权
        for (int i = 0; i < G.vertexNum; i++) {
            dist[i] = G.adjMatrix[start][i];
        }
        dist[start] = 0; // 源点到自身距离为0
    
        visited[start] = true; // 将源点标记为已访问，最短路径已确定
    
        // 循环 |V|-1 次，每次确定一个顶点的最短路径
        for (int i = 0; i < G.vertexNum - 1; i++) {
            int u = -1, min = INF; // u 记录当前未确定最短路径顶点中，dist最小的顶点
    
            // 找到当前未确定最短路径的顶点中，dist最小的顶点 u
            for (int j = 0; j < G.vertexNum; j++) {
                if (!visited[j] && dist[j] < min) {
                    min = dist[j];
                    u = j;
                }
            }
    
            if (u == -1) break; // 如果没有找到，说明图不连通或已完成
    
            visited[u] = true; // 将顶点 u 标记为已访问，最短路径已确定
    
            // 以 u 为中介点，松弛所有未访问的邻接点 v
            for (int v = 0; v < G.vertexNum; v++) {
                // 如果 v 未访问，且 u-v 之间有边，并且通过 u 到 v 的路径更短
                if (!visited[v] && G.adjMatrix[u][v] != INF && dist[u] + G.adjMatrix[u][v] < dist[v]) {
                    dist[v] = dist[u] + G.adjMatrix[u][v]; // 更新 dist[v]
                }
            }
        }
    
        // 打印结果
        printf("Shortest distances from %c:\n", 'A' + start);
        for (int i = 0; i < G.vertexNum; i++) {
            printf("%c: %d\n", 'A' + i, dist[i]);
        }
    }
    ```

[^3]: ```c
    // #Kahn算法
    // ALGraph G 是图的邻接表表示
    #include <queue> // C++ 的 queue，这里假设是C++环境，如果是纯C需要自己实现队列
    
    void topologicalSort(ALGraph G) {
        int inDegree[MAX_VERTEX_NUM] = {0}; // 记录每个顶点的入度
        // int queue[MAX_VERTEX_NUM], front = 0, rear = 0; // 如果是C语言，用数组模拟队列
        std::queue<int> q; // C++ 标准库队列
    
        // 计算所有顶点的入度
        for (int u = 0; u < G.vertexNum; u++) {
            EdgeNode *e = G.adjList[u].first; // 遍历 u 的所有出边
            while (e != NULL) {
                inDegree[e->adjvex]++; // 邻接点的入度加1
                e = e->next;
            }
        }
    
        // 将所有入度为0的顶点入队
        for (int i = 0; i < G.vertexNum; i++) {
            if (inDegree[i] == 0)
                q.push(i); // 入队
        }
    
        // 循环直到队列为空
        while (!q.empty()) {
            int u = q.front(); // 取出队头顶点
            q.pop();           // 出队
            printf("%c ", G.adjList[u].data); // 输出该顶点（进行拓扑排序）
    
            // 遍历 u 的所有邻接点 v
            EdgeNode *e = G.adjList[u].first;
            while (e != NULL) {
                inDegree[e->adjvex]--; // 邻接点 v 的入度减1
                // 如果 v 的入度变为0，则将其入队
                if (inDegree[e->adjvex] == 0)
                    q.push(e->adjvex);
                e = e->next;
            }
        }
    }
    ```
