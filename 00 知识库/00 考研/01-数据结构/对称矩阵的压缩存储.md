---
科目: 
课程名称: 
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度: 
考频: 
备注:
---

# 对称矩阵的压缩存储

## **对称矩阵**

**对称矩阵**是指一个矩阵，其元素满足 `a[i][j] = a[j][i]` 的性质。也就是说，矩阵关于主对角线对称。例如：

```
1 2 3
2 4 5
3 5 6
```

在这个矩阵中，`a[0][1] = a[1][0]`，`a[0][2] = a[2][0]`，依此类推。

## **为什么需要压缩存储？**

对称矩阵的对称性意味着我们可以只存储矩阵的一半（上三角或下三角），从而节省存储空间。例如，对于一个 `n x n` 的对称矩阵，我们只需要存储 `n(n+1)/2` 个元素，而不是 `n^2` 个元素。

## **压缩存储方法**

## **示例**

假设我们有一个 `3 x 3` 的对称矩阵 `A`：

```
1 2 3
2 4 5
3 5 6
```

我们可以选择存储下三角部分：

```
1
2 4
3 5 6
```

将其存储在一维数组 `B` 中：

```
B = [1, 2, 4, 3, 5, 6]
```

## **C语言实现**

下面是一个简单的C语言实现，展示如何将对称矩阵的下三角部分存储在一维数组中，并从中读取元素。

```c
#include <stdio.h>

#define N 3  // 矩阵的大小

// 计算下三角部分的索引
int get_index(int i, int j) {
    if (i >= j) {
        return i * (i + 1) / 2 + j;
    } else {
        return j * (j + 1) / 2 + i;
    }
}

int main() {
    // 原始对称矩阵
    int A[N][N] = {
        {1, 2, 3},
        {2, 4, 5},
        {3, 5, 6}
    };

    // 一维数组用于存储下三角部分
    int B[N * (N + 1) / 2];

    // 将对称矩阵的下三角部分存储到一维数组中
    for (int i = 0; i < N; i++) {
        for (int j = 0; j <= i; j++) {
            B[get_index(i, j)] = A[i][j];
        }
    }

    // 打印一维数组
    printf("Compressed array B: ");
    for (int i = 0; i < N * (N + 1) / 2; i++) {
        printf("%d ", B[i]);
    }
    printf("\n");

    // 从一维数组中读取并打印原始矩阵
    printf("Original matrix A:\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", B[get_index(i, j)]);
        }
        printf("\n");
    }

    return 0;
}
```

## **解释**

1. **定义矩阵和一维数组**：
    - `A` 是原始的对称矩阵。
    - `B` 是用于存储下三角部分的一维数组。

2. **存储下三角部分**：
    - 使用双重循环遍历矩阵的下三角部分，并将元素存储到 `B` 中。

3. **读取和打印**：
    - 从 `B` 中读取元素并打印出原始矩阵 `A`。

## **运行结果**

假设输入的矩阵是：

```
1 2 3
2 4 5
3 5 6
```

运行结果应该是：

```
Compressed array B: 1 2 4 3 5 6 
Original matrix A:
1 2 3 
2 4 5 
3 5 6 
```
