---
科目:
课程名称:
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
aliases: 04 串, 04 串
---

# 04 串
## 4.1 串的定义和基本操作

### 1. 串的定义和基本操作
#### 串的定义
**串 (string)** (或字符串）是由零个或多个字符组成的有限序列，一般记为
$s ='a_1,a_2 …a_n'(n≥0)$
其中，s 是**串的名**，用单引号括起来的字符序列是**串的值**；
$a_{(1~n)}$ 可以是字母、数字或其他字符；
串中字符的数目 n 称为**串的长度**。
零个字符的串称为**空串 (null string)**, 它的长度为零。

串是一种特殊的线性表，数据元素之间呈线性关系
串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）

串的基本操作，如增删改查等**通常以子串为操作对象**
串中任意个连续的字符组成的子序列称为该串的子串。
包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以**子串的第一个字符**在主串中的位置来表示。

#### 串的基本操作
	`假设有串T="",S="iPhone 11 Pro Max?",W="Pro"`  
**trAssign(&T,chars)**：赋值操作。把串T赋值为chars。
**StrCopy(&T,S)**：复制操作。由串S复制得到串T。
**StrEmpty(S)**：判空操作。若S为空串，则返回TRUE，否则返回FALSE。**StrLength(S)**：求串长。返回串S的元素个数。
**ClearString(&S)**：清空操作。将S清为空串。
**DestroyString(&S)**：销毁串。将串S销毁（回收存储空间）。
**Concat(&T,S1,S2)**：串联接。用T返回由S1和S2联接而成的新串
**SubString(&Sub,S,pos,len)**：求子串。用Sub返回串S的第pos个字符起长度为len的子串。
**Index(S,T)**：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。
**StrCompare(S,T)**：比较操作。若S>T，则返回值>0；若S=T，则返回值=0；若S<T，则返回值<0。
	![[4.1.1 串的定义和基本操作.pdf#page=8&rect=399,74,846,384|4.1.1 串的定义和基本操作, p.8]]
#### 字符集编码
y = f(x) 字符集：函数定义域编码：函数映射规则 f y：对应的二进制数
任何数据存到计算机中一定是二进制数。
需要确定一个字符和二进制数的对应规则这就是"编码"
"字符集"：
	英文字符——ASCII字符集
	中英文——Unicode字符集
	基于同一个字符集，可以有多种编码方案，如：UTF-8，UTF-16

	注：采用不同的编码方式，每个字符所占空间不同，考研中只需默认每个字符占1B即可

#### 乱码问题
在你的文件中，原本采用某一套编码规则y=f(x)，如 : '码'↔0001010100010101010010
打开文件时，你的软件以为你采用的是另一套编码规则y=g(x)，如：0001010100010101010010↔

### 2. 储存结构

####  一、串的基本定义

**串（字符串）**是由零个或多个字符组成的有限序列，记作：

```
s = 'a1a2…an'  (n ≥ 0)
```

- `s` 是串的名字；
- 单引号括起来的字符序列是串的值；
- `ai` 是串中的字符，可以是字母、数字、符号等；
- `n` 是串的**长度**；
- 当 `n=0` 时，称为空串（用 `ε` 或 `""` 表示）；
- 串中任意连续字符组成的子序列为该串的**子串**；
- 包含子串的串称为主串；
- 子串的位置由其第一个字符在主串中的位置表示。

✅ 示例
- `a = 'BEI'`，长度为 3；
- `b = 'JING'`，长度为 4；
- `c = 'BEIJING'`，长度为 7；
- `d = 'BEI JING'`，长度为 8；
- `a` 和 `b` 都是 `c` 和 `d` 的子串；
- `a` 在 `c` 和 `d` 中的位置都是 1；
- `b` 在 `c` 中位置是 4，在 `d` 中位置是 5。

---

#### 二、串的相等性

两个串相等的**充分必要条件**：

- 长度相同；
- 对应位置上的字符都相等。

例如，`a`、`b`、`c`、`d` 四个串彼此都不相等。

---

#### 三、串与线性表的异同

| 比较点 | 线性表 | 串 |
|--------|--------|----|
| 数据对象 | 任意元素 | 字符集 |
| 操作对象 | 单个元素 | 串整体 |
| 操作类型 | 插入、删除、查找单个元素 | 查找子串、拼接、替换、插入子串等 |

---

#### 四、串的抽象数据类型（ADT）

```text
ADT String {
  数据对象：D = { a_i | a_i ∈ CharacterSet, i = 1,2,...,n, n ≥ 0 }
  数据关系：R1 = { <a_{i-1}, a_i> | i = 2,3,...,n }
  基本操作：
    StrAssign(&T, chars)       // 串赋值
    StrCopy(&T, S)             // 串复制
    StrEmpty(S)                // 判断是否为空
    StrCompare(S, T)           // 比较串大小
    StrLength(S)               // 获取串长度
    ClearString(&S)            // 清空串
    Concat(&T, S1, S2)         // 串联接
    SubString(&Sub, S, pos, len) // 求子串
    Index(S, T, pos)           // 定位子串
    Replace(&S, T, V)          // 替换子串
    StrInsert(&S, pos, T)      // 插入子串
    StrDelete(&S, pos, len)    // 删除子串
    DestroyString(&S)          // 销毁串
}
```

---

#### 五、最小操作集

在上述操作中，有**5个操作**是**不可由其他操作实现**的，称为**最小操作集**：

1. `StrAssign`（串赋值）
2. `StrCompare`（串比较）
3. `StrLength`（求长度）
4. `Concat`（串联接）
5. `SubString`（求子串）

其他操作（如 `Index`、`Replace`、`Insert`、`Delete`）都可以基于这5个操作来实现。

---

#### 六、Index 操作的实现示例（算法 4.1）

```c
int Index(String S, String T, int pos) {
    if (pos > 0) {
        int n = StrLength(S);
        int m = StrLength(T);
        int i = pos;
        String sub;
        while (i <= n - m + 1) {
            SubString(sub, S, i, m);
            if (StrCompare(sub, T) != 0)
                ++i;
            else
                return i;
        }
    }
    return 0;
}
```

✅ 算法思想

- 从主串 `S` 的第 `pos` 个字符开始；
- 每次取一个与 `T` 等长的子串；
- 与 `T` 比较，若相等则返回位置 `i`；
- 否则继续向后移动一个字符；
- 若找不到匹配子串，则返回 0。

---

#### 七、空串与空格串的区别

| 类型 | 名称 | 示例 | 长度 |
|------|------|------|------|
| 空串 | null string | `""` | 0 |
| 空格串 | blank string | `"   "` | 空格数 |

> ⚠️ 注意：空串和空格串是不同的，空格串不是空串！

---

#### 八、应用中的注意事项

- 单引号用于**标识字符串常量**，不属于串本身；
- 在程序设计语言中，例如 `x = '123';` 表示变量 `x` 的值是字符串 `'123'`；
- 空格是合法字符，可以出现在字符串中间；
- 串的基本操作应以所使用语言的参考手册为准。

---

#### 总结

| 概念 | 内容 |
|------|------|
| 串 | 由字符组成的有限序列 |
| 子串 | 连续字符组成的子序列 |
| 串相等 | 长度相同且对应字符相等 |
| 空串 | 长度为0的串 |
| 空格串 | 由空格组成的串，不是空串 |
| 最小操作集 | StrAssign, StrCompare, StrLength, Concat, SubString |
| Index 实现 | 利用 SubString 和 StrCompare 实现查找子串位置 |

## 4.2 串的模式匹配
---
### 1. 简单的模式匹配算法 (Brute Force / 暴力匹配法)
#暴力匹配法
想象一下，你手里拿着一本厚厚的《数据结构》教材（**主串 Text**），想在里面找到"KMP算法"（**模式串 Pattern**）这几个字。
最笨但最直接的方法是什么？
- **第一步**：从书的第一页第一个字开始，一个字一个字地对照"KMP算法"。
- **第二步**：如果发现某个字对不上（比如书上是"KMP算**法**"，你模式串是"KMP算**法**"，哦，这个例子不好，假设书上是"KMP算**法**"，你模式串是"KMP算**法**"，发现"法"和"法"对上了，但如果书上是"KMP算**法**"，你模式串是"KMP算**法**"，发现"法"和"法"对不上），那就说明从这个位置开始找是错的。
- **第三步**：怎么办？你只好把模式串往后挪**一个字**，然后从头再来，重新对照。
这就是**简单的模式匹配算法**，也叫**暴力匹配法**。

```c
//朴素模式匹配算法
int Index(SSstring S,SString T){
    int i=1,j=1;
    while(i<=S.length && j<=T.length){
        if(S.ch[i]==T.ch[j]){
            i++;
            j++;
        }
        else{
            i=i-j+2;
            j=1;
        }
    }
    if(j>T.length)
        return i-T.length;
    else
        return 0;
}
//最坏的时间复杂度为O(mn)
//平均时间复杂度为O(m+n)
```

**它的特点：**
- **简单粗暴**：容易理解和实现。
- **效率不高**：在最坏情况下，比如主串是 `AAAAAAAAB`，模式串是 `AAAB`，每次都只差最后一个字符才不匹配，然后模式串只挪动一位，导致大量的重复比较。
- #时间复杂度：最坏情况下是 $O(m \times n)$，其中 $n$ 是主串长度，$m$ 是模式串长度。如果主串和模式串都很长，那效率就非常感人了。

---

### 2. 串的模式匹配算法——KMP算法
暴力匹配法的问题在于，每次不匹配时，模式串都只"傻傻地"往后挪一位。但我们人类找东西时，会更聪明：如果我知道"KMP算法"的"KMP"已经对上了，但"算"字对不上，我肯定不会从头再找"KMP"了，我会根据已经对上的部分信息，跳过一些不可能的位置。

#KMP算法（Knuth-Morris-Pratt算法）就是这样一种"聪明"的算法。它的核心思想是：

**当模式串与主串发生不匹配时，我们不需要将模式串完全回溯到起始位置，而是根据模式串自身的特点，计算出应该"跳过"多少位，从而避免不必要的比较。**

这个"模式串自身的特点"就是通过一个叫做 **`next` 数组**（或者叫 **`pi` 数组**）来记录的。

```c
//KMP 算法的实现步骤
int Index_KMP(SString S,SString T,int T,int next[]) //KMP 算法
{
    int i=1,j=1;
    while (i<=S.length && j<=T.length){ //从主串和子串的第1个字符开始比较
        if(j==0 || S.ch[i]==T.ch[j]){ //若j=0或字符相等，则i和j均向后移一位
            i++;
            j++;
        }
        else
            j=next[j];
    }
    if(j>T.length)
        return i-T.length;
    else
        return 0;
}
//最坏的时间复杂度为O(m+n)
```

#### `next` 数组是什么？

`next` 数组记录了模式串中，每个前缀的最长**公共前后缀**的长度。

- **前缀**：从字符串开头开始的子串。
- **后缀**：从字符串结尾结束的子串。
- **公共前后缀**：一个子串既是前缀又是后缀。
- **最长**：在所有公共前后缀中，长度最长的那个。
- **"真"前缀/后缀**：不包括字符串本身。

**举个例子：模式串 `P = "ABABCAB"`**

| 模式串前缀     | 长度  | 所有真前缀                    | 所有真后缀                    | 最长公共前后缀 | `next` 值 (长度) |
| :-------- | :-- | :----------------------- | :----------------------- | :------ | :------------ |
| `A`       | 1   | -                        | -                        | -       | 0             |
| `AB`      | 2   | `A`                      | `B`                      | -       | 0             |
| `ABA`     | 3   | `A`, `AB`                | `A`, `BA`                | `A`     | 1             |
| `ABAB`    | 4   | `A`, `AB`, `ABA`         | `B`, `AB`, `BAB`         | `AB`    | 2             |
| `ABABC`   | 5   | `A`, `AB`, `ABA`, `ABAB` | `C`, `BC`, `ABC`, `BABC` | -       | 0             |
| `ABABCA`  | 6   | `A`, `AB`, …, `ABABC`    | `A`, `CA`, …, `BABC`     | `A`     | 1             |
| `ABABCAB` | 7   | `A`, `AB`, …, `ABABCA`   | `B`, `AB`, …, `BABCAB`   | `AB`    | 2             |

所以，模式串 `P = "ABABCAB"` 的 `next` 数组就是 `[0, 0, 1, 2, 0, 1, 2]`。

#### `next`数组的手算
`next[1]` 任何都是0
`next[2]` 任何都是1
`next[3]` 计算
#### `next` 数组的意义

当模式串的第 `j` 个字符与主串不匹配时，`next[j-1]`（注意，这里是 `j-1`，因为 `next` 数组通常是针对模式串的**前缀**而言的，`next[k]` 表示长度为 `k+1` 的前缀的公共前后缀长度）的值告诉我们，模式串应该向右移动多少位，使得模式串中长度为 `next[j-1]` 的前缀与主串中已经匹配的部分的后缀对齐。

简单来说，就是：**如果 `P[j]` 匹配失败，那么模式串的下一个比较位置是 `P[next[j-1]]`。**

### KMP算法的匹配过程

1. 初始化主串指针 `i = 0`，模式串指针 `j = 0`。
2. **比较**：`Text[i]` 和 `Pattern[j]`。
    - **如果匹配** (`Text[i] == Pattern[j]`)：`i++`, `j++`。继续比较下一个字符。
    - **如果不匹配** (`Text[i] != Pattern[j]`)：
        - 如果 `j == 0`（模式串的第一个字符就没匹配上）：`i++`（主串指针后移），`j` 保持 `0`。
        - 如果 `j > 0`：`j = next[j-1]`。模式串指针回溯到 `next[j-1]` 的位置，主串指针 `i` 不变。
3. **终止条件**：
    - 如果 `j == m`（模式串长度），说明模式串完全匹配成功，返回匹配的起始位置 `i - m`。
    - 如果 `i == n`（主串遍历完），说明主串中没有找到模式串，返回 -1。

**KMP算法的时间复杂度**：
- **构建 `next` 数组**：$O(m)$
- **匹配过程**：$O(n)$
- **总时间复杂度**：$O(m + n)$

这比暴力匹配法大大提高了效率！

---

### 3. KMP算法的进一步优化 (`nextval` 数组)

KMP算法已经很棒了，但它还有一个小小的"瑕疵"。

**问题**：
假设模式串是 `P = "AAAAAB"`，`next` 数组可能是 `[0, 1, 2, 3, 4, 0]`。
当 `P[5]` (即 `B`) 与主串不匹配时，`next[4]` 是 `4`。这意味着模式串会移动，使得 `P[4]` (即 `A`) 与主串中当前 `Text[i]` 对齐。
但是，如果 `Text[i]` 也是 `A`，那么 `P[4]` 仍然会匹配失败！因为我们知道 `P[4]` 是 `A`，而 `P[5]` 也是 `A`，如果 `P[5]` 匹配失败，那么 `P[4]` 肯定也会匹配失败。这样就造成了不必要的比较。

为了解决这个问题，我们引入了 **`nextval` 数组**。

#### `nextval` 数组是什么？

`nextval` 数组是对 `next` 数组的优化。它在计算 `next[j]` 的基础上，增加了一个判断：
**如果 `P[j]` 的下一个匹配位置 `P[next[j-1]]` 处的字符与 `P[j]` 相同，那么就直接跳到 `P[next[next[j-1]]]`，直到找到一个不同的字符或者跳到 `0`。**

简单来说：
- `nextval[j] = next[j]`，如果 `P[j]` 与 `P[next[j]]` 不相等。
- `nextval[j] = nextval[next[j]]`，如果 `P[j]` 与 `P[next[j]]` 相等。

**举个例子：模式串 `P = "AAAAAB"`**

| 模式串前缀 | `next` 值 | `P[j]` | `P[next[j]]` | `nextval` 值 |
| :--------- | :-------- | :----- | :----------- | :----------- |
| `A`        | 0         | `P[0]`=`A` | -            | 0            |
| `AA`       | 1         | `P[1]`=`A` | `P[0]`=`A`   | `nextval[0]`=0 |
| `AAA`      | 2         | `P[2]`=`A` | `P[1]`=`A`   | `nextval[1]`=0 |
| `AAAA`     | 3         | `P[3]`=`A` | `P[2]`=`A`   | `nextval[2]`=0 |
| `AAAAA`    | 4         | `P[4]`=`A` | `P[3]`=`A`   | `nextval[3]`=0 |
| `AAAAAB`   | 0         | `P[5]`=`B` | `P[-1]` (无效) | 0            |

所以，`P = "AAAAAB"` 的 `next` 数组是 `[0, 1, 2, 3, 4, 0]`，而 `nextval` 数组是 `[0, 0, 0, 0, 0, 0]`。
这样，当 `P[5]` (B) 匹配失败时，`j` 会直接跳到 `0`，而不是先跳到 `4` (A)，再跳到 `3` (A)，再跳到 `2` (A)… 减少了不必要的比较。

#### `nextval` 数组的匹配过程
与使用 `next` 数组的匹配过程基本相同，只是在不匹配时，将 `j = next[j-1]` 替换为 `j = nextval[j-1]`。

**KMP算法（使用 `nextval`）的 #时间复杂度**：
- **构建 `nextval` 数组**：$O(m)$
- **匹配过程**：$O(n)$
- **总时间复杂度**：仍然是 $O(m + n)$。虽然渐进时间复杂度没有改变，但在某些特定情况下，`nextval` 确实能减少实际的比较次数，提高常数因子上的效率。

---
