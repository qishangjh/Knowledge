---
科目: "408"
课程名称: 操作系统
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 03 内存管理-存储系统
#OS #计组 #存储系统 #地址转换 #分页管理

## 03-1 课程目标与内容概览

* **课程目标**：
    * 帮助学生理解操作系统与计算机组成原理中存储系统的底层机制。
    * 通过图示与实例打通知识点之间的联系，提升对地址转换的理解。
* **课程材料**：提供了"机组+操作系统存储系统骚图"（基础版）和"存储系统骚图pro"（进阶版）。
* **重点章节**：王道书 `3.2小节`（虚拟分页存储管理）及其课后真题。

## 03-2 虚拟分页存储管理：考点趋势

* **历年真题趋势**：截至目前，考研大题中，内存管理部分**只考察过"请求页式存储管理"**，从未考过分段式或段页式管理。
* **原因分析**：
    1. **大纲引导**：考研大纲在"虚拟内存管理"部分只明确提到了"请求页式管理"。
    2. **技术发展趋势**：段式管理（1970-1980年代流行），段页式管理（1980-1990年代流行），而**纯页式存储管理**是1990年代至今现代操作系统最流行、最通用和优秀的解决方案。考题更倾向于贴近现代技术。
* **复习策略**：将重点放在**页式存储管理**。段式和段页式管理可作为次要复习内容（主要在选择题考察），除非时间非常充裕。

## 03-3 虚拟地址与物理地址转换流程
### 1. 地址转换基本原理
* **CPU访问**：CPU执行指令（取指令）或访问数据（取数据）时，使用的都是**虚拟地址 (VA - Virtual Address)**。
* **内存访问**：CPU必须将虚拟地址转换为**物理地址 (PA - Physical Address)** 后，才能访问实际的物理内存（主存）。
* **转换依赖**：地址转换过程主要依赖于**页表 (Page Table)** 和 **TLB (Translation Lookaside Buffer)**。
    * `页表`：存储在内存中，也称**慢表**。
    * `TLB`：CPU内部的高速缓存，也称**快表**。

### 2. 地址的组成与拆分（示例：36位虚拟地址，32位物理地址）

* **假设系统参数**：
    * **虚拟地址**：36比特。
    * **物理地址**：32比特（对应4GB物理内存，即 $2^{32}$ 字节）。
    * **页面大小**：4KB（$2^{12}$ 字节）。
    * **编址方式**：按字节编址。
* **虚拟地址 (VA) 结构**：
    * `低12位`：**页内偏移量 (Offset)**，表示在页中的具体位置（因为页面大小是4KB）。
    * `高24位`：**虚拟页号 (VPN - Virtual Page Number)**。
* **物理地址 (PA) 结构**：
    * `低12位`：**页内偏移量 (Offset)**，与虚拟地址的页内偏移量相同。
    * `高20位`：**物理页框号 (PFN - Page Frame Number)**。

### 3. CPU如何获取虚拟地址
* **取指令**：CPU的**程序计数器 (PC)** 寄存器中保存的是下一条要执行指令的**虚拟地址**。
* **取数据**：当前执行的指令（存储在**指令寄存器 IR** 中）会包含要访问数据的**内存地址相关信息**（操作数）。这些信息结合指令的**寻址方式**（如寄存器间接寻址、基址寻址等）计算出数据的**虚拟地址**。

### 4. 页表 (Page Table) 的结构与作用
* **本质**：页表本质上是一个**数组**。
* **页表项 (PTE - Page Table Entry)**：
    * `本质`：页表数组中的每个元素，可以理解为一个 `struct` 结构体。
    * `内容`：一个页表项包含以下关键字段：
        * `有效位 (Valid Bit)`：1表示页面已在内存中，0表示页面不在内存中（可能在外存）。
        * `页框号 (Page Frame Number)`：页面在物理内存中的起始物理块号。
        * `外存地址 (Disk Address)`：当页面不在内存时，指示其在外存中的位置。
        * `脏位 (Dirty Bit)`：1表示页面内容被修改过，0表示未修改。
        * `访问位 (Accessed Bit)`：1表示页面被访问过，0表示未访问。
        * `保护位 (Protection Bit)`：控制页面的读/写/执行权限。
* **页号的隐含性**：对于单级页表，虚拟页号作为数组的**下标**，是隐含在页表结构中的。
* **页表项的随机访问**：由于每个页表项大小固定，通过页表起始地址、虚拟页号（下标）、页表项大小，硬件可以**直接计算**出对应页表项的物理地址，实现**随机访问**。

### 5. 虚拟地址到物理地址转换的整体流程
1. **VA拆分**：CPU获取虚拟地址 (VA)，将其拆分为**虚拟页号 (VPN)** 和 **页内偏移量 (Offset)**。
2. **查TLB (快表)**：首先使用 **VPN** 去查询 **TLB**。
    * `TLB命中`：若TLB中存在匹配的VPN且有效位为1，则直接从TLB中获取**物理页框号 (PFN)**。
    * `TLB未命中`：若TLB中没有匹配项，或匹配项的有效位为0，则需要进行下一步，查页表。
3. **查页表 (慢表)**：
    * `页表起始地址`：操作系统会将当前运行进程的页表起始物理地址存放在**页表基址寄存器 (Page Table Base Register)** 中。这个值来源于进程的 **PCB**。
    * 使用 **VPN** 和页表基址寄存器，通过查页表（单级或多级）来获取对应的 **PTE**。
    * `检查有效位`：
        * 若PTE的有效位为1：从PTE中获取 **PFN**。
        * 若PTE的有效位为0：触发**缺页异常**。
4. **PA拼接**：将获取到的 **PFN** 与虚拟地址的 **页内偏移量 (Offset)** 拼接，形成最终的**物理地址 (PA)**。
5. **内存访问**：使用 **PA** 访问物理内存，获取CPU所需的数据或指令。
    * 从内存中读出的数据/指令通常会先放入 **MDR (Memory Data Register)**，然后交给CPU。

## 03-4 TLB (快表) 的作用与工作机制

### 1. TLB 的基本功能
* **定义**：TLB是页表项的**高速缓存**，位于CPU内部，用于加速地址转换。
* **内容**：TLB中保存的是最近访问过的页表项的**副本**，只包含关键字段（如虚拟页号、物理页框号、有效位等）。
* **映射方式**：在操作系统课程中通常只探讨**全相联映射**（每个TLB项可以存放任意页表项）。

### 2. TLB 命中与未命中处理

* **TLB 命中 (Hit)**：
    * `条件`：TLB中存在与当前VPN匹配的TLB标记，且该TLB项的有效位为1。
    * `处理`：直接从TLB中获取PFN，跳过访问内存页表的过程，大大加速地址转换。
* **TLB 未命中 (Miss)**：
    * `条件`：TLB中无匹配项，或匹配项的有效位为0。
    * `处理`：CPU需访问内存中的页表（慢表）进行地址转换。
        * 如果慢表中的有效位为1，则获取PFN，并将其对应的PTE复制到TLB中（替换掉某个旧项）。
        * 如果慢表中的有效位为0，则触发缺页异常。

### 3. TLB 与页表的一致性
* **TLB有效位 vs. 页表有效位**：
    * `页表项的有效位`：表示该页面是否在**物理内存中**。0会触发缺页异常。
    * `TLB项的有效位`：仅表示该TLB项中记录的**地址映射信息是否仍然有效**。
* **TLB 更新机制**：
    * 当页表项内容发生变更（如页面被调出内存导致PFN更新，或页框号变更），MMU (内存管理单元) 会将TLB中对应VPN的项**置为无效**（有效位设为0）。
    * 当缺页处理完成后，新的页表项信息会被更新到TLB中，以便下次访问时TLB命中。
    * **注意**：TLB只在第一次查询页表成功后才更新。若页面调出又调入，即使页框号改变，只要未再次访问该页面，TLB中旧的项（有效位已置0）就不会更新，直到下次访问时TLB未命中，查询慢表成功后才会更新。

## 03-5 单级页表与地址转换
### 1. 单级页表的结构
* **本质**：一个连续存储的数组，每个页表项对应一个虚拟页。
* **索引方式**：虚拟页号直接作为数组下标，用于快速访问对应的页表项。
* **物理连续性**：单级页表在物理内存中必须**连续存储**，否则无法通过数组下标和起始地址计算出页表项的物理位置。
* **页表项内容**：如前所述，包含有效位、页框号、外存地址、脏位等字段。

### 2. 单级页表的地址转换过程
1. **获取VPN和Offset**：从虚拟地址中提取虚拟页号 (VPN) 和页内偏移量 (Offset)。
2. **获取页表起始地址**：从**页表基址寄存器**中获取当前进程页表的起始物理地址。
3. **计算PTE地址**：`PTE物理地址 = 页表基址寄存器值 + VPN * sizeof(PTE)`。
4. **访问PTE**：访问内存获取该PTE。
5. **检查有效位**：
    * 若有效位为1：从PTE中取出PFN。
    * 若有效位为0：触发**缺页中断**。
6. **拼接PA**：将PFN与Offset拼接，形成物理地址。
7. **访问内存**：使用PA访问物理内存。

## 03-6 多级页表 (二级页表) 与地址转换
### 1. 多级页表的结构
* **问题**：单级页表可能非常大，占用大量连续内存空间，且对于稀疏地址空间不高效。
* **解决方案**：将VPN进一步拆分，构建多级页表。
* **二级页表示例**：24位VPN被拆分为两个12位部分：**一级页号 (页目录号)** 和 **二级页号 (页表索引)**。
    * `一级页表 (Page Directory)`：本质也是一个数组，由一级页号索引。每个一级页表项（页目录项）中保存的是**二级页表的起始页框号**。
    * `二级页表`：本质也是一个数组，由二级页号索引。每个二级页表项中保存的是**最终的物理页框号**。
* **页目录项的作用**：通过一级页号查找一级页表，得到二级页表所在的页框号。再将此页框号与12位0拼接，得到二级页表的起始物理地址。

### 2. 多级页表的地址转换过程
1. **获取一级页号、二级页号、Offset**：从虚拟地址中提取。
2. **查一级页表**：
    * 根据页表基址寄存器（指向一级页表）和一级页号，计算并访问一级页表项。
    * 若一级页表项有效位为1：获取二级页表的PFN。
    * 若有效位为0：通常触发缺页异常（整个二级页表可能不在内存）。
    * `注意`：一级页表通常常驻内存，不会发生缺页。
3. **查二级页表**：
    * 将二级页表的PFN与12位0拼接，得到二级页表的起始物理地址。
    * 根据该起始地址和二级页号，计算并访问二级页表项。
    * 若二级页表项有效位为1：获取最终的PFN。
    * 若有效位为0：触发**缺页异常**。
4. **拼接PA**：将最终获取的PFN与Offset拼接，形成物理地址。
5. **访问内存**：使用PA访问物理内存。

### 3. 多级页表的优势
* **减少页表占用内存空间**：只有实际用到的虚拟地址空间才需要建立对应的页表，未使用的部分不占用内存。
* **支持稀疏地址空间的高效管理**：程序虚拟地址空间中可能存在大量未使用区域，多级页表避免为这些区域分配页表空间。
* **不需要物理上连续的巨大页表**：页目录和二级页表可以分散存储在不同的页框中。

## 03-7 TLB 在多级页表中的应用
### 1. TLB 结构

* TLB中保存的是**完整的虚拟页号**（例如，24位虚拟页号），而不是分两级保存。

### 2. TLB 命中与未命中
* **TLB 命中**：
    * 若TLB中存在与完整虚拟页号匹配的项且有效位为1，可直接获取PFN，无需访问多级页表。
* **TLB 未命中**：
    * 若TLB未命中，则需访问内存中的多级页表，逐级查找最终的PFN。

### 3. TLB 更新机制
* 缺页处理完成后，操作系统会将新的页表项信息（包括完整的VPN和PFN）更新到TLB中。
* 对于多级页表，TLB中只存储最终的 `VPN -> PFN` 映射，而不是中间级页表的映射。

## 03-8 进程的虚拟地址空间与页表关系

### 1. 进程的虚拟地址空间构成
* **用户区**：
    * `代码段 (Code Segment)`：存放程序指令。
    * `读写数据段 (Data Segment)`：存放全局变量、静态变量等。
    * `堆 (Heap Segment)`：用于动态分配内存，由程序员管理。
    * `栈 (Stack Segment)`：用于函数调用信息（参数、局部变量、返回地址），由系统管理。
* **内核区 (Kernel Space)**：
    * 由操作系统代码和数据组成，所有进程**共享**物理上同一份内核区数据。
    * **目的**：提供系统调用、中断处理、驱动程序等服务。

### 2. 进程的创建与页表建立

* 操作系统为每个进程创建**PCB (进程控制块)**。
* PCB中包含该进程的**页表起始地址**（即页表基址寄存器应加载的值）。
* 当进程被调度执行时，操作系统会将PCB中的页表起始地址复制到CPU的**页表基址寄存器**中。
* 进程的指令、数据（如代码段、数据段、堆、栈）在被加载到物理内存时，操作系统会同时在进程的页表中建立相应的**虚拟地址到物理地址的映射关系**。

### 3. 进程的地址转换流程 (结合PC、IR寄存器)
1. CPU通过 **PC寄存器** 获取当前指令的**虚拟地址 (VA)**，或通过 **IR指令寄存器** 中指令的寻址方式获取数据VA。
2. 将VA拆分为VPN和Offset。
3. CPU的MMU (内存管理单元) 使用**页表基址寄存器**的值和VPN，通过查TLB和页表，获得对应的PFN。
4. 将PFN与Offset拼接形成PA。
5. CPU使用PA访问物理内存，获取指令或数据。

## 03-9 页表与TLB在物理内存中的位置
* **页表存放**：
    * 页表由操作系统维护。
    * 每个进程都有自己的页表。
    * 页表本身作为数据结构，通常存放在**物理内存的内核区**。
    * 当进程被调度时，其页表会被加载到内存（如果它不在内存）。
* **TLB存放**：
    * TLB是**CPU内部**的高速缓存，不依赖操作系统管理，而是由硬件管理。
* **内核区共享机制**：
    * 所有进程**共享内核区的物理页面**。
    * 物理内存中的内核数据（如操作系统代码、数据、驱动程序、其他进程的PCB）只有一份拷贝。
    * 但这些内核数据会被**映射到每个进程虚拟地址空间的内核区**。
    * **安全性**：用户态进程不能直接访问内核区。若用户态程序试图访问内核区，会触发**异常**，保护系统安全。

## 03-10 缺页异常与页面调入机制

### 1. 缺页异常触发条件

* 当地址转换过程中，页表项的**有效位为0**时，表示所需页面当前不在物理内存中，此时会触发**缺页异常 (Page Fault Exception)**。

### 2. 缺页异常处理流程
1. **保存现场**：CPU保存当前进程的运行现场（寄存器、PC等）。
2. **切换内核态**：CPU从用户态切换到内核态，由操作系统处理。
3. **查找外存**：操作系统根据页表项中的**外存地址**，定位页面在外存中的位置。
4. **页面调入**：操作系统启动磁盘I/O，将页面从外存（如硬盘）调入到物理内存中的一个**空闲页框**。
5. **更新页表**：页面调入完成后，操作系统更新该页面的页表项：
    * 设置有效位为1。
    * 更新页框号为新的物理页框号。
    * 设置脏位为0。
6. **更新TLB**：若TLB中存在该VPN的旧项，MMU将其**置为无效**（有效位设0）。有的系统会在缺页处理完成后立即更新TLB，有的则在下次访问时更新。
7. **重新执行**：异常处理程序返回，CPU切换回用户态，并**重新执行**之前导致缺页的指令。此时，由于页面已在内存，地址转换会成功。

### 3. 局部性原理与TLB命中率提升
* **局部性原理**：
    * `时间局部性`：被访问过的指令和数据在短时间内很可能再次被访问。
    * `空间局部性`：被访问的指令和数据，其附近（地址连续）的指令和数据在短时间内很可能被访问。
* **TLB命中率提升**：由于程序执行具有局部性，TLB能有效缓存最近使用的页表项，显著减少访问内存中页表的次数，从而提升地址转换效率。

## 03-11 进程间共享页面与进程通信
### 1. 共享页面的实现方式

* **原理**：多个进程的页表项指向**相同的物理页框**。
* **效果**：物理页框中的内容在多个进程的虚拟地址空间中可见，但它们的虚拟地址可能不同。
* **示例**：
    * 进程P1的虚拟页A -> 物理页框X。
    * 进程P2的虚拟页B -> 物理页框X。
    * 进程P1通过虚拟页A访问物理页框X，进程P2通过虚拟页B访问物理页框X。

### 2. 共享页面的应用场景
* **进程间通信 (IPC)**：
    * **共享内存**：最直接的应用，进程通过共享页面实现高效的数据传输。
    * **管道/消息队列中转**：操作系统可以将进程间通信的数据（如管道中的数据）复制到共享页面中，作为内核区的一部分，供其他进程访问。
* **共享库/内核区**：
    * 多个进程可以共享同一个物理内存中的共享库代码（如 `libc.so`）或操作系统的内核代码和数据。
    * **原理**：每个进程的页表中的相应虚拟页号都映射到物理内存中的同一份代码/数据页框。

### 3. 进程间通信的底层机制 (示例：信箱/管道)
1. **发送进程请求**：进程通过**系统调用**请求操作系统发送数据给另一个进程。
2. **数据复制到内核区**：操作系统收到请求后，会将发送进程准备好的数据**复制到内核区**的一个共享页面中（物理上只有一份数据）。
3. **接收进程请求**：接收进程也通过**系统调用**请求操作系统接收数据。
4. **数据复制到用户区**：操作系统从内核区的共享页面中读取数据，并将其复制到接收进程的用户区中指定的缓冲区。
* **核心**：内核区充当了进程间通信的**中转站**。通过页面共享，操作系统能够高效地协调不同进程间的数据交换，同时保证系统的安全性和隔离性。

## 03-12 课程总结与学习建议
* **核心内容回顾**：
    * 地址转换流程（VA → PA）。
    * 页表结构（单级、多级）。
    * TLB的作用与更新机制。
    * 缺页异常处理与局部性原理。
    * 进程虚拟地址空间与页表关系。
    * 进程与内核区页面的共享。
* **学习建议**：
    * **重理解，轻题海**：理解知识本质比盲目刷题更重要。
    * **打通学科壁垒**：存储系统是计算机组成原理和操作系统的共同考点，应从整体视角理解。
    * **手绘图示**：通过手绘流程图和内存布局图，加深对底层机制的理解。
    * **真题优先**：优先做王道书 `3.2小节` 的课后真题，举一反三。

---

# 03 内存管理真题精讲 2025

页表自映射、缺页异常、FIFO/Clock、驻留集、页面置换、数组按行/列访问、TLB 计算

---

## 1. 页表自映射（24 年真题）

| 概念 | 一句话 |
|---|---|
| 页表也是 **数组** | 页号 = 数组下标 |
| 页表 **物理必须连续** | 64 页框（4 KB×2^16 项×4 B） |
| 页表 **虚拟也连续** | 内核区高地址，进程可见但不可改 |
| PCB 记录双地址 | **物理起始地址** → 页表基址寄存器&lt;br&gt;**虚拟起始地址** → 进程内核指针 |

### 真题三问速答模板
1. **缺页项地址**
   物理 = 页表基址 + 页号×4 B
   虚拟 = 页表虚拟基址 + 页号×4 B
2. **页表所在页号**
   虚拟地址前 10 bit（或 12 bit）直接截
3. **该页对应页表项虚拟地址**
   同上，再套一次数组偏移

---

## 2. 数组按行/列访问与缺页率（20 年真题）

| 存储方式 | 每行大小 | 缺页次数 |
|---|---|---|
| 行优先 | 1 行 = 1024×4 B = 4 KB → **1 页** | 按行：1 次/行&lt;br&gt;按列：1024 次/行 |

&gt; 口诀：**"行优先，行访问 1 次缺页；列访问 1024 次"**

---

## 3. 驻留集 vs 空闲页框队列

| 术语 | 本质 | 作用 |
|---|---|---|
| 驻留集 | 已分配给进程的 **页框号队列** | 固定分配局部置换 |
| 空闲链表 | **未被使用** 的页框号队列 | 回收未访问页（09/12 真题） |

&gt; 09 真题：驻留集=2 → **无空闲页框** → 缺页必须 **置换**

---

## 4. 页面置换算法速记

| 算法 | 淘汰规则 | 真题关键词 |
|---|---|---|
| FIFO | 最早进入 | 看 **装入时间** |
| Clock | 访问位=0 | 循环扫，扫到 0 淘汰 |
| LRU | 最久未用 | 时间戳或栈 |

---

## 5. TLB 与页表访问次数模板

| 场景 | 访问流程 | 总次数 |
|---|---|---|
| TLB 命中 | TLB → 物理页 | **0 次内存** |
| TLB 未命中 | 页表（1）→ 物理页 | **1 次内存** |
| 多级页表 | 每级 +1 次 | n 级 = n 次 |
| 缺页 | 页表→缺页→置换→再页表 | **+ 磁盘 IO** |

---

## 6. 真题速算

| 年份 | 考点 | 秒答 |
|---|---|---|
| 24 | 页表自映射 | 物理地址 = 064000H + 页号×4 |
| 20 | 数组 1034 号元素 | 虚拟地址 = 10800000H + (1×1024+28)×4 |
| 09 | 驻留集=2 | 缺页只能 **置换** 0 或 2 号页 |
| 12 | 空闲链表回收 | **5 时刻扫描** → 未访问页插回 **链尾** |

---

## 7. 课后任务

- [ ] 王道 3.2 课后 **14-21 真题** → 限时 60 min
- [ ] 手写模板：
  * 页表自映射 3 问
  * 数组行/列缺页对比表
- [ ] 错题本：抄 **"TLB 访问次数模板"**

---

# 🔗 双链
[[04 文件系统真题精讲 2025]]
