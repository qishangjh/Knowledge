---
科目: 
课程名称: 
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度: 
考频: 
备注:
---

# 05 输入输出管理
#os #i/o管理
## 05-1 I/O管理概述
#i/o设备
这一部分主要讲的是操作系统如何看待和处理各种五花八门的I/O设备，以及它与这些设备沟通的基本方式。
### 1. I/O设备：计算机的"外部世界"
* **定义**：I/O设备（Input/Output Device）是计算机系统与外部世界进行信息交换的桥梁。它们种类繁多，功能各异。
* **分类**：
    * **按设备的共享属性**：
        * **独占设备**：一段时间内只允许一个用户访问的设备，如打印机。
        * **共享设备**：可以允许多个用户在一段时间内同时访问的设备，如磁盘。
    * **按信息交换单位（方式）**：
        * **块设备**：以**数据块**为单位传输数据，传输速率较高、可寻址，可随机读/写任一块。如磁盘、磁带、固态硬盘。
        * **字符设备**：传输的基本单位是字符，每次只能传送一个字符的信息，传输速率低、不可寻址（或寻址无意义），输入/输出时常采用中断驱动方式。如键盘、鼠标、打印机。
    * **按设备的使用特性**：
        * **人机交互类外部设备**：用于同计算机用户之间交互的设备，通常以字节为单位进行数据交换。如键盘、鼠标、显示器、打印机。
        * **存储设备**：用于存储程序和数据的设备。如磁盘、磁带。
        * **输入输出设备**：
            * **输入设备**：将外部世界的信息输送给计算机。
            * **输出设备**：将计算机处理或加工好的信息输出给外部世界。
    * **按传输速率**：
        * **高速设备**：数十万字节至千兆字节/秒。如磁盘机、磁带机、光盘机。
        * **中速设备**：千字节至数十万字节/秒。如行式打印机、激光打印机。
        * **低速设备**：几个字节至数百字节/秒。如键盘、鼠标。
* **I/O设备的特点**：
    * 种类繁多、功能各异。
    * 速度差异巨大。
    * 数据传输单位不同。
    * 错误处理复杂。

### 1.5. I/O接口与I/O端口 (设备控制器)
#设备控制器 #i/o端口

I/O接口（也称设备控制器）是主机和外设之间进行信息交换的交接界面。它就像一个"翻译官"和"协调员"。

* **I/O接口（设备控制器）**：
    * **主机和外设之间的交接界面**：通过接口实现主机和外设之间的信息交换。
    * **设备控制器与主机的接口**：
        * 主要通过**数据线、地址线和控制线**三类信号线与主机相连。
        * 数据线通常与两类寄存器相连：
            * **数据寄存器**：存放从设备送来的输入数据或从CPU送来的输出数据。
            * **状态/控制寄存器**：存放从CPU送来的控制信息或设备的状态信息。
    * **设备控制器与设备的接口**：
        * 一个设备控制器可以连接一个或多个设备，控制器中有一个或多个设备接口。
        * 为了区分设备，需要给各个设备进行编号，即给各个控制器与设备的接口编地址。
        * 每个接口中都存在数据、控制和状态三种类型的信号。
    * **I/O逻辑**：
        * 用于实现对设备的控制，通过一组控制线与CPU交互，对从CPU收到的I/O命令进行译码。
        * CPU启动设备时，将启动命令和地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地对所选设备进行控制。
    * **设备控制器的主要功能**：
        * **接收和识别CPU发来的命令**：如磁盘控制器能接收读、写、查找等命令。
        * **数据交换**：设备和控制器之间、控制器和主存之间的数据传输。
        * **识别和报告设备的状态**：供CPU处理。
        * **地址识别**：配置地址译码器。
        * **数据缓冲**：设置缓冲区。
        * **差错控制**：差错检测码置位。
* **I/O端口**：
    * 接口电路中可被CPU直接访问的寄存器。它是CPU和控制器之间通信的具体"小窗口"。
    * **主要有三类**：
        * **数据寄存器**：实现CPU和外设之间的数据缓冲。
        * **状态寄存器**：获取执行结果和设备的状态信息，以让CPU知道设备是否准备好。
        * **控制寄存器**：由CPU写入，以便启动命令或更改设备模式。
    * **CPU和I/O端口进行通信的方法**：
        * **独立编址**：为每个端口分配一个端口号，所有端口形成端口空间。普通用户程序不能访问，只有操作系统使用特殊的I/O指令才能访问端口。
        * **统一编址（内存映射I/O）**：每个端口分配唯一的内存地址，且不会有内存被分配这一地址，通常分配给端口的地址靠近地址空间的顶端。
    * **接口与端口关系**：若干个端口加上相应的控制逻辑电路组成接口。CPU可以对数据端口进行读写操作，CPU若要对I/O端口进行操作，则必须对I/O端口进行编号。

### 2. I/O控制方式
#i/o控制方式

这是操作系统如何与I/O设备进行数据交换和控制的核心机制，也是计组和OS的交叉考点！它决定了CPU在I/O操作中的"忙碌"程度。

* **1）程序直接控制方式（轮询方式）**：
    * **原理**：每次读一个字的数据。CPU主动、反复地查询I/O设备的状态寄存器，看设备是否准备好或是否完成I/O操作。
    * **特点**：CPU和I/O设备串行工作。CPU绝大部分时间处于等待I/O设备完成数据I/O的循环测试中，CPU资源极大浪费。
    * *小比喻*：你每隔一分钟就去问快递员"我的快递到了吗？"
* **2）中断驱动方式**：
    * **原理**：允许I/O设备主动打断CPU的运行并请求服务，从而"解放"CPU，使其向I/O控制器发送读命令后可以继续做其他有用的工作。
    * **特点**：并行工作。CPU会在每个**指令周期**的末尾检查中断，每次中断读写一个字。
        * **从I/O控制器的角度**：I/O控制器从CPU接收一个读命令，然后从外围设备读数据。数据读入数据寄存器，通过控制线给CPU发出中断信号，然后等待CPU请求该数据。I/O控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中。
        * **从CPU的角度**：CPU发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），转去执行其他程序。在每个指令周期的末尾，CPU检查中断。当有来自I/O控制器的中断时，CPU保存当前正在运行程序的上下文，转去执行中断处理程序以处理该中断。CPU从I/O控制器读一个字的数据传送到寄存器，并存入主存。接着，CPU恢复发出I/O命令的程序（或其他程序）的上下文，然后继续运行。
    * *小比喻*：你给快递员打电话说"快递到了通知我"，然后你继续工作，快递员到了给你打电话。
* **3）DMA方式（Direct Memory Access - 直接内存访问）**：
    * **原理**：在I/O设备和内存之间开辟直接的数据交换通路。CPU发出I/O命令后，DMA控制器接管数据传输。DMA控制器直接在I/O设备和内存之间进行数据传输，**无需CPU干预**。只有当整个数据块传输完成后，DMA控制器才向CPU发送一个中断信号。
    * **特点**：
        * 基本单位是**数据块**。每次读写连续的多个数据块。
        * 传送的数据直接在设备和内存之间传输，不经过CPU。
        * 只有在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。
        * DMA控制器中包含：
            * **控制/状态寄存器**：用于接收从CPU发来的I/O命令、有关控制信息或设备的状态。
            * **内存地址寄存器（MAR）**：在输入时，存放把数据从设备传送到内存的起始目标地址；在输出时，存放由内存到设备的内存源地址。
            * **数据寄存器（DR）**：用于暂存从设备到内存或从内存到设备的数据。
            * **数据计数器（DC）**：存放本次要传送的字（节）数。
    * **工作过程**：
        * CPU接收到I/O设备的DMA请求时，给I/O控制器发出一条命令，启动DMA控制器，然后继续其他工作。CPU把控制操作委托给DMA控制器，由该控制器负责处理。
        * DMA控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要CPU参与。传送完成后，DMA控制器发送一个中断信号给处理器。
    * **与中断驱动方式的主要区别**：
        * 中断驱动方式在每个数据需要传输时中断CPU，而DMA方式则是在所要求传送的一批数据全部传送结束时才中断CPU。
        * 中断驱动方式数据传送是在中断处理时由CPU控制完成的，而DMA方式则是在DMA控制器的控制下完成的。
    * *小比喻*：你告诉快递公司"把这批货直接送到仓库"，然后你继续工作，货全部送完后，快递公司才通知你一声。

| **特征**       | **中断 I/O 方式**                             | **DMA 方式**                        |
| ------------ | ----------------------------------------- | --------------------------------- |
| **数据传输单位**   | 字或字节 (Word/Byte)                          | 数据块 (Block)                       |
| **CPU 介入频率** | **高**。每传输一个字都要中断 CPU。                     | **低**。仅在开始和结束时介入。                 |
| **数据流向**     | 设备 $\rightarrow$ **CPU** $\rightarrow$ 内存 | 设备 $\rightarrow$ **内存** (不经过 CPU) |
| **控制权**      | 始终由 CPU 通过程序控制。                           | 传输期间由 DMA 控制器接管总线。                |
| **主要优点**     | CPU 无需轮询等待，利用率提高。                         | 大批量数据传输时，CPU 负担极轻。                |
* **4）通道控制方式**：
    * **原理**：I/O通道是专门负责输入输出的处理器。CPU只需向通道发出一个通道指令，通道就会独立完成一系列I/O操作，完成后才向CPU发中断。
    * **特点**：实现CPU、通道和I/O设备并行操作。CPU只需向通道发出启动命令，给出其所要执行的通道程序的首地址和要访问的I/O设备。
    * **优点**：CPU介入最少，I/O并行性最高，资源利用率高。
    * **缺点**：实现复杂，需要专门的通道硬件支持。
    * **与一般处理机的区别**：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与CPU共享内存。
    * **与DMA方式的区别**：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。
    * *小比喻*：你给物流公司下达一个"物流计划"，物流公司自己安排车辆、人员、路线，全部完成后才给你一个报告。

### 3. I/O软件层次结构
#i/o软件层次

操作系统为了管理复杂的I/O设备，采用了分层设计，就像一个多层蛋糕，每层负责不同的任务。

* **1）用户层I/O软件**：
    * 实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作。
    * 向上：为用户提供接口，使用户能够对I/O设备进行操作。
    * 向下：将用户的请求翻译为格式化的I/O请求，并通过系统调用请求操作系统内核服务。
* **2）设备独立性软件**：
    * 用于实现用户程序与设备驱动程序的统一接口、设备命令、设备保护及设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。
    * **设备独立性**：用户程序中使用逻辑设备名来请求使用某类设备；系统实际执行时，将逻辑设备名映射成物理设备名使用。
    * **用逻辑设备名的好处**：
        * 提高设备分配的灵活性。
        * 便于实现I/O重定向：用于I/O操作的设备可以更换（即重定向），而不必改变应用程序。
    * **主要功能**：
        * 执行所有设备的公有操作：包括对设备的分配与回收；将逻辑设备名映射为物理设备名；对设备进行保护，禁止用户直接访问设备；缓冲管理；差错控制；提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异。
        * 向上层用户提供统一接口：无论何种设备，它们向用户所提供的接口应是相同的。
        * *功能细介绍（了解即可）*：
            * **设备的分配和回收**：很多设备是一种临界资源，不能同时被多个用户占用。
            * **将逻辑设备名映射为物理设备名**：建立逻辑设备名（用户所看到的设备名）和物理设备名之间的映射关系，根据逻辑设备表来确定逻辑设备对应的物理设备。
            * **对设备进行保护**：每个用户对不同设备（设备被看做是一种特殊的文件）的访问权限不一样。
            * **缓冲区管理**：通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。
* **3）设备驱动程序**：
    * 与硬件直接相关，负责具体实现I/O操作。每个设备都应该有一个属于自己的设备驱动程序。
    * 设备驱动程序向上层用户程序提供一组标准接口。
    * 设备具体的差别被设备驱动程序所封装，用于接收上层软件发来的抽象I/O要求，转换为具体要求后，发送给设备控制器，控制I/O设备工作；将由设备控制器发来的信号传送给上层软件，I/O内核子系统隐藏设备控制器之间的差异。
* **4）中断处理程序**：
    * 用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回到被中断进程。
    * 主要任务：进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等。
    * 中断处理与硬件紧密相关，应尽量加以屏蔽，放在操作系统的底层，系统的其余部分尽量少地与之发生联系。
* **5）硬件设备**：
    * I/O设备通常包括一个机械部件和一个电子部件。电子部件称为设备控制器（或适配器）；机械部件是设备本身。

### 4. 应用程序I/O接口
#应用程序接口

应用程序通过操作系统提供的**系统调用 (System Calls)** 来请求I/O服务。这些接口将复杂的硬件操作抽象化。

* **1）字符设备接口**：
    * 数据存取和传输以字符为单位的设备，如键盘、打印机等。
    * 基本特征是传输速率低。
    * 不可寻址，只能采取顺序存取方式，通常建立一个字符缓冲区，用户程序通过`get`操作从缓冲区获取字符，通过`put`操作将字符输出到缓冲区。
    * 字符设备都属于独占设备，接口提供打开和关闭操作，以实现互斥共享。
* **2）块设备接口**：
    * 数据存取和传输以数据块为单位的设备，如磁盘、光盘、磁带等。
    * 基本特征是可寻址。
    * 隐藏了磁盘的二维结构，将磁盘的所有扇区从0到n-1依次编号，变为线性序列。
    * 将抽象命令映射为低层操作。支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令，该接口将命令映射为设备能识别的较低层的具体操作。
* **3）网络设备接口**：
    * 现代OS提供面向网络功能，提供相应的网络软件和网络通信接口。
    * 提供的网络I/O接口为**网络套接字接口**，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。
* **4）阻塞/非阻塞I/O**：
    * **阻塞I/O**：用户进程调用I/O操作时，进程就被阻塞，需要等待I/O操作完成，进程才被唤醒继续执行。大多数操作系统提供的I/O接口采用阻塞I/O。
    * **非阻塞I/O**：用户进程调用I/O操作时，不阻塞该进程，该I/O调用返回一个错误返回值，进程需要通过轮询的方式来查询I/O操作是否完成。

## 05-2 设备独立性软件
#设备独立性

这一部分深入探讨了I/O软件层次中的中间层，它让应用程序可以"不挑设备"，大大简化了编程。

### 1. 设备独立性软件 (Device-Independent Software)

* **定义**：位于设备驱动程序之上、用户层I/O软件之下，是操作系统I/O管理的核心组成部分。
* **作用**：
    * **提供统一接口**：向上层提供统一的、与设备类型无关的I/O接口（如 `read(fd, buf, count)`）。
    * **屏蔽设备差异**：将不同设备的特性（如块大小、寻址方式）隐藏起来，让应用程序无需关心具体设备。
    * **实现通用I/O功能**：如缓冲、设备分配与回收、错误报告、逻辑地址到物理地址的转换等。
* **优点**：
    * 方便编程：应用程序员无需了解设备细节。
    * 易于移植：应用程序可以在不同设备上运行。
    * 简化OS设计：将通用功能集中处理。

### 2. 高速缓存与缓冲区 (Cache & Buffer)
#高速缓存 #缓冲区

这是操作系统用来优化I/O性能的重要手段。

* **1）磁盘高速缓存 (Cache)**：
    * **定义**：磁盘高速缓存不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中存储空间来暂存从磁盘中读出的一系列盘块中信息。
    * **特点**：在逻辑上属于磁盘，物理上是驻留在内存中的盘块。
    * **形式**：
        * 在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定。
        * 利用未使用的内存空间作为缓冲池，供请求分页系统和磁盘I/O时共享。
    * **与硬件Cache的区别**：这里的Cache是操作系统软件层面的，用于文件系统，而计组中的Cache是CPU和主存之间的硬件Cache。
    * **作用**：利用局部性原理，减少对慢速磁盘的访问。
* **2）缓冲区 (Buffer)**：
    * **定义**：内存中的一块区域，用于**暂存**I/O设备和CPU之间传输的数据。
    * **作用目的**：
        * 缓和CPU与I/O设备间速度不匹配的矛盾。
        * 减少对CPU的中断频率，放宽对CPU中断响应时间的限制。
        * 解决基本数据单元大小（即数据粒度）不匹配的问题。
        * 提高CPU和I/O设备之间的并行性。
    * **实现方法**：
        * **硬件缓冲器**：成本高，除关键部位外，一般不采用。
        * **软件缓冲区**：位于内存区域。
    * **根据缓冲器个数分类**：
        * **单缓冲**：在设备和处理机之间设置一个缓冲区。设备和处理机交换数据时，先把数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据。
            * 在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户进程的时间为M，而CPU对这一块数据处理的时间为C。由于T和C可以并行，当T>C时，系统对每一块数据的处理时间为M+T；反之则为M+C。故可把系统对每一块数据的处理时间看作`MAX(C,T)+M`。
        * **双缓冲**：在设备和处理机之间设置两个缓冲区。
            * I/O设备输入数据时先装填到缓冲区1，在缓冲区1填满后才开始装填缓冲区2，同时处理机从缓冲区1中取出数据放入用户进程处理。当缓冲区1中数据处理完后，若缓冲区2已填满，则处理机从缓冲区2中取出数据放入用户进程处理，而I/O设备可以装填缓冲区1。
            * 双缓冲机制提高了处理机和输入设备的并行操作的程度。
            * 系统处理一块数据的时间可以粗略地认为是`MAX(C,T)`。如果C<T，可使块设备连续输入；如果C>T，则可使CPU不必等待设备输入。
            * 对于字符设备，若采用行输入方式，则采用双缓冲可使用户在输入完第一行之后，在CPU执行第一行中的命令的同时，用户可继续向第二缓冲区输入下一行数据。而单缓冲情况下则必须等待一行数据被提取完毕才可输入下一行的数据。
            * 如果两台机器之间通信仅配置了单缓冲，它们在任一时刻都只能实现单方向的数据传输。双向数据传输，必须在两台机器中都设置两个缓冲区，一个用做发送缓冲区，另一个用做接收缓冲区。
        * **环形缓冲**：
            * 包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。
            * 用于输入/输出时，还需要有两个指针`in`和`out`。
                * 对于输入：`in`指针指向可以输入数据的第一个空缓冲区；`out`指针指向可以提取数据的第一个满缓冲区。
                * 对于输出：则正好相反。
            * *小比喻*：管道通信中的"管道"实质就是缓冲区。
        * **缓冲池**：
            * 由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列（输入队列）和装满输出数据的缓冲队列（输出队列）。
            * **四种缓冲区（功能）**：
                * **收容输入数据的工作缓冲区**：当输入进程需要输入数据时，从空缓冲队列队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。
                * **提取输入数据的工作缓冲区**：当计算进程需要输入数据时，从输入队列取得一个缓冲区（满）作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。
                * **收容输出数据的工作缓冲区**：当计算进程需要输出数据时，从空缓冲队列队首取得一个空缓冲区，作为收容输出工作缓冲区。当其中装满输出数据后，再将它挂到输出队列队尾。
                * **提取输出数据的工作缓冲区**：当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区。当数据提取完后，再挂到空缓冲队列的队尾。

### 3. 设备分配与回收
#设备分配

操作系统需要决定哪个进程可以使用哪个设备，以及何时释放设备。这就像一个中央调度员，合理分配有限的资源。

* **1）设备分配概述**：
    * 设备分配是指根据用户的I/O请求分配所需的设备。
    * 分配的总原则是充分发挥设备的使用效率。
    * **分配方式**：
        * **独占式使用设备**：在申请设备时，如果设备空闲，就将其独占，不再允许其他进程申请使用，一直等到该设备被释放才允许其他进程申请使用。
        * **分时式共享使用设备**：当设备没有独占使用的要求时，可以通过分时共享使用，提高利用率。
        * **SPOOLing方式使用外部设备**：SPOOLing技术（假脱机I/O技术）对I/O操作进行批处理，将独占设备改造为共享设备。
* **2）设备分配数据结构**：
    * 查询顺序：系统控制表 -> 设备控制表 -> 控制器控制表 -> 通道控制表（即先确定是哪个设备）。
    * **设备控制表 (DCT)**：系统为每一个设备配置一张DCT，用于记录设备的特性以及与I/O控制器连接的情况。
        * 设备类型（如打印机/扫描仪/键盘）。
        * 物理设备标识符（系统中每个物理设备名唯一）。
        * 设备状态（等待/不忙/空闲）。
        * 指向控制器表的指针。
        * 重复执行次数或时间（多次重复执行后仍不成功，才认为失败）。
        * 设备队列的队首指针（指向正在等待该设备的进程队列，即PCB队列）。
    * **控制器控制表 (COCT)**：每个控制器都配有一张COCT，它反映设备控制器的使用状态及和通道的连接情况等。
        * 控制器标识符（唯一ID）。
        * 控制器状态（忙/闲）。
        * 控制器连接的通道表指针。
        * 控制器队列的队首/队尾指针。
    * **通道控制表 (CHCT)**：每个通道配有一张CHCT，通过通道控制表找到属于该通道的所有控制器。
        * 通道标识符（唯一ID）。
        * 通道状态（忙/闲）。
        * 通道连接的控制器表首址。
        * 通道队列的队首/队尾指针。
    * **系统设备表 (SDT)**：整个系统只有一张SDT，它记录已连接到系统中的所有物理设备的情况，每个物理设备占一个表目。
        * 设备类、设备标识符、DCT、驱动程序入口。
* **3）设备分配策略**：
    * **设备分配原则**：
        * 应根据设备特性、用户要求和系统配置情况。
        * 总原则既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。
    * **设备分配方式**：
        * **静态分配**：主要用于对独占设备的分配。在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器（和通道）。一旦分配后，这些资源就一直为该作业所占用，直到该作业被撤销。
            * 优点：不会出现死锁。
            * 缺点：设备的使用效率低。
        * **动态分配**：在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需的设备、I/O控制器，一旦用完之后，便立即释放。
            * 优点：有利于提高设备的利用率。
            * 缺点：如果分配算法使用不当，则有可能造成进程死锁。
    * **设备分配算法**：
        * 独占设备：静态分配方式，在作业执行前，将作业所要用的这一类设备分配给它。
        * 共享设备：可被多个进程所共享，采用动态分配方式，每个I/O传输的单位时间内只被一个进程所占有，通常采用先请求先分配和优先级高者先分的分配算法。
* **4）设备分配安全性**：
    * **安全分配方式**：
        * 每当进程发出I/O请求后便进入阻塞状态，直到其I/O操作完成时才被唤醒。
        * 一旦进程已经获得某种设备后便阻塞，不能再请求任何资源，而且在它阻塞时也不保持任何资源。
        * 优点：设备分配安全。
        * 缺点：CPU和I/O设备是串行工作的（对同一进程而言）。
    * **不安全分配方式**：
        * 进程在发出I/O请求后继续运行，需要时又发出第二个、第三个I/O请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。
        * 优点：一个进程可同时操作多个设备，从而使进程推进迅速。
        * 缺点：这种设备分配有可能产生死锁。
* **5）逻辑设备名到物理设备名的映射**：
    * **设备独立性**：应用程序独立于具体使用的物理设备。提高设备分配的灵活性和设备的利用率、方便实现I/O重定向。
    * **逻辑设备表 (LUT)**：用于将逻辑设备名映射为物理设备名。实现设备独立性，在应用程序中使用逻辑设备名来请求使用某类设备。
        * LUT表项包括逻辑设备名、物理设备名和设备驱动程序入口地址。
        * 当进程用逻辑设备名来请求分配设备时，系统为它分配相应的物理设备，并在LUT中建立一个表项。以后进程再利用逻辑设备名请求I/O操作时，系统通过查找LUT来寻找相应的物理设备和驱动程序。
    * **建立LUT的方式**：
        * **一个系统中只设置一张LUT**：所有进程的设备分配情况都记录在这张表中，不允许有相同的逻辑设备名，主要适用于单用户系统。
        * **为每个用户设置一张LUT**：当用户登录时，系统为该用户建立一个进程，同时也为之建立一张LUT，并将该表放入进程的PCB中。
* **6）设备分配（详细步骤）**：
    * **分配设备**：
        * 根据I/O请求中的物理设备名查找系统设备表（SDT），从中找出该设备的DCT。
        * 再根据DCT中的设备状态字段，可知该设备是否正忙。若忙，便将请求I/O进程的PCB挂在设备队列上。
        * 若空闲，则按照一定算法计算设备分配的安全性，安全则分配给请求进程，否则仍将其PCB挂到设备队列。
    * **分配控制器**：
        * 系统把设备分配给请求I/O的进程后，再到其DCT中找出与该设备连接的控制器的COCT。
        * 从COCT中的状态字段中可知该控制器是否忙碌。若忙，便将请求I/O进程的PCB挂在该控制器的等待队列上。
        * 若空闲，便将控制器分配给进程。
    * **分配通道**：
        * 在该COCT中又可找到与该控制器连接的通道的CHCT。
        * 再根据CHCT内的状态信息，可知该通道是否忙碌。若忙，便将请求I/O的进程挂在该通道的等待队列上。
        * 若空闲，便将该通道分配给进程。
    * 只有在上述三者都分配成功时，这次设备的分配才算成功。然后，便可启动该I/O设备进行数据传送。

### 4. SPOOLing技术 (假脱机技术)
#SPOOLing

这是操作系统实现设备共享和提高I/O效率的经典技术，**非常重要，常考！**

* **1）概念**：
    * 为了缓和CPU的高速性与I/O设备低速性之间的矛盾，引入了脱机输入/输出技术。
    * 该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上。
    * 外部设备同时联机操作，假脱机输入/输出操作，将独占设备改造成共享设备。
* **2）输入井和输出井**：
    * 在磁盘上开辟出的两个存储区域。数据以文件的形式组织管理。
    * **输入井**：模拟脱机输入时的磁盘，用于收容输入设备（如读卡机）送来的数据。
    * **输出井**：模拟脱机输出时的磁盘，用于收容用户程序的输出数据。
* **3）输入缓冲区和输出缓冲区**：
    * 在内存中开辟的两个缓冲区。
    * **输入缓冲区**：用于暂存由输入设备送来的数据，以后再传送到输入井。（输入设备 -> 输入缓冲区 -> 输入井）
    * **输出缓冲区**：用于暂存从输出井送来的数据，以后再传送到输出设备。（输出井 -> 输出缓冲区 -> 输出设备）
* **4）输入进程和输出进程**：
    * **输入进程**：模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。
    * **CPU需要输入数据时**：直接将数据从输入井读入内存。
    * **输出进程**：模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备。
* **5）SPOOLing系统主要特点**：
    * 提高了I/O的速度。
    * 将独占设备改造为共享设备。
    * 实现了虚拟设备功能。
* **6）应用**：
    * **共享打印机**：假脱机技术可以将独占式设备改造成共享设备，即将一台物理设备虚拟成多台逻辑设备。
    * 每个进程提出打印请求时，操作系统都会为其在输出井中分配一块存储空间（相当于分配一个逻辑设备），使得每个进程都觉得自己独占一个打印机，从而实现对打印机的共享。

### 5. 设备驱动程序接口 (Device Driver Interface)
#设备驱动程序

* **定义**：设备驱动程序是操作系统内核的一部分，负责与特定硬件设备进行直接通信和控制。
* **接口**：若每个设备驱动程序与操作系统的接口都不同，则每出现一个新设备时，都必须为此修改操作系统。因此，要求每个设备驱动程序与操作系统之间都有着相同或相近的接口。
* **作用**：将硬件的复杂性封装起来，提供给操作系统一个统一的抽象接口。

### 6. I/O操作举例 (Example of I/O Operation)
#i/o操作流程

小可爱，咱们来捋一下一个典型的`read()`系统调用，看看它在幕后都经历了些啥！

* **一个典型的 `read()` 系统调用过程**：
    1. **应用程序（用户层I/O软件）**：调用 `read()` 库函数。
    2. **库函数**：将用户请求转换为 `read()` **系统调用**，进入内核态。
    3. **操作系统内核 (设备独立性软件层)**：
        * 接收系统调用，进行通用处理（如检查文件描述符、权限、逻辑设备名映射）。
        * 调用对应设备的**设备驱动程序**。
    4. **设备驱动程序**：
        * 接收来自设备独立性软件的抽象I/O请求。
        * 将其转换为设备控制器能理解的具体命令。
        * 向I/O控制器发送这些命令（如启动DMA传输，并指明内存地址和数据量）。
    5. **I/O控制器 (硬件层)**：
        * 接收到命令后，控制I/O设备进行数据传输（例如，DMA控制器直接将数据从磁盘读入内存中的内核缓冲区）。
        * 这个过程**不需要CPU干预**（DMA方式）。
    6. **I/O操作完成**：
        * 数据传输完成后，I/O控制器向CPU发送**中断信号**。
    7. **CPU与中断处理程序**：
        * CPU收到中断后，暂停当前工作，保存上下文。
        * 转去执行**中断处理程序**，该程序对中断信号源进行测试，并通知设备驱动程序I/O完成。
    8. **设备驱动程序**：
        * 更新设备状态。
        * 将数据从内核缓冲区复制到用户指定的内存区域（应用程序定义的缓冲区）。
    9. **设备独立性软件**：返回结果（如读取的字节数）给用户层。
    10. **应用程序**：从 `read()` 调用中返回，获得数据，继续执行。

---

## 05-3 磁盘和固态硬盘
#磁盘 #固态硬盘

计组更关注**硬件的物理结构、性能指标和工作原理**，而操作系统则更关注**如何管理和优化这些硬件资源**。
在操作系统中，磁盘和固态硬盘被视为重要的**I/O设备**和**存储资源**。操作系统需要高效地管理它们，以确保数据的可靠存储、快速访问和公平分配。
### 1. 磁盘 (Disk)
#磁盘结构 [[2026操作系统.pdf#page=353|2026操作系统, 5.3.1磁盘]]
从操作系统的角度看，磁盘是一个需要精心管理的**慢速、机械式、大容量**的存储设备。
![[考研学习笔记03-操作系统 05 输入输出管理 2025-10-24 4203.png]]
* **磁盘的物理结构**：
    * **磁盘**：由表面涂有磁性物质的金属或塑料构成的圆形盘片。
    * **磁头**：从磁盘中存取数据的导体线圈。
    * **磁道**：磁盘盘面上数据存储的一组同心圆。
    * **扇区（盘块）**：磁道被划分为若干扇区，扇区固定存储大小，是磁盘寻址和读写的基本单位。
    * **柱面**：所有盘片上半径相同的同心磁道集合。
    * **知识点**：
        * 通过磁头臂带动磁头移动到磁盘的相应磁道上方读取数据。
        * 每个扇区的存放数据量相同，但最内侧的扇区面积最小，扇区数据密度最大。
* **操作系统对磁盘的抽象**：
    * 操作系统不会直接操作磁头、盘片、扇区等物理细节。
    * 它将磁盘抽象为一系列**逻辑块 (Logical Blocks)**，每个逻辑块通常对应一个扇区。
    * 操作系统通过**逻辑块地址**来访问数据，然后由磁盘控制器将逻辑块地址转换为物理地址（柱面号、磁头号、扇区号）。
* **读写磁盘数据块的过程**：
    1. 根据柱面好移动磁头臂，让磁头移动到对应的柱面
    2. 激活对应盘面的磁头；
    3. 当磁盘旋转时，磁头从对应扇区上划过，从而完成对制定扇区的读写。

* **磁盘的物理特性对OS的影响**：
    * **寻道时间**：磁头移动到目标磁道的时间，是磁盘访问最耗时的部分。操作系统需要通过调度算法来优化它。
    * **旋转延迟**：等待目标扇区旋转到磁头下方的时间。
    * **数据传输时间**：实际读写数据的时间。

### 2. 磁盘的管理
#磁盘管理
操作系统对磁盘的管理，主要包括以下几个方面：
* **磁盘初始化 (Disk Initialization)**：
    * **低级格式化（物理格式化）**：将磁盘划分为一个个扇区，并检测该磁盘是否有坏扇区。新磁盘是一个含有磁性记录材料的空白盘。在磁盘能存储数据前，必须分成扇区以便磁盘控制器能进行读和写操作。低级格式化为磁盘的每个扇区采用独特的数据结构。每个扇区的数据结构通常由头部、数据区域和尾部组成。头部和尾部包含了一些磁盘控制器所使用的信息。
    * **分区 (Partitioning)**：将磁盘分为由一个或多个柱面组成的分区（如C盘、D盘等逻辑分区）。每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中。
    * **逻辑格式化（高级格式化）**：对物理分区进行逻辑格式化（创建文件系统），操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录。对主引导记录中分区表相应区域的重写、根据用户选定的文件系统，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间，以便用户使用该分区管理文件。
        * 每个分区都建立独立的文件系统。
        * 因扇区的单位太小，OS将多个相邻的扇区组合在一起，形成一**簇（块）**。一簇只能存放一个文件的内容，文件所占用的空间只能是簇的整数倍；如果文件大小小于一簇（甚至是0字节），也要占用一簇的空间。
* **坏块管理 (Bad Block Management)**：
    * 磁盘在出厂时或使用过程中可能会出现坏块。
    * 操作系统或磁盘控制器会维护一个**坏块列表**。
    * 当访问到坏块时，会将其**逻辑地址映射到备用扇区**，或者直接跳过该坏块。
* **引导块 (Boot Block)**：
    * 磁盘的第一个扇区通常是**引导块**，包含引导程序（Bootloader）。
    * 计算机启动时，BIOS/UEFI会加载引导块中的程序，然后由引导程序加载操作系统内核。

### 3. 磁盘调度算法
#磁盘调度算法
**目标**： 减少磁头移动距离，从而减少寻道时间，提高磁盘I/O效率。

* **评价指标**：
    * **吞吐量**：单位时间内完成的I/O请求数。
    * **平均响应时间**：请求从发出到完成的平均时间。
    * **公平性**：所有请求都能得到处理，避免饥饿。
* **常见算法**：
    * **1）FCFS (First-Come, First-Served) 算法**：
        * **原理**：根据进程请求访问磁盘的先后顺序进行调度。
        * **优点**：公平，实现简单。若少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，能达到较好的性能。
        * **缺点**：效率低，当大量进程竞争使用磁盘时，性能往往接近于随机调度。
    * **2）SSTF (Shortest Seek Time First) 算法**：
        * **原理**：选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以使每次的寻找时间最短。
        * **优点**：吞吐量高。
        * **缺点**：可能产生"饥饿"现象。若某时刻磁头正在18号磁道，而在18号磁道附近频繁地增加新的请求，将使184号磁道的访问被无限期地延迟。
    * **3）SCAN (电梯算法)**：
        * **原理**：磁头在一个方向上（如从内到外）移动，处理沿途的所有请求，到达磁盘一端后反向移动，处理另一方向的请求。就像电梯一样。
        * **优点**：避免饥饿现象。
        * **缺点**：只有到达最边上才能改变方向；对最近扫描过的区域不公平。
    * **4）C-SCAN (循环扫描) 算法**：
        * **原理**：在SCAN算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。
        * **优点**：比SCAN更公平，对所有请求的响应时间更均匀。
        * **缺点**：返回途中不处理请求，有一定浪费。
    * **5）LOOK调度算法**：
        * **原理**：对SCAN算法和C-SCAN算法的改进：磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。
        * **优点**：减少了不必要的磁头移动，效率更高。
    * **6）C-LOOK调度算法**：
        * **原理**：解决C-SCAN算法中只有到达最边上的才改变磁头移动方向，以及返回到最边缘的问题。如果磁头移动方向上已经没有磁道访问请求，可以立即让磁头返回。
* **磁盘相关时间**：
    * **一次磁盘读/写所需的时间 = 寻找时间 + 延迟时间 + 传输时间**
    * **寻找时间（寻道时间）**：
        * 在读/写数据前，将磁头移动到指定磁道上方所花的时间。
        * 寻道时间 = 启动磁头臂时间 + 移动磁头时间。
        * 操作系统只能改变寻找时间（通过磁盘调度算法的不同）。
    * **延迟时间**：
        * 通过旋转磁盘，使磁盘定位到目标扇区所需要的时间。
        * 磁盘转速为`r`（转/秒），`1/r`为磁盘转一圈的时间。找到目标扇区平均需要转半圈（可能第一个就能找到，也可能最后才能找到，按半圈）。
        * 平均所需的延迟时间 `T_latency = (1/2) * (1/r) = 1/(2r)`。
    * **传输时间**：
        * 每个磁道可存`N`个字节，读/写`b`字节的数据需要`b/N`个磁道才能存取。
        * 而读/写一个磁道所需的时间为`1/r`（磁盘转一圈即完成一个磁道的读/写），即共需 `b/(rN)`。

### 磁盘空闲存储空间管理方法
#### 1. **位示图 (Bitmap / Bit Vector)**
*   **核心思想**：用一个**二进制位（bit）序列**来表示磁盘上所有存储块的空闲状态。
*   **结构**：一个连续的比特数组。
*   **映射关系**：位示图中的每一个比特位都**唯一对应**磁盘上的一个物理块。
    *   例如，第 `i` 个比特位对应着磁盘上的第 `i` 个块。
*   **状态表示**：
    *   `0` 表示对应的磁盘块是**空闲的**（或已分配，取决于约定）。
    *   `1` 表示对应的磁盘块是**已分配的**（或空闲）。
    *   （本题中，2KB 内存管理 16384 个磁盘块，完美匹配每个块用 1 bit，所以此方法非常适用。）
*   **操作**：
    *   **分配**：当需要分配 `k` 个连续的空闲块时，系统扫描位示图，找到 `k` 个连续的 `0`（或 `1`），然后将它们置为 `1`（或 `0`），并返回起始块号。
    *   **回收**：当回收某个块时，找到对应的比特位，将其置为"空闲"状态。
*   **优点**：
    *   **空间效率高**：每个块只需一个比特位，存储开销极小。
    *   **易于实现**：操作简单直观。
    *   **方便查找连续空闲块**：通过位操作或简单的扫描即可实现。
*   **缺点**：
    *   当磁盘容量非常大时，位示图本身也会很大，可能需要占用大量内存或分成多级管理。

#### 2. **空闲链表 (Free List)**
*   **核心思想**：将磁盘上的所有**空闲块连接成一个链表**。
*   **结构**：每个空闲块中包含指向下一个空闲块的指针（块号）。
*   **操作**：
    *   **分配**：从链表头部取走一个或多个空闲块。
    *   **回收**：将回收的块插入到链表头部或尾部。
*   **优点**：
    *   简单，容易实现。
    *   不需要额外的内存空间来维护空闲状态信息（信息分散在空闲块本身）。
*   **缺点**：
    *   **效率较低**：要找到连续的空闲块非常困难，需要遍历整个链表。
    *   **碎片化**：容易产生外部碎片。
    *   **如果链表损坏，会导致大量空闲块丢失。**

#### 3. **空闲块组 (Grouping)**
*   **核心思想**：空闲链表的改进版。**将多个空闲块的信息集中存放在一个空闲块中**，形成一个"组"。
*   **结构**：一个空闲块中不只包含指向下一个空闲块的指针，还包含一个**列表，列出了多个其他的空闲块号**。最后一个空闲块号指向下一个空闲块组。
*   **优点**：
    *   比单纯的空闲链表查找效率高，可以一次性获取多个空闲块。
    *   减少了磁盘I/O次数。
*   **缺点**：
    *   仍存在查找连续空闲块的困难。

#### 4. **成组链接法 (Counting Method)**
*   **核心思想**：当有大量连续空闲块时，只记录**起始空闲块的地址和连续空闲块的数量**。
*   **结构**：维护一个空闲区列表，每个列表项记录一个起始地址和长度。
*   **优点**：
    *   特别适合管理**连续的大块空闲空间**，减少了记录空闲信息的数量。
*   **缺点**：
    *   当空闲块非常分散时，效率优势不明显。

### 4. 固态硬盘 (SSD)
#固态硬盘

SSD的出现，对操作系统的磁盘管理带来了新的挑战和机遇。

* **1）概念**：
    * SSD是基于闪存技术的存储器。由一个或多个闪存芯片和闪存翻译层组成。
    * 属于电可擦除ROM，即EEPROM。
* **2）组成**：
    * **闪存翻译层（FTL）**：负责翻译逻辑块号，找到对应物理页。
    * **闪存介质**：多个闪存芯片，每个芯片包含多个块，每个块包含多个页。
* **3）读写性能特性**：
    * 数据以**页**为单位读写。只有在一页所属的**块**整个被擦除后，才能写这一页。
    * 以**块**为单位"擦除"。一旦擦除一个块中的每页就可以直接再写一次。
    * **擦写寿命有限**：某块进行若干次重复写后，就会磨损，无法再使用。
    * **随机写很慢**：如果写操作试图修改包含已有数据的页P，那么这个块中所有含有用数据的页都必须被复制到一个新（擦除过的）块中，然后才能进行对页P的写操作（写放大）。
    * SSD由半导体存储器构成，没有移动部件，随机访问时间比机械磁盘快很多，没有机械噪声和功耗更低、抗震性好、安全性高等。
* **4）磨损均衡 (Wear Leveling)**：
    * **目的**：将"擦写"操作均匀分布在各个块上，提升使用寿命。
    * **静态磨损均衡**：写入数据时，自动选择较新的闪存块。老的闪存块先歇一歇。
    * **动态磨损均衡**：SSD会监测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常读写操作在较新闪存块中进行。
    * **TRIM 命令**（操作系统配合）：当操作系统删除一个文件时，它会向SSD发送TRIM命令，通知SSD控制器哪些数据块已经不再使用。SSD控制器收到TRIM命令后，可以将这些"已删除"的数据块标记为无效，并在空闲时进行**垃圾回收 (Garbage Collection)**，提前擦除这些块，为后续的写入操作做好准备。这可以减少写入放大，提高写入性能，并延长SSD寿命。
    * **不进行磁盘调度**：由于SSD没有机械臂，没有寻道时间，所以传统的磁盘调度算法（如SSTF, SCAN）对SSD**不再有意义**。操作系统会直接将I/O请求发送给SSD控制器。

---
