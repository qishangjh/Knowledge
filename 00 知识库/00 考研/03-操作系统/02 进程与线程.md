---
科目: "408"
课程名称: 操作系统
tags: [操作系统]
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频: -1
备注:
---

# 02 进程与线程
#OS #进程管理 #CPU调度 #同步互斥 #死锁
## 02-1 进程与线程
在  #多道程序 环境下，为了让计算机能够同时（宏观上）执行多个任务，实现操作系统的 **`并发性`** 和 **`共享性`** 这两个最基本的特征，我们引入了"进程"这个至关重要的概念。它解决了多程序在共享资源和独立执行时可能遇到的**失去封闭性、具有间断性及不可再现性**等问题。

### 1. 进程的概念、组成、特征
#### (1) 进程的概念
*   **程序 (Program)**：
    *   `静态的`：仅仅是存放在磁盘里的一系列指令和数据的集合，是**可执行文件**，是**没有生命的"躯壳"**。
*   **进程 (Process)**：
    *   `动态的`：是一个程序及其数据从磁盘加载到内存后，在 CPU 上执行**一次完整的执行过程**。它是**程序的一次执行实例**，是**有生命的"细胞"**。
    *   `核心`：进程是**进程实体（进程映像）的运行过程**，是系统进行**资源分配**和 **调度** 的一个**独立单位**。 **(Q62 - 2012统考真题)**
    *   `本质`：进程是动态的（有生命周期），但**进程实体（进程映像）本身是静态的数据结构**（在特定时刻，其代码、数据和 PCB 内容相对固定，但其状态在不断变化）。
    *   `标志`：**PCB (进程控制块) 是进程存在的唯一标志**，并且常驻内存。
        *   创建进程，实质上是**创建进程映像中的 PCB**。
        *   撤销进程，实质上是**撤销进程的 PCB**。
    *   `标识符`：当进程被创建时，操作系统会为该进程分配一个**唯一的、不重复的 PID (Process ID)**。

#### (2) 进程的组成
一个进程实体（或称进程映像， #进程映像 ）由以下三大部分组成：

1.  **进程控制块 (PCB - Process Control Block)**： `#PCB`
    *   **定义**：操作系统用于管理和控制进程的**唯一数据结构**，是进程存在的唯一标志。它包含了操作系统管理进程所需的一切信息。
    *   **内容**：![[考研学习笔记03-操作系统 02 进程与线程 2025-10-10 0334.png]]
        *   **进程描述信息**：
            *   `进程标识符 PID` (Process ID)。
            *   `用户标识符 UID` (User ID)。
            *   为了描述进程家族关系，还包括父进程标识符及子进程标识符列表。
        *   **进程控制和管理信息**：
            *   `进程当前状态`：如新建态、就绪态、运行态、阻塞态、终止态等。
            *   `优先级`：用于进程调度。
            *   CPU 使用时间、磁盘 I/O 次数、网络流量使用情况等统计信息。
        *   **资源分配清单**：
            *   正在使用的文件（文件描述符列表，如 Q75 中提到的文件描述符 `fd`，是进程共享资源）。
            *   正在使用的内存区域信息（如页表起始地址、段表地址、内存区起止地址）。
            *   正在使用的 I/O 设备列表。
        *   **处理机相关信息 (CPU 上下文)**：
            *   用于实现进程切换时保存和恢复 CPU 现场，确保进程可以从上次中断的地方继续执行。
            *   `程序计数器 (PC)`：存放下一条要执行指令的地址。
            *   `程序状态字 (PSW)`：含有 CPU 的状态信息，如条件码、执行方式（用户态/内核态）、中断屏蔽标志等。
            *   `通用寄存器`：用户程序可访问，用于暂存运算数据和中间结果。
            *   `栈指针`：指向系统栈（或用户栈）的栈顶，系统栈用于存放过程（函数）和系统调用参数及返回地址。

2.  **程序段 (Program Segment)**：`#程序段`
    *   存放进程即将被 CPU 执行的**程序代码**。
    *   **特点**：程序代码通常是**只读的**，并且可以被**多个进程共享**（例如，多个用户同时运行同一个文本编辑器程序，它们的进程会共享同一份代码）。

3.  **数据段 (Data Segment)**：`#数据段`
    *   一个进程的数据段，可以是进程对应的程序加工处理的**原始数据**（如全局变量、静态变量），也可以是程序执行时产生的**中间或最终结果**。每个进程通常拥有独立的、可写的**数据段**和**堆栈段**。

#### (3) 进程的特征

1.  **动态性** (`#动态性`)：
    *   这是进程**最基本、最核心的特征**。进程是程序的一次执行过程，是动态地产生、变化和消亡的。程序是静态的，进程是动态的。
2.  **并发性** (`#并发性`)：
    *   内存中有多个进程实体，各进程可在**同一时间段内交替执行**（宏观上并行），实现多任务处理，但在**单核 CPU** 上，微观上看，**同一时刻最多只有一个进程正在运行**。
 > [!并行和并发]
> *   `并行 (Parallelism)`：指两个或多个任务在**同一时刻**同时执行（需要多核 CPU 或多处理器）。
> *   `并发 (Concurrency)`：指两个或多个任务在**同一时间段内**交替进行，宏观上同时发生，微观上串行（单核 CPU 上通过时间片轮转实现）。
3.  **独立性** (`#独立性`)：
    *   进程是系统**独立运行、独立获得资源、独立接受调度**的基本单位。每个进程拥有独立的地址空间，互不干扰（但可通过 IPC 机制协作）。
4.  **异步性** (`#异步性`)：
    *   各进程按各自独立的、**不可预知的速度**向前推进（取决于调度、I/O 速度等）。
    *   这种异步性可能导致执行结果的不可再现，因此操作系统需要提供**"进程同步机制"**来协调进程的执行顺序。
5.  **结构性** (`#结构性`)：
    *   每个进程都会配置一个唯一的 **PCB**。从结构上看，进程由**程序段、数据段和 PCB** 三部分组成，使得静态的程序拥有了动态的执行能力和可管理性。

#### (4) 进程控制块 PCB 的作用与信息

*   **PCB 的作用 (进程存在的唯一标志)**：
    *   `作为独立运行基本单位的标志`：PCB 记录了用于描述进程状况和管理进程运行的全部信息，使一个静态程序（含数据）能够成为一个能独立运行、独立获得 OS 服务的进程。
    *   `实现间断性运行方式`：进程的运行是停停走走的间断性。当进程暂停运行时，必须保留 CPU 现场信息（即上下文），以便再次被调度时，能够恢复其 CPU 现场信息。这些信息就保存在 PCB 中。
    *   `提供进程管理所需信息`：操作系统通过 PCB 来掌握进程的各种状态和资源使用情况，进行有效的管理（如 Q70 中创建进程时必须申请和初始化 PCB）。
    *   `提供进程调度所需信息`：调度程序运行时，根据 PCB 中的进程状态、优先级等信息，选择合适的进程投入运行。
    *   `与其它进程的同步与通信`：PCB 中还可能包含用于实现进程间通信（IPC）的区域或通信队列指针、信号量等信息。

*   **PCB 的信息**：
    1.  **进程标识符**：唯一标识一个进程。
        *   `外部标识符`：由创建者提供，如父进程标识（PPID）、子进程标识列表、用户标识（UID）。
        *   `内部标识符`：系统赋予的唯一数字标识符（PID）。
    2.  **处理机状态（CPU 上下文）**：用于实现进程切换时保存和恢复 CPU 现场。
        *   `用户可视寄存器`：用户程序可访问，用于暂存信息（如通用寄存器）。 **(2012统考真题)**
        *   `程序计数器 (PC)`：存放下一条指令地址。
        *   `程序状态字 (PSW)`：含有状态信息，如条件码、执行方式（用户态/内核态）、中断屏蔽标志等。中断处理一定会保存 PSW。
        *   `栈指针`：指向系统栈栈顶，用于存放过程和系统调用参数及返回地址。
    3.  **进程调度信息**：OS 调度时必须了解的信息。
        *   `进程状态`：当前状态，是调度和对换（页面置换）的重要依据。
        *   `优先级`：描述进程使用处理机的优先级别。
        *   `其他信息`：与所采用的进程调度算法有关，如等待事件类型（导致进程阻塞的原因）。
    4.  **进程控制信息**：用于进程控制的必要信息。
        *   `程序和数据的地址`：进程实体中程序和数据的内存或外存起始地址。
        *   `进程同步和通信机制`：如消息队列指针、信号量等，可能全部或部分放在 PCB 中。
        *   `资源清单`：进程运行期间所需的全部资源（除 CPU 外，如打开文件列表、I/O 设备），及已分配的资源清单。
        *   `链接指针`：用于将 PCB 连接到各种队列（如就绪队列、等待队列）中。

#### (5) 进程与程序关系

*   **动态与静态**：进程是**动态的**（有生命周期），程序是**静态的**（可长久保存于磁盘）。
*   **暂时与永久**：进程是**暂时的**（随执行而产生和消亡），程序是**永久的**（一旦编译完成可反复使用）。
*   **创建与形成**：一个程序可以生成**多个不同的进程**（多次运行），一个进程可以执行**多个程序**（如 Shell 程序可以根据用户命令启动其他程序）。进程可以创建其他进程，而程序不能形成新的程序。
*   **特性**：进程具有**并发性、独立性、异步性**等特征，程序则不具备。
*   **关系类型**：
    *   `一对一关系`：执行一条命令或运行一个应用程序。
    *   `一对多关系`：进程在执行过程中可以加载执行不同应用程序。
    *   `多对一关系`：以不同参数多次执行同一程序。
    *   `多对多关系`：并发地执行不同应用程序。

#### (6) 进程与作业关系

*   **作业 (Job)**：用户需要计算机完成某项任务而要求计算机所做工作的集合，是用户向系统提交的**任务实体**。
*   **进程 (Process)**：已提交完毕的作业的运行过程，是**资源分配的基本单位**和**执行实体**。
*   **组成**：一个作业可由多个进程（如编译、链接、运行）、至少由一个进程组成；一个进程不能构成多个作业。
*   **阶段**：一个作业的完成要经过作业提交、作业收容、作业执行和作业完成 4 个阶段。

### 2. 进程的状态与转换

#### (1) 五种基本状态
1.  **运行状态 (Running)**： #运行态
    *   进程**占有 CPU**，并在 CPU 上运行。
    *   `单核 CPU`：同一时刻只会有一个进程处于运行态。
    *   `多核 CPU`：可以有多个进程并行处于运行态。
2.  **就绪状态 (Ready)**：`#就绪态`
    *   进程**具备运行所需的所有条件**（除 CPU 外的所有资源都已具备），但由于没有空闲 CPU，而暂时不能运行。
    *   通常有多个进程处于就绪态，排队等待 CPU 调度。
3.  **阻塞状态 (Waiting/Blocked / 等待态)**：`#阻塞态`
    *   进程**因等待某一事件（如 I/O 完成、资源可用、收到信号等）而暂时不能运行**。
    *   操作系统剥夺该进程 CPU 使用权，使其进入阻塞态，并将 CPU 分配给其他就绪进程。
    *   若该进程等待的事件处理完成后，该进程就会重新从阻塞态变为就绪态。
4.  **创建状态 (New / 新建态)**：`#创建态`
    *   进程正在被创建，操作系统正在为进程分配资源、初始化 PCB 等。
5.  **终止状态 (Terminated / 结束态)**：`#终止态`
    *   进程正在从系统中撤销，操作系统会回收进程拥有的所有资源、撤销 PCB 等。
    *   进程可以通过执行 `exit` 系统调用请求操作系统终止自身。

#### (2) 状态间的转换

![[02 进程与线程 2025-10-04 20.44.31.excalidraw]]

*   `创建态 → 就绪态`：操作系统完成进程资源分配、PCB 初始化等操作后，将 PCB 插入就绪队列。
*   `就绪态 → 运行态`：进程调度器选择一个就绪进程，将其调度到 CPU 上执行。
*   `运行态 → 就绪态`：
    *   `时间片用完`：采用时间片轮转调度时，当前进程的时间片用完，被操作系统剥夺 CPU。 **(2015统考真题)**
    *   `高优先级抢占`：在可剥夺（抢占式）调度算法中，有更高优先级的进程进入就绪态，当前进程被强制剥夺 CPU。 **(2015统考真题)**
    *   `主动放弃`：进程主动通过 `yield()` 系统调用等方式放弃 CPU 使用权。 **(2023统考真题)**
*   `运行态 → 阻塞态`：`(进程主动行为)`
    *   进程**请求并等待**某个系统资源分配（如申请 I/O 外设）。 **(2022统考真题)**
    *   进程**等待**某事件发生（如 I/O 操作的完成、数据尚未到达）。 **(2018统考真题)**
    *   进程需要等待相互合作的其他进程完成工作（如通过 `wait()` 信号量操作等待资源）。 **(2022统考真题)**
    *   **【考点】**：导致进程阻塞的事件包括：进程申请临界资源而资源不可用；进程从磁盘读数据（等待 I/O）；进程执行信号量的 `wait()` 操作。 **(2018统考真题)**
*   `阻塞态 → 就绪态`：`(被动行为)`
    *   进程等待的**事件发生**，由操作系统将其从等待队列中移出。 **(2019统考真题)**
    *   **示例**：I/O 操作完成 **(2014统考真题; 2019统考真题)**、所需资源分配到位、被等待的信号量被 `signal()` 操作释放 **(2019统考真题)**、数据已到达。
    *   **注意**：进程不能从阻塞态直接转换为运行态，也不能从就绪态直接转换为阻塞态。中间必须经过其他状态或由操作系统调度。
*   `任何状态 → 终止态`：
    *   进程正常终止（执行完毕，或调用 `exit` 系统调用）。
    *   异常终止（如整数除 0、非法使用特权指令、越权访问内存）。
    *   外部干预（如用户手动杀死进程 `kill` 命令）。
    *   可以从任何状态直接进入终止态（例如，父进程终止子进程）。

### 3. 线程的实现
#### (1) 线程概念与引入原因
*   **什么是线程 (Thread)**：
    *   线程是一个基本的 **CPU 执行单元**，是程序执行流的**最小调度单位**。
    *   线程本身不能独立存在，它必须包含在进程中，作为进程的一部分执行。一个进程可以包含一个或多个线程。
*   **为什么要引入线程**：
    *   **提高程序并发度**：在进程内部实现并发，使得一个进程可以同时处理多个任务。
    *   **减少系统开销**：线程的创建、撤销和切换比进程更轻量级，开销更小。
    *   **提高资源利用率**：当一个线程阻塞时，同一进程中的其他线程可以继续执行，提高了 CPU 利用率。

#### (2) 引入线程机制后的变化

*   **资源分配与调度**：
    *   `传统进程`：进程是资源分配和调度的基本单位。
    *   `引入线程后`：**进程仍是资源分配的基本单位**（拥有独立的地址空间、文件句柄等资源），而**线程成为 CPU 调度的基本单位**（拥有独立的执行流和 CPU 上下文）。 **(2012统考真题)**
*   **并发性**：
    *   `传统进程`：只能实现进程间的并发。
    *   `引入线程后`：进程之间可以并发，**进程内的各线程之间也可以并发**，显著提高了程序的并发度。
*   **系统开销**：
    *   线程的创建、撤销和切换，通常**比进程的开销小得多**，因为线程共享进程的大部分资源，无需分配或回收整个地址空间。
*   **地址空间和其他资源**：
    *   进程的地址空间之间互相独立。
    *   **同一进程的各线程间共享进程的所有资源**（包括进程的地址空间、全局变量、打开的文件描述符列表、信号等）。
        *   **【考点】**：线程**不能共享**的是**线程独立的栈指针**（每个线程有独立的栈）。 **(Q61 - 2011统考真题)**
        *   **【考点】**：Ta 与 Tb （同一进程下的线程）可以共享**进程的地址空间**和**文件描述符**。 **(Q75 - 2024统考真题)**
    *   各个线程可以访问进程地址空间的每个单元，一个线程可以读写甚至清除另一线程的堆栈（虽然不推荐）。
*   **通信方面**：
    *   进程间通信 (IPC) 需要操作系统提供的复杂机制（如管道、消息队列、共享内存）。
    *   **线程间通信可以直接通过读/写进程共享的内存空间**（如全局变量、堆上的数据）以及局部变量来进行，效率更高。

#### (3) 线程实现的方式

1.  **用户级线程 (ULT - User-Level Thread)**：`#用户级线程`
    *   **概念**：线程的管理（创建、撤销、调度、切换）完全在**用户空间**实现，由用户态的**线程库**（如 POSIX Pthreads）负责。操作系统内核**不感知**用户级线程的存在，只将整个进程视为一个调度实体。
    *   **优点**：
        *   线程切换不需要操作系统内核参与，**不需要转换到内核空间**，避免了模式切换的开销，**效率高**。 **(Q68 - 2019统考真题)**
        *   同一个进程可以选择不同的线程调度算法。
        *   用户级线程的实现与底层操作系统平台无关，移植性好。
        *   可以在**不支持内核级线程的操作系统上实现**。 **(Q68 - 2019统考真题)**
    *   **缺点**：
        *   如果单个用户级线程执行系统调用或被阻塞（例如等待 I/O），操作系统会将整个进程阻塞，导致**整个进程的所有线程都无法执行**，并发度不高。
        *   由于操作系统只调度进程，无法将一个进程内的多个用户级线程分配到**多核处理机上并行运行**。

2.  **内核级线程 (KLT - Kernel-Level Thread)**：`#内核级线程`
    *   **概念**：线程的管理由**操作系统内核**实现。系统会为每个内核级线程建立相应的**线程控制块 (TCB)**，并通过 TCB 对线程进行管理、调度和切换。内核级线程是"从操作系统内核视角看能看到的线程"。
    *   **优点**：
        *   一个内核级线程被阻塞后，同一进程中的**其他内核级线程还可以继续执行**，并发能力强。
        *   内核可以将同一进程内的多个内核级线程分配到**多核处理机上并行执行**。
        *   **内核级线程的调度由操作系统完成**。 **(Q68 - 2019统考真题)**
    *   **缺点**：
        *   线程的创建、撤销、调度和切换等操作**需要内核负责**，每次操作都需要从用户态切换到内核态，**开销较大**。
        *   一个用户进程可能会占用多个内核级线程，增加了内核的开销。

#### (4) 多线程模型
(用户级线程与内核级线程的映射关系)

1.  **一对一模型 (One-to-One)**：`#一对一模型`
    *   `特点`：一个用户级线程映射到一个内核级线程。每个用户进程有多少个用户级线程，内核就为其创建多少个内核级线程。
    *   `优点`：线程可在多核处理机上并行执行；一个用户级线程被阻塞后，同进程的其他线程可以继续执行，并发能力强。
    *   `缺点`：线程切换开销相对较大（每次切换都涉及内核），一个用户进程占用较多的内核资源。

2.  **多对一模型 (Many-to-One)**：`#多对一模型`
    *   `特点`：多个用户级线程映射到一个内核级线程。一个用户进程只被分配一个内核级线程。
    *   `优点`：用户级线程的切换在用户空间即可完成，不需要切换到核心态，系统开销小，效率高。
    *   `缺点`：当一个用户级线程被阻塞后，整个进程（即唯一的内核级线程）都会被阻塞，导致所有用户级线程都无法执行，并发度低。多个用户级线程无法在多核处理机上并行运行。

3.  **多对多模型 (Many-to-Many)**：`#多对多模型`
    *   `特点`：M 个用户级线程映射到 N 个内核级线程（通常 N ≤ M）。每个用户进程对应 N 个内核级线程。
    *   `优点`：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程、开销太大的缺点。兼顾了效率和并发性。
    *   `本质`：用户级线程是"代码逻辑"的载体，内核级线程是"运行机会"的载体。

### 4. 进程与线程的组织与控制
#### (1) 进程控制基本概念
*   **概念**：进程控制是操作系统对系统中的所有进程实施有效管理（如创建、撤销、状态转换）的主要功能。
*   **实质**：实现进程的各种**状态转换**。
*   **实现**：通过**原语 (Primitive)** 实现进程控制操作。
#### (2) 进程控制相关的原语
*   **原语 (Primitive)**： `#原语`
    *   `原子性`：原语的执行具有**原子性**，意味着它是一个不可分割的操作序列，必须一气呵成，在执行过程中**不能被中断**。
    *   `实现`：通常通过**关中断、开中断指令**这两个**特权指令**来实现原子性，从而防止并发访问时的数据不一致问题。
    *   `重要性`：如果进程控制操作不是原子性的，则可能在操作完成一半时被中断，导致系统状态混乱或数据不一致。

*   **创建原语 (Create)**：`#创建原语`
    1.  分配唯一的进程标识号（PID），申请空白 PCB。 **(2021统考真题)**
    2.  为进程分配所需资源（如内存空间）。
    3.  初始化 PCB（填写进程标识、处理机状态、调度信息、控制信息等）。 **( 2021统考真题)**
    4.  将 PCB 插入就绪队列（状态由**创建态 → 就绪态**）。
    *   `引起创建的事件`：
        *   **用户登录成功** (创建 Shell 进程)。 **(2010统考真题)**
        *   **启动程序执行** (为程序创建进程)。 **(2010统考真题)**
        *   作业调度。
        *   系统服务请求。
        *   用户进程请求创建子进程（如 `fork()`）。

*   **撤销原语 (Terminate)**：`#撤销原语 终止进程`
    1.  在 PCB 集合中找到终止进程的 PCB。
    2.  若进程正在运行，立即剥夺 CPU，分配给其他进程；终止其所有子进程（或将其变为孤儿进程）。 **(Q74 - 2024统考真题)**
    3.  进程拥有的所有资源归还给父进程或操作系统（如回收进程占用的设备、释放内存）。 **(Q74 - 2024统考真题)**
    4.  删除 PCB，释放 PCB 所占内存。 **(Q74 - 2024统考真题)**
    *   `引起终止的事件`：
        *   进程自己请求终止（如调用 `exit` 系统调用）。
        *   异常终止（如整数除 0、非法使用特权指令、越权访问内存）。
        *   外部干预（如用户手动杀死进程）。
        *   父进程终止子进程（取决于操作系统策略，不一定）。 **(Q74 - 2024统考真题)**

*   **阻塞原语 (Block)**：`#阻塞原语` `(运行态 → 阻塞态)`
    1.  找到要阻塞的进程对应的 PCB。
    2.  保护进程运行现场（将 CPU 上下文保存到 PCB）。
    3.  将 PCB 的状态信息设置为"阻塞态"，暂停进程运行。
    4.  将 PCB 插入响应事件的等待队列。
    5.  转到进程调度程序，选择一个新进程投入运行。
    *   `引起阻塞的事件`：
        *   等待系统分配某种资源（如 I/O 外设）。 **(Q71 - 2022统考真题)**
        *   等待相互合作的其他进程完成工作。
        *   等待 I/O 操作完成。 **(Q71 - 2022统考真题)**
        *   执行信号量的 `wait()` 操作。 **(Q71 - 2022统考真题)**
        *   **【考点】**：导致进程阻塞的事件包括：进程申请临界资源（如果资源不可用）；进程从磁盘读数据。 **(Q66 - 2018统考真题)**

*   **唤醒原语 (Wakeup)**：`#唤醒原语` `(阻塞态 → 就绪态)`
    1.  在事件等待队列中找到对应的 PCB。
    2.  将 PCB 从等待队列中移除，设置进程状态为"就绪态"。
    3.  将 PCB 插入就绪队列，等待被调度。
    *   `引起唤醒的时间`：进程等待的事件发生（因何事阻塞，就应由何事唤事）。
        *   **【考点】**：可能将进程唤醒的事件包括：I/O 结束；某进程退出临界区（释放了资源）。 **(Q67 - 2019统考真题)**
    *   **注意**：唤醒原语由**其他进程或操作系统调用**，对阻塞进程而言是被动行为。阻塞与唤醒原语必须**成对出现**。

*   **切换原语 (Switch)**：`#切换原语` `(运行态 ↔ 就绪态)`
    1.  保存处理机上下文（程序计数器、其他寄存器内容、PSW）到当前进程 PCB。
    2.  将当前进程的 PCB 移入相应队列（如就绪队列）。
    3.  选择另一个进程执行，并更新其 PCB。
    4.  恢复新进程所需的运行环境（从其 PCB 中）。
    *   `引起切换的事件`：进程时间片用完、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止。
    *   **注意**：进程切换一定会产生中断，并进行**处理器模式切换**（用户态 → 内核态），因为进程切换是操作系统的特权操作。 **(Q17 - 2012统考真题)**

#### (3) 进程的挂起 (Suspended)

*   **概念**：将进程从内存调出到外存（硬盘），使其状态变为"挂起就绪 (Suspended Ready)"或"挂起阻塞 (Suspended Blocked)"。
*   **挂起原因**：
    *   **用户的需要**：用户发现程序运行可疑问题，希望暂时挂起检查。
    *   **父进程请求**：父进程希望挂起子进程以协调执行。
    *   **调节负载的需要**：系统工作负荷重，内存资源不足时，OS 可能会挂起一些不活跃进程，释放内存。
    *   **系统的需要**：操作系统需要检查资源使用情况或进行记账。

#### (4) 线程的控制

*   **控制块 (TCB - Thread Control Block)**：`#TCB`
    *   每个线程配置一个线程控制块，用于记录、控制和管理线程的信息。
    *   `内容`：线程标识符 (TID)；一组寄存器（PC、程序状态字、通用寄存器）；线程运行状态；优先级；线程专有存储区；堆栈指针。
    *   **共享**：同一进程中的所有线程完全共享进程的地址空间和全局变量。各个线程可以访问进程地址空间的每个单元。
    *   **【考点】**：操作系统**不会**为每个用户级线程建立一个 TCB，而是由用户级线程库在用户空间维护。 **(Q68 - 2019统考真题)**

*   **线程的创建**：
    *   线程具有生命期，由创建而产生，由调度而执行，由终止而消亡。
    *   用户程序启动时，通常只有一个"初始化线程"执行，用于创建新线程。
    *   创建新线程需利用线程创建函数（如 `pthread_create()`），提供入口指针、堆栈大小、优先级等参数，返回线程标识符。

*   **线程的终止**：
    *   线程完成任务或出现异常时，调用相应函数终止。
    *   线程被终止后并不立即释放它所占有的资源（如栈空间），只有当进程中的其他线程执行了**分离函数 (detach)** 或**等待函数 (join)** 后，被终止线程才与资源分离并被回收。
    *   被终止但尚未释放资源的线程（即处于"僵尸"状态）可被其他线程调用，以获取其退出状态。

*   **线程的切换**：
    *   线程切换时需要保存/恢复：PC（程序执行到哪）、其他寄存器（程序当前运行的结果）和堆栈指针。
    *   每个线程都有独立的栈用于保存函数调用信息（例如函数返回地址）和局部变量。

### 5. 进程间通信 (IPC - Inter-Process Communication)

当多个进程需要相互协作完成任务时，它们需要进行信息交换。进程间通信是实现这一目的的机制。

#### (1) 共享存储 (Shared Memory)

*   **原理**：设置一个**共享内存区域**，多个进程可以映射并访问这块共享内存。进程通过对共享内存的读写来交换数据。
*   **实现**：进程需要通过系统调用向操作系统申请一片共享内存，并将其映射到自己的地址空间。
*   **两种方式**：
    *   `基于数据结构` (低级)：操作系统提供一些共享的数据结构（如共享缓冲区），适用于传递相对少量的数据，但通信效率可能受限。
    *   `基于存储区` (高级)：操作系统提供一大块共享内存区，进程可以自由决定共享内存中区域的读写形式、数据存放等细节，限制少，通信速度快，但需要进程自己通过同步机制（如信号量、互斥锁）来保证数据一致性。
*   **特点**：通信速度最快，因为数据直接在内存中传递，无需内核中转，但编程复杂，需要程序员自行处理同步互斥问题。

#### (2) 消息传递 (Message Passing)

*   **原理**：进程间的数据交换以**格式化的消息 (Message)** 为单位。进程通过操作系统提供的"发送消息"和"接收消息"两个原语来进行数据交换。
*   **消息结构**：由消息头和消息体构成。
    *   `消息头 (概要信息)`：包含发送进程 ID、接收进程 ID、消息长度、消息类型等。
    *   `消息体 (具体信息)`：包含具体的待交换数据。
*   **操作**：操作系统在内核中维护消息缓冲区和消息队列。
    *   `发送消息`：发送进程将消息（及其头部）封装好，调用发送原语，由 OS 将消息发送到目标进程的消息队列或信箱。
    *   `接收消息`：接收进程调用接收原语，从其消息队列或信箱中获取消息。
*   **两种通信方式**：
    *   `直接通信方式`：发送方进程需明确指明接收方进程的 ID，消息直接挂到接收进程的消息缓冲队列上。
    *   `间接通信方式`：通过一个中间实体（如**信箱或端口**）进行通信。消息先发送到信箱中，接收进程从信箱中获取消息。信箱存放在操作系统内核的地址空间中。
*   **特点**：编程相对简单，操作系统负责同步互斥，安全性高，但通信速度相对较慢（需要内核参与）。

#### (3) 管道通信 (Pipe Communication)

*   **原理**：管道是一种特殊的**内存缓冲区**（或称为**"特殊共享文件"**），数据在管道中以**先进先出 (FIFO)** 的方式传输。
*   ![[02 进程与线程 2025-10-04 20.53.37.excalidraw]]
*   **特点**：
    *   **半双工通信**：通常，一个管道**只能实现单向数据传输**。若要实现双向通信，需要建立两个管道。 **(Q64 - 2014统考真题)**
    *   **基于文件系统**：管道在文件系统中表现为一个特殊文件，但其实质是操作系统内核维护的一个环形缓冲区。
    *   **容量限制**：管道的容量是固定的（通常由操作系统设置，如几 KB 到几十 KB），它位于**内核内存中**，**不受磁盘容量大小限制**。 **(Q64 - 2014统考真题)**
    *   **同步与阻塞**：进程对管道进行**读操作和写操作都可能被阻塞**。
        *   当管道**为空**时，读进程会被阻塞。
        *   当管道**已满**时，写进程会被阻塞。 **(Q64 - 2014统考真题)**
    *   **多读多写**：一个管道可以有**多个读进程和多个写进程**对其操作，但数据一旦被一个读进程读取，就会从管道中移除。 **(Q64 - 2014统考真题)**
    *   **生命周期**：匿名管道通常随进程而生，随进程而灭，多用于有亲缘关系的进程（如父子进程）间通信。命名管道 (FIFO) 具有文件名，可用于无亲缘关系进程间通信。

---

#### (5) 最高响应比优先 (HRRN, Highest Response Ratio Next)

*   **思想**：综合考虑作业/进程的**等待时间**和**要求服务时间**（运行时间）。
*   **规则**：每次调度时先计算各个作业/进程的**响应比**，选择响应比最高的作业/进程为其服务。
    *   **响应比 = (等待时间 + 要求服务时间) / 要求服务时间**
*   **方式**：**非抢占式**的算法。只有当前运行的作业/进程主动放弃处理机时才需调度。
*   **优点**：
    *   综合考虑等待时间和运行时间，调度性能优异。
    *   **等待时间相同**时，要求服务时间短的优先（体现了 SJF 的优点）。
    *   **要求服务时间相同**时，等待时间长的优先（体现了 FCFS 的优点）。
    *   对于长作业来说，随着等待时间越长，其响应比也会越来越大，从而**避免了长作业饥饿 (2011)** 的问题。

---

## 02-2 CPU调度与上下文切换
#CPU调度
### 1. 调度的基本概念
#### (1) 基本概念
* 在多道程序系统中，进程数量>CPU个数
* **定义**：对CPU进行分配，即从就绪队列中按照一定的算法（公平、高效），选择一个进程并将CPU分配给它运行

#### (2) 三个层次
![[考研学习笔记03-操作系统 02 进程与线程 今天16_09.jpg]]
1. **高级调度 (作业调度)**（`2012`）： #作业调度
    * `位置`：**内存与辅存**之间调度。
    * `频率`：最低。
    * `过程`：操作系统按一定原则从辅存的作业后备队列中挑选一个作业调入内存，并为之创建进程（即为其分配 PCB）。一个作业通常只被调入内存一次，调出内存一次。
    * `注意`：作业调入时会建立PCB，调出时才撤销PCB。
2. **中级调度 (内存调度)**： #内存调度
    * **目的**：提高内存利用率和系统吞吐量
    * `位置`：**内存与外存**之间调度。
    * `频率`：略高于作业调度。
    * `过程`：将处于"挂起"状态的进程（其数据和代码已调出到外存）重新调入内存（"激活"），或将内存中暂时不能运行的进程调出外存（"挂起"）。
    * `注意`：被挂起的进程的 PCB 会被组织成挂起队列，但其 PCB 仍然存在于内存中，以便快速恢复。
3. **低级调度 (进程/CPU调度)**（`2010`, `2011`, `2012`, `2013`, `2014`, `2016`, `2017`, `2018`, `2019`, `2020`, `2021`, `2022`, `2023`, `2024`）： #进程调度
    * `位置`：就绪队列中的进程分配CPU。
    * `频率`：最高，是操作系统中最基本和不可或缺的调度。
#### (3) 联系
*   作业调度为进程的活动做准备（创建进程）。
*   进程调度使进程能够正常活动起来（分配 CPU 运行）。
*   中级调度将暂时不能运行的进程挂起（优化内存）。
*   调度频率：作业调度次数最少，中级调度次数略多，进程调度频率最高。

### 2. 调度的目标（基本原则）
好的调度算法，其目标是实现系统资源的**高效、公平利用**，并优化用户的体验。
1. **CPU利用率 (CPU Utilization)**： #CPU利用率
    * `定义`：指CPU"忙碌"的时间占总时间的比例。
    * `计算`：`CPU利用率 = 忙碌的时间 / 总时间`。
2. **系统吞吐量 (System Throughput)**：`#系统吞吐量`
    * `定义`：单位时间内完成作业的数量。
    * `计算`：`系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间`。
3. **周转时间 (Turnaround Time)**（`2018`, `2023`, `2024`）： #周转时间
    * `定义`：从作业被提交给系统开始，到作业完成为止的这段时间间隔。
    * `计算`：`周转时间 = 作业完成时间 - 作业提交时间`。
    * `组成`：
        * 作业在外存后备队列上等待高级调度的时间。
        * 进程在就绪队列上等待低级调度的时间。
        * 进程在CPU上执行的时间（运行态）。
        * 进程等待I/O操作完成的时间（阻塞态）。
    * `注意`：后三项在一个作业的整个处理过程中可能发生多次。
4. **平均周转时间 (Average Turnaround Time)**（`2018`, `2023`）： #平均周转时间`
    * `计算`：`平均周转时间 = 各作业周转时间之和 / 作业数`。
    *   **目标**：尽可能短。
5. **带权周转时间 (Weighted Turnaround Time)**： #带权周转时间
    * 计算：`带权周转时间 = 作业周转时间 / 作业实际运行的时间`。尽可能小（值越小越好）
6. **平均带权周转时间 (Average Weighted Turnaround Time)**：`#平均带权周转时间`
    * `计算`：`平均带权周转时间 = 各作业带权周转时间之和 / 作业数`。
7. **等待时间 (Waiting Time)**（`2018`, `2019`, `2023`）： #等待时间
    * `定义`：指进程/作业处于等待处理机状态时间之和。
    * `进程`：等待时间指进程建立后等待被服务的时间之和，在等待I/O完成期间进程也在被服务，不计入等待时间。
    * `作业`：不仅考虑进程建立后的等待时间，还要加上作业在外存后备队列中等待的时间。
    * `注意`：调度算法只会影响作业/进程的等待时间。
8. **响应时间 (Response Time)**（`2017`, `2024`）： #响应时间`
    * `定义`：从用户提交请求到首次产生响应所用的时间。

### 3. 调度的实现
#### (1) 调度器组成
1. **排队器**：将就绪进程按照策略排成队列，以便调度程序选择。
2. **调度程序 (Scheduler)**： #调度程序 依据某种策略，从就绪队列中选取一个进程。
3. **分派器 (Dispatcher)**： #分派器 将CPU分配给调度程序所选的新进程。
4. **上下文切换器 (Context Switcher)**： #上下文切换器
      * **进程上下文**：指进程运行时的**所有现场信息**，包括 CPU 的所有寄存器值（如程序计数器 PC、程序状态字 PSW、通用寄存器等）、进程的状态和控制信息 (存储在 PCB 中)、以及堆栈中的内容。
    *   **流程**：
        *   第一步：将当前运行进程的上下文（即 CPU 现场信息）**保存**到其 PCB 中。
        *   第二步：装入分派程序的上下文（即分派器自身的运行现场），以便分派程序能够运行起来。
        *   第三步：移出分派程序的上下文，将新选进程的上下文（CPU 现场信息）**装入**处理机的各个相应寄存器。

#### (2) 调度的时机与调度方式（抢占式/非抢占式）

1. **什么时候需要调度？**（`2012`, `2017`, `2021`）
    *   **主动放弃 CPU**：
        *   进程正常结束或因错误异常而终止。
        *   进程主动请求阻塞（如等待 I/O 操作、等待信号量、系统调用完成并返回用户态）。
    *   **被动放弃 CPU (被剥夺)**：
        *   当前进程的时间片用完。
        *   有更紧急（如 I/O 中断）或更高优先级的进程进入就绪队列。
        *   中断处理结束（可能会引发调度）。
        *   进程状态转换（运行→就绪、运行→阻塞、阻塞→就绪）等事件发生。
2. **什么时候不能进行调度？**
    *   在处理**中断的过程中**：为了保证中断处理的及时性和完整性，通常会暂时屏蔽中断，避免在中断处理中再发生中断或进行进程切换。
    *   在**操作系统内核程序临界区中**：执行操作系统内核中的原子操作代码段时，为保证数据一致性，通常会暂时禁止中断（从而阻止抢占），确保临界区代码能够一气呵成地执行完毕。
    *   **【注意澄清】**：针对"进程处于临界区时不能进行处理机调度" (`2012`) 这个表述，在**抢占式系统**中，用户进程即使处于**自身的临界区**，也**可能被调度剥夺 CPU**（如时间片用完）。但这样做**可能导致并发问题**。因此，为了**保护临界区**的正确性，进程通常会使用互斥机制（如锁）来**主动避免**其他进程同时进入临界区，而不是调度器强制不能调度。但若特指**内核自身的临界区**，则通常会禁止中断以避免抢占。
3. **"狭义的进程调度"与"进程切换"的区别(2017)**：
    *   **狭义的进程调度**：仅指从就绪队列中**选择**一个要运行的进程。
    *   **进程切换**：指一个进程**让出**处理机，由另一个进程**占用**处理机的过程。
    *   **广义的进程调度**：包含了**选择**一个进程和**进程切换**这两个步骤。
4. **进程切换的过程与代价**： #进程切换
    * `过程`：
        1.  暂停当前运行进程，并**保存其 CPU 上下文**（PC、PSW、通用寄存器等处理机现场信息，通常保存在其 PCB 中）。
        2.  更新旧进程的 PCB 信息（如状态由运行态变为就绪态或阻塞态）。
        3.  将旧进程的 PCB 移入相应的队列（如就绪队列队尾或阻塞队列）。
        4.  选择另一个进程执行，并更新其 PCB 信息（如状态变为运行态）。
        5.  **恢复新进程的 CPU 上下文**（从其 PCB 中加载 PC、PSW、通用寄存器等）。
        6.  跳转到新进程 PCB 中的程序计数器所指向的位置执行。
    * `代价`：进程切换是**计算密集型**的操作，会消耗大量的 CPU 时间（现场保存、恢复、更新 PCB、队列操作等）。过于频繁的进程调度和切换，会增加系统开销，降低 CPU 的有效利用率和系统效率。
5. **调度方式**：
    * **非剥夺调度方式 (非抢占式)**： #非抢占式调度`
        * `规则`：只允许进程**主动放弃**处理机。一旦进程获得 CPU，它将一直运行，直到该进程终止，或主动要求进入阻塞态（如等待 I/O），或时间片用完（但此时仍是运行到下一个调度点才放弃）。
        * `优点`：实现简单，系统开销小。
        * `缺点`：无法及时处理紧急任务，不适合分时系统和大多数实时系统。适合早期批处理系统。
    * **剥夺调度方式 (抢占式)**： #抢占式调度`
        * `规则`：当一个进程正在 CPU 上执行时，如果发生**某种条件**（如时间片用完、更高优先级的进程到达、更紧急的中断发生），操作系统可以**立即暂停**正在执行的进程，将其 CPU 剥夺，并分配给其他进程。
        * `优点`：优先处理更紧急的进程，实现各进程按时间片轮流执行的功能（通过时钟中断）。
        * `缺点`：切换开销相对较大。
        * `适用`：分时操作系统、实时操作系统。

#### (3) 闲逛进程 (Idle Process)
* **定义**：在进程切换时，若系统中**没有就绪进程**可供调度，操作系统就会调度一个特殊的进程——**闲逛进程 (IDLE 进程)** 运行。
* **特点**：
    *   优先级最低。
    *   只要有任何进程进入就绪队列，闲逛进程就会立即让出 CPU。
    *   通常不需要 CPU 之外的资源，因此它永远不会被阻塞。
    *   它通常执行一个简单的空操作指令（如一个循环的 `NOP` 指令，占用完成的指令周期），并在执行过程中周期性地测试是否有中断发生。
    *   其开销极低。
    *   它使得 CPU 始终处于忙碌状态，避免 CPU 真正空闲。

#### (4) 内核级线程与用户级线程调度
*   **用户级线程调度**：
    *   **内核不可感知**：操作系统内核并不知道用户级线程的存在，它只将进程视为一个单一的调度单位。
    *   **由进程内部调度**：CPU 调度器选择一个进程并给予其时间片。在该进程内部，由用户级线程库中的调度程序决定该进程内的哪个线程运行。
    *   **切换开销小**：线程切换在**同一进程内部**进行，无需内核介入，仅需少量机器指令即可完成（如保存/恢复寄存器、切换栈指针）。
*   **内核级线程调度**：
    *   **内核可感知**：操作系统内核能够感知并直接管理和调度内核级线程。
    *   **由内核直接调度**：内核调度器选择一个特定的线程运行，无需考虑该线程属于哪个进程。
    *   **切换开销大**：线程切换需要完整的上下文切换（尽管线程间共享进程地址空间，但仍需保存/恢复线程特有的上下文），可能涉及修改内存映像、使高速缓存失效，导致一定的延迟。

### 4. 典型调度算法
*   **调度算法的分类**：
    *   **抢占式 vs. 非抢占式**：理解何时可以剥夺 CPU。
    *   **静态优先级 vs. 动态优先级**。

#### (1) 先来先服务 (FCFS, First Come First Serve)
* **规则**： #FCFS 按照作业/进程到达的先后顺序来分配CPU。
    * `作业调度`：哪个作业先到达后备队列。
    * `进程调度`：哪个进程先到达就绪队列。
* **方式**：非抢占式、不可剥夺算法。
* **优点**：公平、算法实现简单。
* **缺点**：对**短作业不利**（长作业后面的短作业需要等待很长时间，带权周转时间大），对 CPU 繁忙型作业有利。可能导致"护航效应"。
#### (2) 最短作业优先 (SJF, Shortest Job First)
* **思想**： #SJF  追求最少的平均等待时间、最少的平均周转时间、最少平均带权周转时间。
* **规则**：最短的作业/进程优先得到服务（"最短"指要求服务时间最短）。
    * 每次调度时选择当前已到达且运行时间最短的作业/进程。
* **方式**：即可用于作业调度，也可用于进程调度（短进程优先 SPF）。默认**非抢占式**。
* **抢占式版本**：**最短剩余时间优先算法 (SRTN, Shortest Remaining Time Next)**。 #SRTN
    *   每当有进程加入就绪队列或进程完成时就需要调度。如果新到达进程的**剩余运行时间**比当前运行进程更短，则立即抢占 CPU。
* **优点**：在所有进程都几乎同时到达时，平均等待时间、平均周转时间最少。
* **缺点**：
    *   对短作业有利，**长作业不利，可能产生饥饿现象 (2011, 2014)**。
    *   必须**预知**作业的精确运行时间，这在实际中很难做到。
    *   不适合交互式系统，未考虑任务的紧迫程度。
#### (3) 时间片轮转调度算法 (RR, Round-Robin)
* **规则**： #RR  按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若未在一个时间片内执行完，则剥夺CPU，将进程重新放到就绪队列队尾重新排队。
* **方式**：抢占式。由时钟装置发出时钟中断通知CPU时间片已到。
* **优点**：公平；响应快，不会**饥饿(2014)**，适用于分时操作系统。
* **缺点**：高频率的进程切换带来一定**开销**；不区分任务紧急程度。
* **时间片大小影响(2017)**：
    * `时间片太大`：算法退化为FCFS，增大进程响应时间。
    * `时间片很小`：CPU频繁切换，**开销增大**，真正用于运行用户进程的时间减少。

#### (4) 优先级调度算法 (Priority Scheduling)
* **规则**： #优先级调度 调度时选择优先级最高的作业/进程。
* **方式**：**抢占式、非抢占式**都有。抢占式版本会在就绪队列状态变化时（如新进程到达、进程完成、I/O 结束）检查是否需要抢占当前运行进程。
* **优点**：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活调整偏好。
* **缺点**：若源源不断有高优先级进程到来，则可能导致**饥饿现象**。
* **补充**：
    * `优先级`：
        *   **静态优先级**：在创建进程时确定，之后不再改变。
        *   **动态优先级**：在进程运行过程中，优先级可以动态调整。
    *   **优先级设置原则**：
        *   系统进程优先级高于用户进程；前台进程优先级高于后台进程。
        *   操作系统更偏好 **I/O 密集型进程**（通过适当提升其优先级，**2013**），以提高系统资源利用率。
    * 操作系统更偏好I/O型进程（适当提升优先级）。
    * `动态优先级调整时机`：
        *   进程在就绪队列中等待时间长则**提升**优先级（**老化机制**，防止饥饿）。
        *   进程占用 CPU 运行时间长则**降低**优先级。
        *   进程频繁进行 I/O 操作则**提升**优先级。
    *   **降低优先级的合理时机**：进程时间片用完 (2010)。
#### (5) 最高响应比优先 (HRRN, Highest Response Ratio Next)
* **思想**： #HRRN 综合考虑作业/进程的**等待时间**和**要求服务的时间**。
* **规则**：每次调度时先计算各个作业/进程的**响应比**，选择响应比最高的作业/进程为其服务。
    * `响应比 = (等待时间 + 要求服务时间) / 要求服务时间`
* **方式**：非抢占式的算法。只有当前运行的作业/进程主动放弃处理机时才需调度。
* **优点**：
    * 综合考虑等待时间和运行时间。
    * 等待时间相同，要求服务时间短的优先（SJF优点）。
    * 要求服务时间相同，等待时间长的优先（FCFS优点）。
    * 长作业来说，随着等待时间越长，响应比也会越来越大，从而**避免了长作业饥饿(2011)** 的问题。

#### (6) 多级反馈队列调度算法 (MLFQ, Multilevel Feedback Queue)
* **思想**： #MLFQ  对其他调度算法的折中权衡。
* **规则**：
*   **规则**：
    *   设置**多级就绪队列**，各级队列**优先级从高到低，时间片从小到大**。
    *   新创建的进程先进入**第 1 级（最高优先级）队列**，按 FCFS 原则等待一个时间片。
    *   若进程用完时间片但未结束，则**降级**，进入下一级队列队尾。
    *   如果进程已在最下级队列，则在最下级队列按 FCFS（或 RR）原则继续排队。
    *   **调度优先级**：只有当更高级的队列都为空时，系统才会调度低一级队列中的进程。
    *   **抢占**：在较低级队列中的进程运行过程中，若更上级队列（如第 1 级）中进入新进程，则新进程立即抢占 CPU，原运行进程放回其原队列的队尾。
*   **优点**：
    *   **兼顾多种类型进程**：对 I/O 密集型进程和交互式进程有较好的响应时间（高优先级队列的小时间片）。
    *   **短进程能快速完成**（SJF 优点）；长进程也能最终得到执行（FCFS 优点，且可避免饥饿）。
    *   **不必事先估计进程运行时间**（避免用户作假）。
    *   可灵活调整对各类进程的偏好。
*   **缺点**：实现复杂，参数（队列数量、时间片大小、优先级、迁移条件）调整困难，可能设计不当仍导致饥饿。
*   **设计考虑因素 (2020)**：需要考虑就绪队列的数量、就绪队列的优先级、各就绪队列的调度算法、进程在就绪队列间的迁移条件。

---

### 5. 上下文及其切换机制
#### (1) 上下文切换概念
* **定义**：切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态，进程的运行环境产生了实质性的变化。
* **上下文 (Context)**：某一时刻CPU寄存器和程序计数器的内容。
* **机制**：进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。

#### (2) 上下文切换的流程
1.  暂停当前进程的执行。
2.  **保存 CPU 上下文**：将当前进程的 CPU 所有寄存器（PC、PSW、通用寄存器等）内容保存到其 PCB 中。
3.  **更新旧进程的 PCB 信息**：修改旧进程的状态（如从运行态变为就绪态或阻塞态）。
4.  将旧进程的 PCB 移入相应的队列（如就绪队列队尾或阻塞队列）。
5.  选择（调度）另一个进程执行，并更新其 PCB 信息（如状态变为运行态）。
6.  **恢复新进程的 CPU 上下文**：从新进程的 PCB 中加载其 CPU 寄存器内容。
7.  跳转到新进程 PCB 中的程序计数器所指向的位置执行。

#### (3) 上下文切换的消耗
*   上下文切换通常是**计算密集型的操作**，它需要消耗 CPU 时间来保存和恢复寄存器、更新内存管理信息（如刷新 TLB）。
*   频繁的上下文切换会导致系统开销增大，降低 CPU 的有效利用率。
*   有些处理器提供多个寄存器组，上下文切换只需简单改变当前寄存器组的指针，可以减少开销。

#### (4) 上下文切换与模式切换
* **模式切换**（`2022`）： #模式切换 用户态和内核态之间的切换。
    * `特点`：CPU逻辑上可能在执行**同一进程**。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后回到用户态刚被中断的进程运行。
    * `区别`：模式切换**不是上下文切换**，因为它没有改变当前的进程，只是改变了CPU的特权级别。
* **上下文切换**： #上下文切换 通常**只能发生在内核态**，并且是多任务操作系统中的一个必需的特性。它**必然涉及模式切换**（如果两个进程都在用户态，切换时也必须先进入内核态才能保存和恢复上下文）。

---
## 02-3 同步与互斥
### 1. 同步与互斥的基本概念
1. **临界资源(Critical Resource)**
    * 一次只能被一个进程访问的资源，如打印机、共享变量、共享文件等。
    *   **临界区 (Critical Section)**： #临界区 进程中**访问临界资源的那段代码**。为了保证互斥，进程在进入临界区之前必须获得"锁"，退出时释放"锁"。
    * **临界区构成**：
        1. `进入区`：检查是否可进入临界区，若可进入，需要"上锁"。
        2. `临界区`： 访问临界资源的那段代码。
        3. `退出区`：负责解除正在访问临界资源的标志，"解锁"。
        4. `剩余区`：其余代码部分。
2. 进程同步（直接制约关系）
    *   **定义**：为完成某种任务而建立的两个或多个进程，它们之间因需要**协调工作次序**而产生的**直接制约关系**。进程在某些位置上需要等待、传递信息。
    *   **原因**：并发性带来的异步性，有时需要通过进程同步来解决这种**执行顺序不确定**的问题。
    *   **特点**：进程之间需要**相互配合**地完成工作，各进程的工作推进需要遵循一定的**先后顺序**。例如，"消费者"必须在"生产者"生产出产品后才能消费。
3. 进程互斥（间接制约关系）
*   **定义**：多个进程因**竞争共享的临界资源**而产生的**间接制约关系**。它要求对临界资源的访问必须**互斥进行**，即在任何一个时刻，只能有一个进程访问该资源。

*   **实现互斥的遵循原则 (考点: `2020-I, II, III, IV`)**：
    *   **互斥性 (Mutual Exclusion)**：**【必须遵循】** 任何时候，只允许一个进程进入临界区。 (对应 `2020-I`)
    *   **空闲让进 (Progress)**：**【必须遵循】** 当临界区空闲时，应允许一个请求进入临界区的进程立即进入。
    *   **有限等待 (Bounded Waiting)**：**【必须遵循】** 任何进程在请求进入临界区后，必须在**有限时间**内得到允许，不能无限期地等待（防止饥饿）。 (对应 `2020-III`)
    *   **让权等待 (Yield Waiting)**：**【理想准则，非必须】** 当进程不能进入临界区时，应立即释放 CPU，进入阻塞态，而不是忙等。这是一个很好的原则，可以避免 CPU 资源的浪费。 (对应 `2020-IV`)
### 2. 实现临界区互斥的基本方法
#### (1) 软件实现方法
这些方法主要通过设置标志变量或轮流机制来协调进程对临界区的访问，但往往存在效率、饥饿或死锁等问题。
1. **单标志法(轮转法)**：
    * `思想`：使用一个 `turn` 标志变量，指示哪个进程可以进入临界区。只有 `turn == 进程ID` 的进程才能进入。
    * `缺点`：**违背"空闲让进"原则**。进程必须严格交替进入临界区，即使临界区空闲，如果不是轮到自己的 `turn`，也无法进入，效率低。可能出现"死等"（如 P0 运行完就终止，P1 永远等不到 `turn=1`）。
2. **双标志先检查法** (先检查后上锁)(不满足互斥，**可能发生竞态条件**)：
    * `思想`：设置布尔数组 `flag[n]` 标记进程意愿。每个进程先检查对方意愿，没有则设置自己意愿为 `true`，再进入。
    * `优点`：不用交替进入，可连续使用。
    * `缺点`：**可能同时进入临界区（违背"忙则等待"原则）**。因为"检查"和"设置自己意愿"这两个动作不是原子操作，可能发生**竞态条件**。例如，P0 检查 P1 没意愿，P1 检查 P0 也没意愿，然后 P0 设自己意愿为真，P1 也设自己意愿为真，最后两者都进入临界区。
3. **双标志后检查法** (先上锁后检查)(可能发生死锁)：
    * `思想`：先将自己的标志 `flag[i]` 设为 `TRUE`，表明自己想进入，再检测对方标志 `flag[j]`。
    * `缺点`：解决了"忙则等待"问题，但**可能产生死锁**（例如 P0 设 `flag[0]=TRUE`，P1 设 `flag[1]=TRUE`，然后 P0 检查 P1，P1 检查 P0，两者都发现对方"忙碌"，于是都无限等待）。因此，也**违背了"空闲让进"和"有限等待"原则**，可能导致饥饿。
4. **Peterson算法**(`2010-B`)：
    * `思想`：结合双标志 (`flag[]` 数组表示意愿) 和 `turn` 变量（表示让步）。进程先设置自身标志表示意愿，再设置 `turn` 变量表示让步，然后通过 `while` 循环同时检测对方标志和 `turn` 变量。
    *   **优点**：**解决了进程互斥问题 (2010-B)**，严格遵循了**互斥性、空闲让进、有限等待**这三个原则。
    *   **缺点**：**不满足"让权等待"原则 (2010-B)**。若进程无法进入临界区，会卡在 `while` 循环中进行**忙等 (Busy Waiting)**，浪费 CPU 资源

#### (2) 硬件实现方法
硬件实现方法利用特殊的 CPU 指令，保证了检查和设置操作的原子性。
1. **中断屏蔽方法**：
    * `优点`：简单高效。使用"开关中断"指令实现，禁止一切中断发生，从而不引发调度和进程切换。
    * `缺点`：
        *   只适用于**操作系统内核进程**，因为"开关中断"指令是**特权指令**，只能在内核态运行。
        *   只适用于**单处理机**系统。在多处理机系统中，关中断只能禁止当前 CPU 的中断，其他 CPU 仍然可以并发执行。
        *   关中断时间过长，会影响系统对紧急事件的响应效率，限制处理器交叉执行程序的能力。
2. **TestAndSet (TS指令/TSL指令)**( `2016-B, C, D`, `2018-D`： #TestAndSet
    * `过程`：TS管理临界区时，为每个临界资源设置一个共享布尔变量`lock`,`true`表示正在被占用，`false`表示空闲，初始值为`false`。进程进入临界区之前，先用TS检查`lock`值
    ```c
        while TestAnddSet(&lock);  //加锁并检查
        进程的临界区代码段
        lock=false;  //解锁
    ```
    * 由硬件逻辑直接实现，不可中断。它是一个**原子操作**，一次性完成"检查"(`Test`) 和"上锁"(`Set`) 两个动作。
    * `优点`：实现简单，适用于**多处理机环境**（硬件原子性保证）。
    * `缺点`：**不满足"让权等待"原则 (2016-C)**，存在**忙等 (2016-B)**，会浪费 CPU 资源；可能导致饥饿。
3. **Swap指令 (XCHG指令)**( `2018-C`)： #Swap
    * `过程`：交换两个字节的内容
    ```c
        Swap(boolean *a, boolean *b)
        boolean tempt=*a;
        *a=*b;
        *b=tempt;
    ```
    * 由硬件逻辑直接实现，不可中断。通过**交换**全局的 `lock` 变量（共享的互斥标志）和进程局部的 `key` 变量（私有的互斥标志）的值来实现互斥。
    * `优点`：适用于任意数目进程、单处理机或多处理机；简单，容易验证；支持进程内有多个临界区。
    * `缺点`：**不满足"让权等待"**，存在忙等；可能导致饥饿。

### 3. 互斥锁 (Mutex Lock)
*   **概念**： #互斥锁 一种同步机制，每个进程在进入临界区时应**获得锁**；在退出临界区时**释放锁**。它通常是操作系统提供的、基于硬件原子指令（如 `TestAndSet` 或 `Swap`）或禁用中断实现的，但封装了忙等或阻塞机制。
*   **操作**：
    *   `acquire()` / `lock()`：尝试获得锁。若锁当前可用，则获得锁并继续执行。若锁不可用，则根据实现方式**阻塞**或**忙等**。
    *   `release()` / `unlock()`：释放锁。
*   **特点**：
    *   互斥锁的主要缺点（特别是基于忙等的简单实现）是**忙等**（即违反让权等待原则）。
    *   **旋锁 (Spinlock)**：是一种特殊的互斥锁，其在锁不可用时会**连续忙等**，直到锁可用（通常基于 TSL、SWAP 指令实现）。适用于临界区很短，且忙等时间小于切换开销的多处理器系统。
    *   互斥锁广泛用于多处理器系统，以保护共享数据。

### 4. 信号量 (Semaphore) ( #重点 `2010`, `2011`, `2018`, `2020`)
#### (1) 信号量机制
*   **概念**：用户进程通过一对**原语**来对信号量进行操作。信号量是一个变量，表示系统中某种资源的数量（或某种事件的发生次数）。
*   **原语**：
    *   `wait(S)` / **P 操作 (proberen)**：尝试申请资源。
    *   `signal(S)` / **V 操作 (verhogen)**：释放资源。
*   **原语特性**：执行只能**一气呵成**，不可被中断，由关中断/开中断指令或硬件原子指令实现。
#### (2) 整型信号量
*   **概念**：用一个简单的整数型变量 `S` 作为信号量。
*   **操作**：
    *   `wait(S)`：`while (S <= 0); S--;` （循环检查资源是否够用，若够用则 `S--`）。
    *   `signal(S)`：`S++;`
*   **缺陷**：**不满足"让权等待"原则**，当资源不足时，进程会陷入 `while` 循环进行**忙等**，浪费 CPU 资源。
#### (3) 记录型信号量 ( #高频考点 `2010`)
*   **概念**：用记录型数据结构表示的信号量，解决了整型信号量的忙等问题。它是操作系统中最常用的信号量实现。
*   **结构**：由两部分组成：
    *   `S.value`：一个整数，表示某种资源的**可用数量**。
    *   `S.L`：一个队列，指向**等待该资源的进程队列**。
*   **P 操作 (wait(S))**：
    1.  `S.value--` (资源数减 1)。
    2.  若 `S.value < 0`，表示资源已分配完毕，当前进程需要等待。进程会调用 `block` 原语进行**自我阻塞**，主动放弃处理机，并插入 `S.L` 等待队列（从运行态 → 阻塞态）。
    *   **特点**：遵循"让权等待"原则，不会出现忙等现象。
*   **V 操作 (signal(S))**：
    1.  `S.value++` (资源数加 1)。
    2.  若 `S.value <= 0`，表示依然有进程在等待该类资源（即 `S.value` 的负值表示等待进程数）。系统会调用 `wakeup` 原语唤醒 `S.L` 等待队列中的**第一个**进程（被唤醒进程从阻塞态 → 就绪态）。
*   **功能**：可用记录型信号量实现系统资源的"申请"和"释放"，从而实现进程互斥和进程同步。
*   **推断**：**能够根据信号量的值和队列状态，推断资源的可用个数和等待进程数 (2010-C)**。
    *   当 `S.value > 0` 时，表示有 `S.value` 个资源可用，等待进程数是 0。
    *   当 `S.value <= 0` 时，表示没有资源可用，且有 `|S.value|` 个进程在等待。

#### (4) 用信号量机制实现进程互斥、同步、前驱关系
*   **基本原则**：**一个信号量通常对应一种资源或一个事件**。
* **实现进程互斥**：
    * `过程`：
        1. 分析并发进程的关键活动，划定**临界区**。
        2. 设置互斥信号量 `mutex`，**初值为 1**。
        3. 在进入区执行 `P(mutex)` (申请资源)。
        4. 在退出区执行 `V(mutex)` (释放资源)。
    * `注意`：对不同的临界资源需设置不同的互斥信号量；P、V操作必须成对出现。
* **实现进程同步 (前V后P)**：
    * `过程`：
        1.  分析需要实现"同步关系"的地方（"一前一后"执行的两个操作）。
        2.  设置同步信号量 `S`，**初始为 0**（表示事件尚未发生，或资源尚未产生）。
        3.  在"前操作"**之后**执行 `V(S)` (提供某种资源/事件，使 `S` 值增加)。
        4.  在"后操作"**之前**执行 `P(S)` (等待某种资源/事件，消耗 `S` 值)。
* **实现进程的前驱关系**：
    *   前驱关系是更复杂的同步关系。为每一对前驱关系（如 A 必须在 B 之前完成）各设置一个同步信号量，并初始化为 0。
    *   在"前操作"**之后**对相应的同步信号量执行 `V` 操作。
    *   在"后操作"**之前**对相应的同步信号量执行 `P` 操作。

### 5. 经典同步问题 ( #重点 `2011`, `2018`, `2020`)

#### (1) 生产者-消费者问题

* **场景**：生产者生产产品放入共享缓冲区，消费者从缓冲区取出产品。
* **要求**：
    * 缓冲区未满时生产者才能放入，否则等待。
    * 缓冲区不空时消费者才能取出，否则等待。
    * 缓冲区是临界资源，各进程必须互斥地访问。
* **实现**：

```c
    semaphore mutex = 1; // 互斥信号量，实现对缓冲区的互斥访问
    semaphore empty = n; // 同步信号量，表示空闲缓冲区数量 (n为缓冲区总容量)
    semaphore full = 0;  // 同步信号量，表示产品数量 (非空缓冲区数量)

    // 生产者进程
    void producer() {
        while (1) {
            // 生产一个产品;
            P(empty);  // 消耗一个空闲缓冲区
            P(mutex);  // 互斥访问缓冲区
            // 把产品放入缓冲区; (临界区)
            V(mutex);  // 释放互斥
            V(full);   // 增加一个产品
        }
    }

    // 消费者进程
    void consumer() {
        while (1) {
            P(full);   // 消耗一个产品
            P(mutex);  // 互斥访问缓冲区
            // 从缓冲区取出一个产品; (临界区)
            V(mutex);  // 释放互斥
            V(empty);  // 增加一个空闲缓冲区
            // 使用产品;
        }
    }
 ```

*   **易错点与死锁预防**：
    *   **P 操作顺序**：**实现互斥的 P 操作（`P(mutex)`）一定要在实现同步的 P 操作（`P(empty)` 或 `P(full)`）**之后**。
        *   若生产者先 `P(mutex)` 再 `P(empty)`，当缓冲区为空时，生产者会占用 `mutex` 后阻塞在 `P(empty)`，导致消费者无法进入临界区 `V(mutex)`，从而造成死锁。
    *   **V 操作顺序**：`V` 操作不会导致进程阻塞，因此两个 `V` 操作的顺序可以交换（但习惯上先 `V(mutex)` 再 `V(empty/full)`）。
*   **多生产者-多消费者问题**： #多生产者多消费者
    *   **关键**：理清复杂的同步关系，从 **"事件"** 的角度来分析，而非单个进程的行为。将抽象的"进程行为的前后关系"抽象为一对"事件的前后关系"来解决。

#### (2) 读者-写者问题 ( #重点)
**场景**：多个读者进程和多个写者进程共享一个文件。
*   **要求**：
    *   **读者-读者**：允许多个读者同时对文件执行读操作（不互斥）。
    *   **写者-写者**：只允许一个写者往文件中写信息（互斥）。
    *   **读者-写者**：写者在写文件时，不允许其他读者或写者工作（互斥）。
    *   写者执行写操作前，应让所有已有的读者和写者都退出。
*   **关系分析**：
    *   `写进程` 与 `写进程`：**互斥**。
    *   `写进程` 与 `读进程`：**互斥**。
    *   `读进程` 与 `读进程`：**不互斥**。
*   **实现 (读优先算法)**：

```c
    semaphore rw = 1;         // 用于实现对共享文件的互斥访问 (读写锁)
    int count = 0;            // 记录当前有几个读进程在访问文件
    semaphore mutex_count = 1; // 用于保证对count变量的互斥访问

    // 写者进程
    void writer() {
        while (1) {
            P(rw);       // 写之前“加锁”，等待所有读写完成
            // 写文件… (临界区)
            V(rw);       // 写完了“解锁”
        }
    }

    // 读者进程
    void reader() {
        while (1) {
            P(mutex_count);   // 各读进程互斥访问count
            count++;          // 读进程数+1
            if (count == 1) { // 如果是第一个读进程
                P(rw);        // 读之前“加锁”，阻止写者进入
            }
            V(mutex_count);   // 释放对count的互斥访问

            // 读文件… (允许多个读者同时进行)

            P(mutex_count);   // 各读进程互斥访问count
            count--;          // 读进程数-1
            if (count == 0) { // 如果是最后一个读进程
                V(rw);        // 读完了“解锁”，允许写者进入
            }
            V(mutex_count);   // 释放对count的互斥访问
        }
    }
 ```

*   **潜在问题**：读优先算法可能导致**写进程饥饿**。如果不断有新的读者到来，`count` 始终不为 0，`rw` 信号量将一直被读者占用，写者永远无法获得 `rw` 从而无法写入。
*   **解决饥饿 (写优先 / 公平法)**：引入额外的信号量来控制读者和写者的调度，如 `semaphore w = 1;` 来保证读者和写者能公平地获取访问权。
    *   **写者**：`P(w); P(rw); 写文件; V(rw); V(w);` （确保写者在等待 `rw` 时不会被其他读者绕过）
    *   **读者**：`P(w); P(mutex_count); … V(mutex_count); V(w); 读文件; P(mutex_count); … V(mutex_count);`
    *   **结论**：这种做法可以避免写者饥饿，使读写操作相对公平（接近 FCFS），但不是真正意义上的"写优先"。
* **知识回顾**：核心思想在于设置**计数器 `count`** 来记录读进程数，用其判断第一个/最后一个读进程。对 `count` 变量的检查和赋值需要用互斥信号量保护。

#### (3) 哲学家进餐问题 ( #重点)
*   **场景**：N 个哲学家围坐圆桌，每两个哲学家之间摆一根筷子。哲学家只有同时拿到左右两根筷子才能进餐。
*   **本质**：多个进程需要**同时持有多个临界资源**（筷子），具有**死锁隐患**（满足死锁的请求并保持、环路等待条件）。
* **典型死锁代码**：

```c
    semaphore chopstick[5]={1,1,1,1,1}; // 5根筷子
    void Pi (){ // i号哲学家的进程
        while(1){
            // P(思考);
            P(chopstick[i]);       // 拿左手筷子
            P(chopstick[(i+1)%5]); // 拿右手筷子
            // 吃饭…
            V(chopstick[i]);       // 放左手筷子
            V(chopstick[(i+1)%5]); // 放右手筷子
            // V(思考);
        }
    }
```

    * `问题`：如果5个哲学家并发地拿起了自己左手边的筷子，则都会阻塞等待右边筷子，发生死锁。
* **解决死锁的三种思路**：
    1. **限制最多允许并发进餐的哲学家数量**：
        * `方案`：最多允许 N-1 个哲学家同时进餐（如5个哲学家只允许4个同时拿筷子）。
        * `实现`：引入一个全局互斥信号量 `max_philosophers = N-1`，每个哲学家在拿筷子前先 `P(max_philosophers)`，吃完后 `V(max_philosophers)`。
        * `优点`：简单有效，可保证至少有一个哲学家能拿到两根筷子。
        * `缺点`：并发度略有降低。
    2. **规定申请资源的顺序**：
        * `方案`：要求奇数号哲学家先拿左筷子再拿右筷子，偶数号哲学家先拿右筷子再拿左筷子。
        * `优点`：避免了相邻哲学家同时拿起第一只筷子，打破了环路等待。
        * `缺点`：通用性差，题目变种后难套用。
    3. **仅当所有筷子都可用时才允许哲学家拿筷子 (一次性获取所有资源)**：
        * `方案`：哲学家只有当左右两边的筷子都可用时，才一次性全部拿起。
        * `实现`：引入一个全局互斥信号量 `mutex`，保护检查和拿筷子的原子性。

        ```c
        semaphore chopstick[5] = {1,1,1,1,1};
        semaphore mutex = 1; // 互斥地检查和取筷子

        void Pi (){ // i号哲学家进程
            while(1){
                // P(思考);
                P(mutex); // 互斥地进入取筷子的临界区
                // 检查chopstick[i] 和 chopstick[(i+1)%5] 是否都为1 (隐含在Wait中)
                P(chopstick[i]);       // 拿左手筷子
                P(chopstick[(i+1)%5]); // 拿右手筷子
                V(mutex); // 释放互斥，其他哲学家可以尝试检查和取筷子

                // 吃饭…

                V(chopstick[i]);       // 放左手筷子
                V(chopstick[(i+1)%5]); // 放右手筷子
                // V(思考);
            }
        }
        ```

        * `优点`：确保了在拿起筷子时不会被阻塞，避免了请求并保持。并发度相对较高。
        * `缺点`：`P(mutex)` 使得拿筷子行为串行化，在 `mutex` 保护期间，即使其他哲学家所需的筷子空闲，也无法立即获取。这种做法更准确地说，是让"拿筷子"这件事互斥执行。
#### (4) 吸烟者问题
* **场景**：一个供应者，三个抽烟者。供应者每次放两种材料到桌上，拥有第三种材料的抽烟者才能抽。目标是轮流抽烟。
* **本质**：多产品单生产者-多消费者问题。
* **核心**：通过一个计数器 `int i` 实现供应者轮流放置材料，并通过不同的 `offerX` 信号量与抽烟者同步。

### 6. 管程
大量PV操作易导致死锁，引入管程（进程同步工具）
*   **易用性**：将复杂的同步逻辑（互斥、条件同步）封装起来，程序员只需关注业务逻辑，无需处理低级同步原语。
*   **安全性**：自动保证互斥，减少了因编程错误导致的死锁和数据不一致问题。
*   **模块化**：同步代码集中在管程内部，便于管理和维护。

一、管程是啥？（定义与组成）
*   **官方定义**：管程是操作系统提供的一种**高级进程同步工具**。它把共享资源的数据结构和所有操作这些数据的方法（过程）封装在一起，确保对共享资源的所有访问都得到统一管理。
*   **四大组成部分**：
    1.  **管程内部的共享数据结构说明**：比如酒店前台的"入住信息系统"（记录房间空闲情况）。
    2.  **对该数据结构进行操作的一组过程（或函数）**：比如"办理入住 (take\_away)"和"办理退房 (give\_back)"的服务员。
    3.  **局部于管程内部的共享数据**：就是那些只有管程内部能访问的变量。
    4.  **共享数据设置初始值的语句**：比如酒店刚开业时，"初始有 5 个空房间"。

**二、管程的 (核心特性)**
1.  **数据封装与保护（信息隐藏）**
    *   **特性**：管程内的共享数据结构**只能**被管程内部的过程访问。外部进程想用？抱歉，你得乖乖调用管程提供的方法（比如 `take_away()`）才能进去操作。
    *   **好处**：这就像你不能直接跑去修改酒店的入住系统，必须通过前台服务员。大大减少了数据被非法或错误操作的可能性，安全！
    *   **联系 OOP**：熟悉面向对象编程的老登，是不是觉得管程就像个"类 (class)"？封装性杠杠的！

2.  **自动互斥访问（天生互斥）**
    *   **特性**：**任何时候，管程内只允许一个进程执行**。如果有多个进程想同时进入管程（比如都想办理业务），管程会自动让它们排队，一个接一个地来。
    *   **好处**：作为程序员，**你再也不用自己写复杂的 P/V 操作来保证互斥了！** 管程自己就帮你实现了临界区的互斥保护。这不仅省心，还大大降低了因为同步操作不当而导致死锁的风险。简直是"懒人福音"！

**三、条件变量 (Condition Variable)**
*   **作用**：它像管程内部的一个**"休息区"或"等待室"**，专门用来协调进程间的条件同步。当进程因某个条件不满足而无法继续时，它就去休息区等待。
*   **两个核心操作**：
    1.  `x.wait()`：
        *   **动作**：当进程发现条件 `x` 不满足时，调用 `x.wait()`。
        *   **结果**：
            1.  该进程**立即释放它当前持有的管程锁**（把前台让出来给别人用）。
            2.  该进程**阻塞**，并被加入到条件变量 `x` 对应的等待队列中。
        *   **老登提醒**：释放管程锁是关键！否则，你占着茅坑不拉屎，别人怎么改变条件呢？
    2.  `x.signal()`：
        *   **动作**：当另一个进程改变了条件（比如释放了资源，条件 `x` 可能满足了），它会调用 `x.signal()`。
        *   **结果**：从条件变量 `x` 的等待队列中**唤醒一个**（如果有的话）因条件 `x` 而阻塞的进程。被唤醒的进程将有机会重新获取管程锁并继续执行。
*   **条件变量 vs. 信号量 (Semaphore)**：
    *   **相似点**：两者都能实现进程的阻塞和唤醒。
    *   **不同点**：
        *   **条件变量"没有值"**：它仅仅提供"排队等待"和"唤醒"的功能，不记录资源的数量。
        *   **信号量"有值"**：信号量的值直接反映了可用资源的数量，或者作为一个计数器。管程中，资源的数量由内部的共享数据结构来记录。

---

## 02-4 死锁
#重点

### 1. 死锁的概念

#### (1) 死锁定义
*   **定义**：并发环境下，多个进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象。若无外力干涉，这些进程都将无法向前推进。
*   **特点**：至少两个或两个以上的进程同时发生死锁，死锁进程一定处于**阻塞态**。
    *   **【2019 统考真题 Q41 考点】**：当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态。

#### (2) 进程死锁、饥饿、死循环的区别
*   **死锁**：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进。**一定处于阻塞态**。
*   **饥饿**：某进程长期得不到想要的资源，无法向前推进。可能只有一个进程发生饥饿。可能是阻塞态，也可能是就绪态。
*   **死循环**：某进程执行过程中一直跳不出某个循环。通常是程序逻辑bug或程序员故意设计。
*   **共同点**：都导致进程无法顺利向前推进。
*   **管理归属**：死锁和饥饿是**管理者（操作系统）的问题**；死循环是**被管理者（应用程序）的问题**。

#### (3) 死锁必要条件 (同时满足才会发生死锁)
1.  **互斥条件 (Mutual Exclusion)**：
    *   只有对必须互斥使用的资源（不可共享）的争抢才会导致死锁。可共享资源不会导致死锁。
2.  **不剥夺条件 (No Preemption)**：
    *   进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
3.  **请求并保持条件 (Hold and Wait)**：
    *   进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
4.  **环路等待条件 (Circular Wait)**：
    *   存在一种进程-资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求。
    *   发生死锁时一定有循环等待；但发生循环等待时未必死锁（例如资源是多实例的）。
*   **总结**：四个条件**缺一不可**。
*   **【2016 统考真题 】死锁进程数至少是**

#### (4) 死锁原因
1.  **对不可剥夺资源的不合理分配**：各进程对不可剥夺资源竞争可能引起死锁。对可剥夺的资源（如CPU）竞争不会引起死锁。
2.  **进程推进顺序非法**：请求和释放资源的顺序不当，导致死锁。
3.  **信号量使用不当**：如P操作顺序错误。

#### (5) 死锁的处理逻辑
*   **死锁预防 (Prevention)**： #死锁预防 破坏死锁产生的四个必要条件。在死锁发生之前，对系统加的限制条件通常很严格，对系统并发性有副作用。
*   **死锁避免 (Avoidance)**： #死锁避免 避免系统进入不安全状态（如银行家算法）。对系统所加的限制条件相对宽松。
*   **死锁检测和解除 (Detection and Recovery)**： #死锁检测解除 允许死锁发生，系统负责检测出死锁并解除。
*   **【2015 统考真题 Q38 考点】死锁避免与死锁检测的比较**
    *   **答案分析**：
        *   I. S1（避免）通过安全性检查，限制了哪些请求能被满足，间接上对"有效的"申请顺序有影响；S2（检测）不限制。 (正确)
        *   II. S1（银行家算法）需要进程的最大资源需求量（Max），S2（检测）只需要当前分配和剩余需求。 (正确)
        *   III. S1 拒绝不安全请求，S2 允许发生死锁后解除。 (正确)
    *   **正确答案：D. I、 II、 III**
*   **【2019 统考真题 Q41 考点】死锁处理方法概览**
    *   I. 剥夺资源是解除死锁的一种方式。 (正确)
    *   II. 死锁预防旨在破坏必要条件，从根源上阻止死锁发生。 (正确)
    *   III. 银行家算法是死锁避免，判断系统是否处于安全状态，而非是否已死锁。 (错误)
    *   IV. 死锁至少涉及两个进程，且它们都处于阻塞态。 (正确)

### 2. 死锁预防（静态策略）
*   **目的**：破坏死锁产生的四个必要条件之一。
1.  **破坏互斥条件**：
    *   `方法`：某些资源可共享（如只读文件）。
    *   `解决办法`：**SPOOLing技术**把独占设备在逻辑上改造成共享设备。
    *   `缺点`：多数临界资源无法破坏互斥条件。
2.  **破坏不剥夺条件**：
    *   `方法`：允许OS剥夺已分配的资源。当某个进程需要的资源被其他进程所占有，由OS协助，将想要资源强行剥夺。
    *   `解决办法`：当进程申请新的资源得不到满足时，它必须立即释放自己已占有的所有资源。
    *   `缺点`：复杂；可能造成前一阶段工作失效（只适用于易保存和恢复状态的资源）；申请和释放资源增加开销，降低吞吐量；导致某个进程饥饿。
3.  **破坏请求并保持条件**：
    *   `方法`：**一次性申请完所有资源**（静态分配）。进程在运行前一次申请完它所需要的全部资源，资源未满足前不投入运行。一旦投入运行后，这些资源就一直归它所有。
    *   `缺点`：资源利用率低；导致某些进程饥饿。
4.  **破坏环路等待条件**：
    *   `方法`：**顺序资源分配法**。给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。
    *   `原理`：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。打破了逆向请求，从而不会产生循环等待。
    *   `缺点`：不方便增加新设备；导致资源浪费；用户编程麻烦。

### 3. 死锁避免（动态策略）
*   **目的**：在资源分配时，动态检查系统状态，确保系统始终处于安全状态。

1.  **安全序列 (Safe Sequence)**： #安全序列
    *   `定义`：如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态。安全序列可能有多个。
    *   `不安全状态`：如果分配了资源，系统中找不出任何一个安全序列，系统就进入了不安全状态。
    *   `联系`：
        *   如果处于安全状态，就一定不会发生死锁。
        *   如果进入不安全状态，可能会导致死锁，但未必死锁。
        *   系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。
    *   **【2009 统考真题 Q33 考点】可能发生死锁的进程数最小值**
    *   **【2014 统考真题 Q37 考点】确保不发生死锁的设备数最小值**
    *   **【2021 统考真题 Q43 考点】通用公式计算确保不发生死锁的资源总数**

2.  **银行家算法 (Banker's Algorithm)**： #银行家算法
    *   `数据结构`：
        *   `Available (m维向量)`：表示系统还有多少可用资源。
        *   `Max (n*m矩阵)`：表示各进程对资源的最大需求数。
        *   `Allocation (n*m矩阵)`：表示已给各进程分配了多少资源。
        *   `Need (n*m矩阵)`：`Max - Allocation`，表示各进程最多还需要多少资源。
        *   `Request (m维向量)`：进程此次申请的各种资源数。
    *   `银行家算法流程`：
        1.  检查此次申请是否超过了之前声明的最大需求数（Request <= Need）。
        2.  检查此时系统剩余的可用资源是否还能满足这次请求（Request <= Available）。
        3.  试探性分配（更改 `Available`, `Allocation`, `Need`）。
        4.  用**安全性算法**检查此次分配是否会导致系统进入不安全状态。若安全，则分配；否则，回滚并拒绝分配。
    *   `安全性算法步骤`：
        1.  初始时安全序列为空。初始化 `Work = Available`，`Finish[i] = false` 对所有 `i`。
        2.  查找满足 `Finish[i] = false` 且 `Need[i] <= Work` 的进程 `Pi`。
        3.  若找到：`Work = Work + Allocation[i]`，`Finish[i] = true`，重复步骤2。
        4.  若未找到：检查所有 `Finish[i]` 是否都为 `true`。若是，则系统处于安全状态。
    *   **【2013 统考真题 】当系统处于安全状态时， 系统中一定无死锁进程**
    *   **【2018 统考真题 Q40 考点】安全性检测结果**
        *   **不存在安全序列， 系统处于不安全状态**
    *   **【2020 统考真题 Q42 考点】多类资源安全性检测**
    *   **【2011 统考真题 Q34 考点】寻找安全序列**
    *   **【2022 统考真题 Q44 考点】计算安全序列的个数**

### 4. 死锁检测和解除（允许死锁的发生）
*   **目的**：一旦检测出死锁的发生，就应该立即解除死锁。
*   **死锁检测**：
    *   **资源分配图 (Resource Allocation Graph)**： #资源分配图
        *   `两种结点`：进程结点（圆）、资源结点（矩形，可有多实例）。
        *   `两种边`：资源请求边（进程 → 资源）、资源分配边（资源 → 进程）。
        *   `检测算法`：找出既不阻塞又不是孤点的进程 `Pi` (即其申请资源数量 <= 系统可用资源数量)，将其加入安全序列，并回收其资源。重复此过程。
        *   `死锁定理`：当且仅当某时刻系统的资源分配图**不可完全简化**时，系统死锁。
*   **死锁解除**：
    *   `资源剥夺法`：挂起（暂放外存）某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程。
        *   **【2019 统考真题 Q41 考点】**：可以通过剥夺进程资源解除死锁。
    *   `进程终止法`：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。
        *   `优点`：实现简单。
        *   `缺点`：代价可能很大。
    *   `回退法`：让一个或多个死锁进程回退到足以避免死锁的地步（回滚到安全点）。
    *   `如何决定终止或剥夺哪个进程`：考虑进程优先级、运行多长时间、多久能完成、使用了多少资源、进程类型（交互式/批处理式）等。

---
