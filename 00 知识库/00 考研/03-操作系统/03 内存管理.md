---
tags: []
---
# 03 内存管理
 #OS #计组 #存储系统 #地址转换 #分页管理 #虚拟内存
## 03-1 内存管理基础
### 1. 内存管理的基本概念
#### (1) 什么是内存
*   **内存 (Main Memory / RAM)**：主存储器。
*   **作用**：程序执行前需要先放到内存中才能被CPU处理，作为CPU与硬盘之间速度矛盾的缓冲。
*   **编址方式**：
    *   `按字节编址`：每个存储单元大小为1字节 (B)。现代计算机普遍采用。
    *   `按字编址`：若字长为16位，每个存储单元大小为1个字（16位）。（较少见于考研真题）
#### (2) 内存管理的功能
1.  **内存空间的分配与回收**：操作系统完成主存储器空间的分配和管理，让程序员摆脱存储分配的麻烦，提高编程效率。
2.  **地址转换 (Address Translation)**：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，存储管理提供地址变换功能，将**逻辑地址 (VA)** 转换成**物理地址 (PA)**。
    *   **【2011 统考真题 Q64 考点】**：地址变换机构将逻辑地址变换为物理地址是虚拟内存管理的核心功能。 #2011年 
3.  **内存扩充 (Memory Expansion)**：利用虚拟存储技术或自动覆盖技术，在逻辑上扩充内存容量，让用户看到比实际存储空间大得多的地址空间。
4.  **内存保护 (Memory Protection)**：保证各道作业在各自的存储空间内运行，互不干扰，防止越界访问。
    *   **【2009 统考真题 Q60 考点】**：分区分配内存管理方式的主要保护措施是**界地址保护**。通过上下限寄存器检查访问地址是否在合法范围内。

#### (3) 程序装入与链接
##### ① 从程序到程序运行的过程
![[03 内存管理 2025-11-12 19.41.32.excalidraw|600]]
1.  **编译 (Compile)**：
    *   由编译程序将用户源代码（高级语言）编译成若干个**目标模块文件**（机器语言）。
    *   目标模块文件中包含代码所对应的指令，指令的编址都是**逻辑地址**（或称**相对地址**，通常从0开始）。
2.  **链接 (Link)**：
    *   由链接程序将编译后形成的一组目标模块，以及所需的库函数链接在一起，形成一个完整的**装入模块**（可执行文件）。
    *   此时装入模块具有完整的**逻辑地址**。
3.  **装入 (Load)**：
    *   由装入程序将装入模块装入内存运行，并且将逻辑地址转换成物理地址。**【2011年】形成逻辑地址的阶段**

##### ② 链接的三种方式
1.  **静态链接 (Static Linking)**：
    *   `时机`：程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。
    *   `特点`：将所有模块的相对地址进行修改，统一以0开始编址，并变化外部调用符号为相对地址。
2.  **装入时动态链接 (Load-time Dynamic Linking)**：
    *   `时机`：将各目标模块装入内存时，边装入边链接。
    *   `优点`：便于修改和更新（各目标模块分开存放），便于实现对目标模块的共享。
3.  **运行时动态链接 (Run-time Dynamic Linking)**：
    *   `时机`：在程序执行中需要该目标模块时，才对它进行链接。
    *   `优点`：优点与装入时动态链接相同，且**只在真正需要时才链接**，进一步节省内存和提高启动速度。

##### ③ 装入的三种方式
1.  **绝对装入 (Absolute Loading)**：`(单道程序阶段，无操作系统)`
    *   `特点`：编译时产生绝对地址的目标代码。需要提前知道程序执行后将存放在内存哪个位置。
2.  **可重定位装入 (Relocatable Loading / 静态重定位)**：`(早期多道批处理阶段)`
    *   `特点`：装入时将逻辑地址转换为物理地址，地址变换通常在装入时一次完成。
    *   `局限`：一个作业装入内存时，必须给它分配要求的全部内存空间。作业一旦进入内存，整个运行期间不能在内存中移动，也不能再申请内存空间。
3.  **动态运行时装入 (Dynamic Run-time Loading / 动态重定位)**：`(现代操作系统)`
    *   `特点`：程序运行过程中将逻辑地址转换为物理地址，需设置**重定位寄存器**。
    *   `优势`：可以将程序分配到不连续的存储区中；程序运行前可只装入部分代码即可运行，后续根据需要动态申请分配内存；便于程序段的共享；可以向用户提供一个比存储空间大得多的地址空间（虚拟内存基础）。

#### (4) 逻辑地址 VS 物理地址
*   **逻辑地址 (Logical Address / Virtual Address - VA)**：
    *   `定义`：每个目标模块都从0号单元开始编址，用户程序和程序员只需知道逻辑地址。
    *   `特点`：不同进程可有相同的逻辑地址；相同的逻辑地址可以映射到主存的不同位置。
*   **物理地址 (Physical Address - PA)**：
    *   `定义`：地址转换的最终地址。进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。
    *   `转换`：当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为**地址重定位**。

#### (5) 内存共享
*   `实现`：主要通过**可重入代码 (纯代码)**。
*   `可重入代码`：一种允许多个进程同时访问但**不允许任何进程修改**的代码。只有只读区域才可以共享。

#### (6) 内存保护
*   **目的**：保证各进程都有单独的内存空间，不会越界访问。
*   **两种方式**：
    1.  `设置上下限寄存器`：进程的指令要访问某个地址时，CPU检查是否越界。
    2.  `重定位寄存器 (基址寄存器) + 界地址寄存器 (限长寄存器)`：
        *   `重定位寄存器`：含最小的物理地址值，用于"加"操作，`物理地址 = 逻辑地址 + 重定位寄存器值`。
        *   `界地址寄存器`：含逻辑地址的最大值（或长度），用于"比较"操作，`逻辑地址 <= 界地址寄存器值`。

### 2. 连续分配与非连续分配关系
#### (1) 连续分配 (Contiguous Allocation)
*   `特点`：为用户进程分配的必须是一个**连续**的内存空间。
#### (2) 非连续分配 (Non-contiguous Allocation)
*   `特点`：为用户进程分配的可以是一些**分散**的内存空间。
*   `分类`：根据分区大小是否固定，分为**分页存储管理方式**和**分段存储管理方式**。
*   `分页存储`：根据运行时是否要把所有页面都装入内存，分为**基本分页存储管理**和**请求分页存储管理**
#### (3) 关系
*   `缺点`：非连续分配需要额外的空间（如页表、段表）去存储分散区域的索引，使得其存储密度低于连续存储方式。

### 3. 连续分配管理方式
#### (1) 单一连续分配
*   `内存划分`：系统区（OS使用，通常低地址）、用户区（用户程序独占）。
*   `特点`：内存中只能有一道用户程序。
*   `优点`：简单、无外部碎片（但有内部碎片），可采用覆盖技术扩充内存，不一定需要内存保护。
*   `缺点`：用于单用户、单任务操作系统，存储利用率极低。
#### (2) 固定分区分配
*   `内存划分`：将用户内存空间划分为若干**固定大小**的区域，每个分区只装入一道作业。
*   `分区大小`：
    *   `相等`：缺乏灵活性，适用于控制系统。
    *   `不等`：增加了灵活性，满足不同大小进程需求。
*   `优点`：无外部碎片。
*   `缺点`：存在**内部碎片**（分区固定，进程可能用不完），内存利用率低。
#### (3) 动态分区分配
*   `内存划分`：不预先划分内存，而是在进程装入内存时，根据进程大小**动态地建立分区**，分区大小和数目可变。
*   `数据结构`：
    *   **空闲分区表**：记录空闲分区的起始地址和大小。
    *   **空闲分区链**：将空闲分区链成表。
*   `碎片`：**没有内部碎片**，但有**外部碎片**（由于太小而难以利用的空闲区）。
*   `外部碎片解决`：可用 **"紧凑"技术**（内存挪位）来解决，但开销大。
*   `回收内存的四种情况`：
    1.  回收区之后有相邻空闲分区：合并。
    2.  回收区之前有相邻空闲分区：合并。
    3.  回收区前、后都有相邻空闲分区：三个合并。
    4.  回收区前、后都没有相邻空闲分区：单独建立表项。

#### (4) 动态分区分配算法
1.  **首次适应算法 (FF, First Fit)**：`(效果最好)`
    *   `思想`：每次都从**低地址开始查找**，找到第一个能满足大小的空闲分区。
    *   `实现`：空闲分区以地址递增次序排列。
    *   `优点`：优先利用低地址部分空闲分区，保留高地址大的空闲分区。
    *   `缺点`：低地址部分不断划分，留下很多小碎片，增加查找开销。
2.  **最佳适应算法 (BF, Best Fit)**：
    *   `思想`：优先使用**更小的空闲区**进行分配，为保证"大进程"到来时能有连续的大片空间。
    *   `实现`：空闲分区按容量递增次序链接。
    *   `缺点`：会留下越来越多的、很小的、难以利用的内存块，产生大量外部碎片。
        *   **【2010 统考真题 Q62 考点】**：最佳适应算法分配和回收操作后，主存中最大空闲分区计算。
        *   **【2017 统考真题 Q67 考点】**：最佳适应算法下回收分区（含合并）后，空闲分区链的状态（数量、首分区始址和大小）。
        *   **【2019 统考真题 Q70 考点】**：最佳适应算法**最容易产生内存碎片**。
3.  **最坏适应算法 (WF, Worst Fit / Largest Fit)**：
    *   `思想`：每次分配时优先使用**最大的连续空闲区**，剩余的空闲区就不会太小。
    *   `实现`：空闲分区按容量递减次序链接。
    *   `优点`：剩下空闲区不至于太小，产生碎片可能性最小，查找效率高。
    *   `缺点`：较大空间迅速用完，"大进程"会没内存分区可用。
4.  **邻近适应算法 (NF, Next Fit)**：
    *   `思想`：每次都从**上次查找结束的位置开始检索**。
    *   `实现`：空闲分区以地址递增顺序排列（可排成一个循环链表）。
    *   `优点`：管理方案相对简单，不需要更多开销。
    *   `缺点`：无论低地址、高地址部分的空闲分区都有相同的概率被使用，高地址的大分区更可能被划分，最后导致无大分区可用（最坏适应算法的缺点）。
5.  **伙伴算法 (Buddy System)**：
    *   `思想`：将内存划分为 $2^k$ 大小的块，分配时分割，回收时与**相邻且大小相等**的"伙伴"合并。
    *   `特点`：回收分区时**仅合并大小相等的空闲分区**。
    *   **【2024 统考真题 Q73 考点】**：伙伴算法回收时仅合并大小相等的空闲分区。

### 4. 基本分页存储管理方式 ( #重点)
#### (1) 分页存储(Paging)基本概念
*   **原理**：将进程的虚拟地址空间和物理内存空间都划分为固定大小的块。
*   **页框 (Page Frame / Physical Block / Frame)**：
    *   `定义`：物理内存空间被划分为一个个大小相等的分区。每个页框有一个编号，即"页框号"，从0开始。
    *   `本质`：物理上的概念。
*   **页 (Page / 页面)**：
    *   `定义`：进程的逻辑地址空间被划分为与页框大小相等的一个个部分。每个页面也有一个编号，即"页号"，从0开始。
    *   `本质`：逻辑上的概念。
*   **页面大小**：应是2的幂（如4KB），便于硬件快速地把逻辑地址拆分为（页号，页内偏移量）。
*   **存储特点**：各个页面不必连续存放，可以放到不相邻的各个页框中（实现离散分配）。
*   **地址转换**：CPU 产生的**虚拟地址**由**虚拟页号 (Page Number)** 和 **页内偏移量 (Offset)** 组成。
    *   **计算公式**：虚拟页号 = 虚拟地址 / 页面大小；页内偏移 = 虚拟地址 % 页面大小。
    *   **在二进制中**：如果页面大小为 $2^N$ 字节，则低 $N$ 位是页内偏移，高位是虚拟页号。

#### (2) 页表 (Page Table)
*   **定义**：操作系统为每个进程维护的一张表，记录了该进程的**逻辑页号**与内存中**物理页框号**的对应关系。
*   **本质**：页表在内存中存储，本质上是一个**数组**。![[03 内存管理-1763347176042.png]]
    *   `页表起始地址`：保存在**页表基址寄存器 (PTBR)** 中，指向这个数组的起始物理地址。
    *   `页号`：作为数组的**下标**，用于快速定位到对应的页表项。
*   **页表项 (Page Table Entry, PTE)**：
    *   **定义**：页表中的每个元素，本质上是一个 `struct` 结构体，对应一个逻辑页。
    *   **内容**：通常包含以下关键字段：
        *   `有效位 (Present/Valid Bit - P)`：`1` 表示该页已调入内存；`0` 表示该页不在内存中，触发**缺页异常**。
        *   `物理页框号 (Page Frame Number - F)`：该逻辑页在物理内存中存放的页框号。
        *   `外存地址`：当页面不在内存时，指明该页在外存（如磁盘）中的存放地址，用于页面调入。
        *   `访问位 (Accessed Bit - A)`：记录该页是否被访问过（用于页面置换算法）。
        *   `修改位/脏位 (Dirty Bit - M)`：记录该页内容是否被修改过。若修改过，页面换出时需要写回外存。
        *   `保护位`：记录该页的访问权限（读/写/执行）。
*   **页表存放**：页表通常存放在**操作系统内核区**的内存中，由操作系统统一管理，不允许用户程序随意访问。

#### (3) 分页系统的逻辑地址结构
*   **逻辑地址 (Virtual Address, VA)**：CPU生成，用户程序使用的地址。
    *   **结构**：`页号 (P)` + `页内偏移量 (W)`
    *   `页号 (P)`：用于标识该地址所在的页。
    *   `页内偏移量 (W)`：用于标识该地址在页内的具体位置。
    *   `计算`：如果页大小为 $2^K$ 字节，则页内偏移量需要 $K$ 位表示。逻辑地址的其余高位则表示页号。

#### (4) 基本地址变换机构
*   **页表寄存器 (PTBR)**：存放当前运行进程的页表起始地址和页表长度。
    *   只在进程被调度时存放在页表寄存器中；进程未被调度时，存放在PCB中。
    *   **【2021 统考真题 Q71 考点】**：在二级分页系统中，CPU 页表基址寄存器中的内容是**当前进程的一级页表的起始物理地址**。
*   **地址变换过程 (逻辑地址 → 物理地址) (无快表)**：![[03 内存管理-1763347268554.png|474x254]]
    1.  根据逻辑地址算出**页号 `P`** 和 **页内偏移量 `W`**。
    2.  `合法性检查`：检查页号 `P` 的合法性（与页表长度对比）。
    3.  若页号合法，根据页表起始地址、页号 `P` 找到对应页表项。
    4.  检查页表项的**有效位**。若为0，触发**缺页中断**。若为1，取出**内存块号 (页框号 `F`)**。
    5.  将内存块号 `F` 与页内偏移量 `W` 拼接，得到最终的**物理地址 (PA)**。
    6.  **两次访存**：一次访问内存中的页表，一次访问目标内存单元。
*   **其他小细节**：
    *   页式管理中地址是**二维的**。
    *   页内偏移量位数与页面大小之间关系（$2^K$ 字节页面需要K位偏移量）。
    *   实际应用中，通常使一个页框恰好能放入整数个页表项。
    *   页表一般放在连续的内存块中。

#### (5) 具有快表 (TLB) 的地址变换机构
*   **快表 (TLB - Translation Lookaside Buffer)**： #TLB
    *   `定义`：联想寄存器，访问速度比内存快很多的**高速缓存**，位于CPU内部，用来**缓存最近访问过的页表项**，加速地址变换速度。
    *   `对比`：内存中的页表常称为**慢表**。TLB是缓存，非内存。
    *   `特点`：快表是硬件。当发生进程切换时，快表的内容也会被清除（刷新）。
*   **工作原理** (逻辑地址 → 物理地址)： ![[03 内存管理-1763347394569.png|517x281]]
    1.  CPU给出逻辑地址（虚拟地址），MMU算出页号 `P` 和页内偏移量 `W`。
    2.  MMU 首先并行地（或优先地）在 **TLB** 中查找对应的页表项，将页号 `P` 与快表中的所有页号进行**并行比较**。
    3.  **TLB 命中 (TLB Hit)**：如果找到，直接从 TLB 获取物理页框号（PFN），加上页内偏移形成物理地址，耗时很短。
        *   找到匹配的页号，且该快表项的**有效位为1**，说明要访问的页表项在快表中有副本。
        *   直接从中取出该页对应的内存块号 `F`。
        *   将内存块号 `F` 与页内偏移量 `W` 拼接形成物理地址。
        *   访问对应的内存单元。
        *   `访存次数`：若快表命中，访问某个逻辑地址仅需**一次访存**（直接访问目标内存单元）。
    4.  **TLB 未命中 (TLB Miss)**：如果没找到，就必须访问**主内存中的页表**，获取物理页框号。
        *   没有找到匹配的页号，或匹配页号的有效位为0。
        *   **第一次访存**：需要访问内存中的页表（慢表），找到对应页表项，得到页面存放的内存块号 `F`。
        *   将内存块号 `F` 与页内偏移量 `W` 拼接形成物理地址。
        *   **第二次访存**：访问该物理地址对应的内存单元。
        *   `同时操作`：将查到的页表项**存入快表**，以便后续可能的再次访问。若快表已满，则按算法替换旧项。
        *   `访存次数`：若快表未命中，访问某个逻辑地址需要**两次访存**。
*   **局部性原理 (Locality Principle)**：`#局部性原理`
    *   `时间局部性`：如果执行了程序中的某条指令或访问某个数据，不久后它很有可能再次被执行/访问（因循环）。
    *   `空间局部性`：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因数据连续存放）。
    *   `作用`：局部性原理是TLB和Cache能有效工作的根本原因，它使得TLB命中率较高，减少内存访问时间。
*   **访问时间**：
    *   TLB 访问时间 ($T_{TLB}$)
    *   内存访问时间 ($T_{mem}$)
    *   **无 TLB 且页命中**的地址转换时间 = $T_{mem}$ (访问页表) + $T_{mem}$ (访问数据)。
    *   **TLB 命中**的地址转换时间 = $T_{TLB}$ + $T_{mem}$ (访问数据)。
    *   **TLB 未命中但页命中**的地址转换时间 = $T_{TLB}$ + $T_{mem}$ (访问页表) + $T_{mem}$ (访问数据)。
*   **访问内存的有效时间**：
    *   `t`：访问内存的时间。
    *   `α`：快表命中率。
    *   `访快表时间`：通常远小于访问内存时间，可近似忽略。
    *   `有效访问时间 = t_TLB + α * t_memory + (1-α) * (t_TLB + t_memory + t_memory)`
    *   `简化后（忽略t_TLB）`：`有效访问时间 = α * t + (1-α) * 2t = (2-α) * t`。

#### (6) 多级页表 (Multi-level Page Table)
*   **存在什么问题？如何解决？**
    *   `问题1`：所有页表项必须连续存放，页表过大时需要很大的连续空间（单级页表的缺陷）。
    *   `问题2`：在一段时间内并非所有页面都用得到，没必要让整个页表常驻内存。
    *   `解决`：将页表再分页，为离散存放的页表再建立一张页表，该页表称为**页目录表**（外层页表/顶级页表）。
        *   **【2014 统考真题】**：多级页表的主要优点是**减少页表所占的连续内存空间**。
*   **多级页表的结构 (以二级页表示例)**：
    *   **【文件一考点】**：将VPN进一步拆分，构建多级页表。24位VPN被拆分为两个12位部分：**一级页号 (页目录号)** 和 **二级页号 (页表索引)**。
    *   `一级页表 (Page Directory)`：本质也是一个数组，由一级页号索引。每个一级页表项（页目录项）中保存的是**二级页表的起始页框号**。
    *   `二级页表`：本质也是一个数组，由二级页号索引。每个二级页表项中保存的是**最终的物理页框号**。
    *   `页目录项的作用`：通过一级页号查找一级页表，得到二级页表所在的页框号。再将此页框号与12位0拼接，得到二级页表的起始物理地址。
*   **逻辑地址结构**：`【一级页号，二级页号，页内偏移量】`
    *   `一级页号`：表示某个二级页表所存放在哪个内存块号。
    *   `二级页号`：表示具体某个页号存放在哪个内存块号。
    *   **【2010 统考真题 】
    *   **【2019 统考真题】**：给定二级分页地址结构和虚拟地址，计算页目录号和页号。需要从右往左按位切分并转换为十六进制。
*   **如何实现地址变换？**
    1.  按照地址结构将逻辑地址拆分成三部分。
    2.  从PCB中读出页目录表始址，根据**一级页号**查页目录表（**第一次访存**），找到下一级页表在内存中的存放位置（页框号）。
    3.  根据**二级页号**查二级页表（**第二次访存**），找到最终想访问的内存块号。
    4.  将内存块号与页内偏移量拼接，得到物理地址。
    5.  访问目标内存单元（**第三次访存**）。
*   **多级页表的优势**：
    *   **【文件一考点】**：减少页表占用内存空间：只有实际用到的虚拟地址空间才需要建立对应的页表，未使用的部分不占用内存。
    *   **【文件一考点】**：支持稀疏地址空间的高效管理：程序虚拟地址空间中可能存在大量未使用区域，多级页表避免为这些区域分配页表空间。
    *   **【文件一考点】**：不需要物理上连续的巨大页表：页目录和二级页表可以分散存储在不同的页框中。
*   **多级页表细节**：
    *   **访存次数 (无快表)**：N级页表访问一个逻辑地址需要 **N+1次访存**。
    *   **各级页表大小**：各级页表的大小不能超过一个页。若两级不够，可分更多级。
    *   **示例**：40位逻辑地址，页面大小4KB (12位偏移)，页表项4B。页号28位 (40-12)。每个页面可存放 $2^{12}/4 = 2^{10}$ 个页表项。每级页号10位。28位页号至少需要分**三级页表** ($10+10+8$ 或 $10+9+9$ 等)。
*   **引入快表后的访存次数**：引入快表后，若快表命中，则仅需一次访存（访问目标内存单元）。
    *   **【文件一考点】**：TLB在多级页表中的应用：TLB中保存的是**完整的虚拟页号**（例如，24位虚拟页号），而不是分两级保存。若TLB命中，可直接获取PFN。若TLB未命中，则需访问内存中的多级页表，逐级查找最终的PFN。缺页处理完成后，操作系统会将新的页表项信息（包括完整的VPN和PFN）更新到TLB中。对于多级页表，TLB中只存储最终的 `VPN -> PFN` 映射，而不是中间级页表的映射。

#### (7) 基本分页存储管理方式的优缺点
*   **优点**：
    *   内存利用率高（消除了外部碎片）。
    *   实现了离散分配
    *   便于存储访问控制。
*   **缺点**：
    *   需要硬件支持（MMU、TLB）。
    *   内存访问效率下降（无快表时两次访存）。
    *   可能产生**内部碎片**。
    *   不方便实现逻辑上的共享和保护。

#### (8) 共享页面
*   **【2023 统考真题 Q72 考点】**：进程共享数据页面的特征。
*   **特点**：共享数据在物理内存中只有一份副本，所以不同进程的页表项会指向同一个物理页框 ($f1 = f2$ **一定相等**)。但在各自的逻辑地址空间中，这些页可以有不同的页号 ($p1$ 和 $p2$ **不一定相等**)。
*   **共享页面的应用场景**：
    *   **进程间通信 (IPC) - 共享内存**：最直接的应用，进程通过共享页面实现高效的数据传输。
    *   **共享库/内核区**：多个进程可以共享同一个物理内存中的共享库代码（如 `libc.so`）或操作系统的内核代码和数据。
        *   **原理**：每个进程的页表中的相应虚拟页号都映射到物理内存中的同一份代码/数据页框。
*   **进程间通信的底层机制 (示例：信箱/管道)**：
    1.  **发送进程请求**：进程通过**系统调用**请求操作系统发送数据给另一个进程。
    2.  **数据复制到内核区**：操作系统收到请求后，会将发送进程准备好的数据**复制到内核区**的一个共享页面中（物理上只有一份数据）。
    3.  **接收进程请求**：接收进程也通过**系统调用**请求操作系统接收数据。
    4.  **数据复制到用户区**：操作系统从内核区的共享页面中读取数据，并将其复制到接收进程的用户区中指定的缓冲区。
    *   **核心**：内核区充当了进程间通信的**中转站**。通过页面共享，操作系统能够高效地协调不同进程间的数据交换，同时保证系统的安全性和隔离性。

### 5. 基本分段管理方式 ( #小题常考)
#### (1) 分段 (Segmentation)
*   `特点`：将地址空间按照程序自身的**逻辑关系**划分为若干个**段**。每段从0开始编址。
*   `存储`：每个段在内存中占据**连续空间**，但各段之间可以**不相邻**（段内连续，段间离散）。
*   `逻辑地址结构`：`【段号，段内地址】`。段号位数决定最大段数；段内地址位数决定每个段最大长度。
    *   **【2009 统考真题 Q61 考点】**：段式存储中，地址总长和段号位数确定最大段长。最大段长 = $2^{(\text{总地址位数} - \text{段号位数})}$.

#### (2) 段表 (Segment Table)
*   `定义`：记录逻辑段到实际存储地址的映射关系。一个段对应一个段表项。
*   `内容`：段号（隐含）、**段长**（每个段的长度可能不同）、**基址**（段的起始物理地址）。
*   `段表寄存器`：存放段表在内存中的起始地址和段表长度。

#### (3) 如何实现地址变换
![[03 内存管理-1763212698506.png|500]]
1.  由逻辑地址得到**段号**、**段内地址**。
2.  `合法性检查`：段号与段表寄存器中的段长度比较，检查越界。
3.  由段表始址、段号找到对应段表项。
4.  根据段表中记录的段长，检查段内地址是否越界（因为每个段大小可能不同）。
    *   **【2016 统考真题】**：分段存储中，访问段号为2，段内地址为400的逻辑地址，若段2的段长为300，则会触发**越界异常**。
5.  由段表中的"基址 + 段内地址"得到最终的物理地址，访问目标单元。
*   **特点**：地址变换过程由硬件自动完成。

#### (4) 优缺点
*   **优点**：
    *   **方便编程**：作业按逻辑关系划分，每段从0编址，有名称和长度。
    *   **便于共享**：段是信息的逻辑单位，可按段共享代码和数据。
        *   **【2019 统考真题 Q68 考点】**：共享段在不同进程中可以有**不同的段号**，但物理内存中只保存一份段内容，且由引用计数管理回收。
    *   **便于保护**：每一段包含相对独立信息，可采取对段进行保护。
*   **缺点**：
    *   需要硬件支持。
    *   为满足分段的动态增长和减少外部碎片，要采用拼接技术。
    *   分段的最大尺寸受到主存可用空间的限制。
    *   存在**外部碎片**。

#### (5) 分段、分页管理的对比
*   **单位**：分页是信息的**物理单位**；分段是信息的**逻辑单位**。
*   **大小**：分页大小**固定**；分段大小**不固定**。
*   **可见性**：分页是**系统行为**，对用户不可见；分段是**用户行为**，对用户可见。
*   **碎片**：分页有**内部碎片**，无外部碎片；分段无内部碎片，有**外部碎片**。
*   **地址空间**：分页的地址空间是**二维的**；分段的地址空间是**二维的**。
*   **访存**：分页（单页表）访问一个逻辑地址需要两次访存；分段存储中也可用快表减少访存。

#### (6) 段的共享和保
页、段共享的原理和特点 **(2019、2023 统考真题考点)**
*   **目的**：让多个进程共享内存中的一份代码或数据，节省内存空间。主要通过**可重入代码（纯代码）** 实现。
*   **可重入代码 (纯代码)**：
    *   `定义`：一种允许多个进程同时访问但**不允许任何进程修改**的代码。
    *   `特点`：只有只读区域才可以共享。为防止程序执行时修改共享代码，每个进程须配以局部数据区，将执行过程中可能改变的部分复制到数据区，进程对数据区内容进行修改。
*   **分段系统中的共享 (更方便)**：
    *   `原理`：段是信息的逻辑单位，可以很自然地实现共享。
    *   `实现`：
        *   在物理内存中，共享段的内容只保存一份。
        *   每个共享该段的进程，其各自的段表中会设置一个段表项，指向物理内存中该共享段的同一个起始地址。
        *   **【2019 统考真题】**：对于一个共享段，在不同的进程中**可以具有不同的段号**。进程用自己进程的段号去访问该共享段，但它们各自段表项指向的是同一份物理内存中的段内容。
        *   系统中通常配置一张**共享段表**，记录共享段的段号、段长、内存始址、状态位、外存始址和**共享进程计数 (count)** 等信息。
        *   **共享进程计数 (count)**：记录有多少进程正在共享该段。仅当所有共享该段的进程都不再需要它时（count = 0），才回收该段所占的内存区。
    *   `优点`：共享段只需一个段表项，管理方便。
*   **分页系统中的共享 (不如分段方便)**：
    *   `原理`：页是物理单位，共享需要按页进行。
    *   `实现`：若被共享的代码占 $N$ 个页框，则每个进程的页表中都要建立 $N$ 个页表项，分别指向被共享的 $N$ 个页框。
    *   **【2023 统考真题】**：若进程 R 和 S 共享数据 `data`，且 `data` 在各自进程中所在的逻辑页号分别为 $p1$ 和 $p2$，它们所对应的物理页框号分别为 $f1$ 和 $f2$。则 **$p1$ 和 $p2$ 不一定相等**（逻辑地址可不同），但 **$f1$ 和 $f2$ 一定相等**（共享同一份物理内容）。
    *   `缺点`：管理相对复杂，需要多个页表项。
*   **共享的保护**：
    *   主要有两种：**存取控制保护**（权限管理，如只读）和**地址越界保护**。
    *   **地址越界保护对比**：
        *   **分段管理**：将段表寄存器中的段表长度与逻辑地址中的段号比较（检查段号越界），再将段表项中的段长与逻辑地址中的段内偏移进行比较（检查段内偏移越界）。
        *   **分页管理**：只需判断页号是否越界，页内偏移是不可能越界的（因为偏移量是固定的，由页大小决定，总能找到对应位置）。

---

### 6. 段页式管理方式
#### (1) 段页式概念
*   **结合**：结合了分段和分页管理方式的优点。
*   **划分**：先将地址空间按照程序自身逻辑关系划分为若干个**段**，再将各段分为大小相等的**页面**。
*   **内存分配**：将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存。
*   **逻辑地址结构**：`【段号，页号，页内偏移量】`。

#### (2) 段表、页表
*   **段表项**：每个段对应一个段表项，由段号（隐含）、**页表长度**、**页表存放地址**（指向该段的页表起始地址）组成。
*   **页表项**：每个页对应一个页表项，由页号（隐含）、**页面存放的内存块号**组成。

#### (3) 如何实现地址变换
![[03 内存管理-1763212772913.png|500]]
1.  由逻辑地址得到**段号**、**页号**、**页内偏移量**。
2.  `合法性检查1`：段号与段表寄存器中的段长度比较，检查是否越界。
3.  由段表始址、段号找到对应段表项。
4.  `合法性检查2`：根据段表中记录的页表长度，检查页号是否越界。
5.  由段表中的页表地址、页号查询页表，找到相应页表项。
6.  将页面存放的内存块号、页内偏移量得到最终的物理地址。
7.  访问目标单元。
*   **访存次数**：无快表时，需要**三次访存**（查段表、查页表、访问目标单元）。
*   **引入快表**：可引入快表机构，以**段号和页号**为关键字查询快表，可直接找到目标页面存放位置。引入快表后，若命中仅需**一次访存**。

---

## 03-2 虚拟内存管理
*   **【考点趋势】**：截至目前，考研大题中，内存管理部分**只考察过"请求页式存储管理"**，从未考过分段式或段页式管理。原因在于大纲引导和技术发展趋势（纯页式是现代操作系统最流行、最通用和优秀的解决方案）。复习策略：将重点放在**页式存储管理**。段式和段页式管理可作为次要复习内容。
### 1. 虚拟内存基本概念
#### (1) 传统存储管理方式的特征、缺点
*   **一次性 (Onceness)**：
    *   `特征`：作业必须一次性全部装入内存后才能开始运行。
    *   `缺点`：
        *   作业很大时，不能全部装入内存，导致大作业无法运行。
        *   当大量作业要求运行时，由于内存无法容纳所有作业，导致多道程序并发度下降。
*   **驻留性 (Residency)**：
    *   `特征`：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。
    *   `缺点`：在一个时间段内，只需要访问作业的一小部分数据即可正常运行，内存中会驻留大量暂时用不到的数据，浪费内存资源。

#### (2) 局部性原理 (Locality Principle)
*   `时间局部性`：现在访问的指令、数据在不久后很可能会被再次访问（因为程序中存在大量的循环）。
*   `空间局部性`：现在访问的内存单元周围的内存空间，可能不久后会被访问（因为数据在内存中通常连续存放）。
*   `应用`：高速缓存技术（TLB、Cache）就是利用局部性原理，将频繁使用的数据放到更高速的存储器中。

#### (3) 虚拟内存(Virtual Memory)的定义
*   **概念**：一种内存管理技术，使应用程序认为它拥有连续的、私有的、比实际物理内存大得多的内存空间。
    *   **【2023 统考真题 Q57 考点】**：**每个进程都有自己独立的虚拟地址空间**，且 C 语言中 `malloc()` 函数返回的是**虚拟地址**。虚拟地址空间的大小由 **CPU 架构的地址位数**决定，而非内存和硬盘大小。
*   **目的**：
    *   **拓展寻址空间**：让程序可以使用比物理内存更大的地址空间。
    *   **内存保护**：隔离不同进程的内存空间，防止互相干扰。**进程可以对数据段和代码段有不同的访问权限**。
    *   **提高内存利用率**：只把程序当前需要的页面加载到物理内存，其他页面留在磁盘上。
    *   **支持多道程序设计**：方便内存的共享和隔离。
*   `核心`：程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据。
*   `本质`：一种具有**请求调入功能**和**置换功能**，从逻辑上对内存容量加以扩充的存储器系统。

#### (4) 虚拟内存特征
1.  **多次性**：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
2.  **对换性**：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
3.  **虚拟性**：从逻辑上扩充内存的容量，使用户看到的内存容量远大于实际的容量。

#### (5) 如何实现虚拟内存技术
*   `基础`：借助**离散分配的内存管理方式**（**请求页式**、**请求分段**、**请求段页式**）。
    *   **【2012 统考真题 Q44 考点】**：虚拟内存只能基于**非连续分配**来实现。
*   `机制`：
    *   一定容量的内存和外存
    *   页表机制（或段表），作为主要的数据结构
    *   中断机制，当用户程序要访问的部分尚未调入内存时，则产生中断
    *   地址变换机构，逻辑地址——>物理地址

### 2. 请求分页管理方式 ( #重中之重)
#### (1) 页表机制 (扩展页表项)
在[[#4. 基本分页存储管理方式 ( 重点)|基本分页]]的基础上，页表项增加了几个字段：
`页号 | 物理块号 | 状态位P | 访问字段A | 修改位M | 外存地址 |`
*   `状态位 P (存在位)`：表示页面是否已在内存中。0触发缺页异常。
*   `访问字段 A`：记录最近被访问过几次，或上次访问时间，供置换算法参考。
*   `修改位 M (脏位)`：表示页面调入内存后是否被修改过。修改过的页面换出时需写回外存。
*   `外存地址`：记录页面在外存中存放的位置。

#### (2) 缺页中断机构(Page Fault)
*   **何时发生**：当进程访问的虚拟页对应的页表项的**有效位为 `0`** 时（即该页不在物理内存中）。
*   **处理流程**：
    1.  **产生中断**：CPU 捕获缺页中断，控制权转交操作系统。
    2.  **保存现场**：操作系统保存当前进程的上下文。
    3.  **查找空闲页框或页面置换**：
        *   **空闲页框**：若有，直接分配。
        *   **无空闲页框 (驻留集已满)**：根据**页面置换算法**（如 LRU、FIFO、OPT 等）选择一个牺牲页框。
            *   **LRU (Least Recently Used)**：淘汰**最近最久未被使用的页面**。
            *   **驻留集大小 (Resident Set Size)**：一个进程在物理内存中可以拥有的最大页框数。
        *   **【2011 统考真题 Q42 考点】**：缺页处理过程中，操作系统可能执行的操作包括**分配页框、磁盘 I/O、修改页表**。
        *   **【2013 统考真题 Q45 考点】**：缺页异常时，操作系统可能执行的操作是**置换页面、分配内存（页框）**。
        *   **【2022 统考真题 Q55 考点】**：缺页异常处理中，**将脏页（已修改的页面）写回外存不一定是每次都包含的操作**（只有当被置换的页面被修改过才需要）。为页面分配内存、从外存调入页面、建立页框映射关系是必须包含的操作。
    4.  **调入页面**：将缺失页面从磁盘调入到选定的物理页框。
        *   **【文件一考点】**：操作系统根据页表项中的**外存地址**，定位页面在外存中的位置。操作系统启动磁盘I/O，将页面从外存（如硬盘）调入到物理内存中的一个**空闲页框**。
    5.  **更新页表**：修改页表项，设置有效位为 `1`，记录新的物理页框号。
        *   **【文件一考点】**：页面调入完成后，操作系统更新该页面的页表项：设置有效位为1，更新页框号为新的物理页框号，设置脏位为0。
    6.  **更新 TLB**：将新的页表项加入 TLB。
        *   **【文件一考点】**：若TLB中存在该VPN的旧项，MMU将其**置为无效**（有效位设0）。有的系统会在缺页处理完成后立即更新TLB，有的则在下次访问时更新。
    7.  **恢复现场**：恢复进程上下文，并**重新执行导致缺页中断的指令**。
        *   **【文件一考点】**：CPU切换回用户态，并**重新执行**之前导致缺页的指令。此时，由于页面已在内存，地址转换会成功。

*   `性质`：缺页中断属于**内中断**，是内中断中的"故障"，即可能被系统修复的异常。
*   `特点`：一条指令在执行过程中可能产生**多次**缺页中断（例如，指令本身跨页，操作数也跨页）。

#### (3) 地址变换机构 (TLB在请求分页中)
*   `对比`：内存中的页表常称为**慢表**。TLB是缓存，非内存。
    *   `特点`：快表是硬件。当发生进程切换时，快表的内容也会被清除（刷新）。
    *   **【文件一考点】**：TLB中保存的是最近访问过的页表项的**副本**，只包含关键字段（如虚拟页号、物理页框号、有效位等）。映射方式在操作系统课程中通常只探讨**全相联映射**。
    *   **【文件一考点】**：TLB是**CPU内部**的高速缓存，不依赖操作系统管理，而是由硬件管理。
![[03 内存管理-1761396149467.png|543x356]]
* **1. 逻辑地址拆分**
    *   CPU给出逻辑地址（虚拟地址），MMU（内存管理单元）将其拆分为**页号 (P)** 和 **页内偏移量 (W)**。
*   **2. TLB（快表）检索**
    *   MMU 首先并行地（或优先地）在 **TLB** 中查找对应的页表项，将页号 `P` 与快表中的所有页号进行**并行比较**。
*   **3. TLB 命中 (TLB Hit)**
    *   若找到匹配的页号，且该快表项的**有效位为1**（说明要访问的页表项在快表中有副本）。
    *   从TLB中取出该页对应的物理块号（页框号 `F`）。
    *   **更新状态**：同时，修改页表项中的**访问位 (A)** 为1，以供置换算法参考。对于**写指令**，还需要将**修改位 (M)** 置为1。
    *   **访存次数**：若快表命中，访问某个逻辑地址仅需**一次访存**（直接访问目标内存单元）。
    *   **拼接物理地址**：将物理块号 `F` 与页内偏移量 `W` 拼接形成物理地址，然后用该地址去访存。
    *   `核心`：TLB查询优先于页表查询，TLB命中时不可能发生缺页。
*   **4. TLB 未命中 (TLB Miss)**
    *   若没有找到匹配的页号，或匹配页号的有效位为0，则必须访问**主内存中的页表（慢表）**。
    *   **第一次访存**：根据**页表基址寄存器 (PTBR)** 查询内存中的页表，找到对应页表项。
    *   **判断页表项有效性**：
        *   **4.1. 页表项有效（慢表命中且有效）**
            *   若页表项的**有效位为1**：从页表中取出页面存放的物理块号 `F`。
            *   **更新快表**：将查到的页表项**存入快表**。若快表已满，则需采用某种算法（如LRU）替换旧项。
            *   **更新状态**：修改页表项中的**访问位 (A)** 为1。对于**写指令**，还需要将**修改位 (M)** 置为1。
            *   **访存次数**：TLB未命中但页表命中，访问某个逻辑地址需要**两次访存**（一次访问页表，一次访问目标内存单元）。
            *   **拼接物理地址**：将物理块号 `F` 与页内偏移量 `W` 拼接形成物理地址，然后用该地址去访存。
        *   **4.2. 页表项无效（慢表命中但有效位为0，发生缺页）**
            *   若页表项的**有效位为0**：这表示所需页面当前不在物理内存中，触发**缺页中断处理**。
            *   **缺页处理**：请求操作系统将该页从外存（如磁盘）换入内存。
            *   **更新映射**：页面被调入内存后，由操作系统负责**更新页表和快表**（设置有效位为1，记录新的物理块号等），并获得新的物理块号。
            *   **访存次数**：缺页处理还会涉及**磁盘I/O**操作，消耗时间远大于内存访问。
            *   **重新执行与拼接**：缺页处理完成后，通常会**重新执行**导致缺页中断的指令。此时，页表和快表已更新，地址变换将成功，然后得到的物理块号 `F` 和页内偏移量 `W` 拼接形成物理地址，用该地址去访存。
*   `核心`：TLB查询优先于页表查询。
*   `TLB命中且有效位为1`：不可能发生缺页。直接获取物理页框号，拼接页内偏移量，一次访存。
*   `TLB命中但有效位为0，或者TLB未命中`：
    *   **第一次访存**：根据PTBR查询内存中的页表。
    *   `检查有效位`：
        *   若为1（慢表命中且有效）：得到PFN，拼接PA，二次访存。同时将映射关系复制到TLB。
        *   若为0（慢表命中但有效位为0，**发生缺页**）：过程同无TLB时的缺页处理。
*   `补充`：
    *   只有写指令才需要修改"修改位"。
    *   缺页中断处理需要保留CPU现场。
    *   当内存满时，由页面置换算法决定换出哪个页面。
    *   调入内存后，不仅需要修改慢表，也需要将慢表中关于其的表项复制到快表中。
*   **【2014 统考真题 Q46 考点】**：**增大快表 (TLB) 容量**能加快地址变换速度。
*   **【2021 统考真题 Q54 考点】**：给定虚拟地址和页表信息，进行分页地址转换，计算物理地址。

### 3. 请求分段管理方式
*   `特点`：段表项扩展，增加存在位P、访问字段A、修改位M、外存始址等。
*   `地址变换`：与基本分段类似，但若发现所需段不在内存，触发缺段异常，调入内存并修改段表。
*   `分段的共享与保护`：
    *   **共享段表**：系统配置一张共享段表，所有共享段都在其中占表项，记录段号、段长、基址、状态位、外存始址、共享计数等信息。
    *   **共享进程计数 `count`**：为0时才回收段所占内存。
    *   **存取控制字段**：为不同进程赋予不同存取权限。
    *   **段号**：在不同进程中可有不同段号访问同一共享段。
    *   **分段保护**：越界检查、存取控制检查、环保护机构。

### 4. 页框分配
#### (1) 驻留集 (Resident Set)
*   `定义`：请求分页存储管理中给进程分配的**物理块的集合**。
*   `大小`：一般小于进程的总大小。
*   `影响`：
    *   `太小`：导致缺页频繁（抖动），系统大部分时间处理缺页。
    *   `太大`：导致多道程序并发度下降，资源利用率降低。
    *   `选择`：应选择合适的驻留集大小。
#### (2) 页面分配、置换策略
1.  **固定分配局部置换**：
    *   `特点`：操作系统为每个进程分配一组**固定数目**的物理块，运行期间不改变。缺页时只能从进程自己的物理块中选择一页换出。
    *   `缺点`：难以确定合理的初始分配块数。
2.  **可变分配全局置换**：
    *   `特点`：刚开始为每个进程分配一定数量物理块。操作系统维护一个**空闲物理块队列**。缺页时，从空闲块中取一块分配给该进程；若无空闲块，则可选择一个未锁定的页面**换出**到外存（可能是其他进程的页面），再分配给缺页进程。
    *   `影响`：只要某进程*缺页就获*得新块。被选择调出的页可能是任何进程的页，被选中进程的物理块会减少，缺页率可能增加。
3.  **可变分配局部置换**：
    *   `特点`：刚开始分配一定数量物理块。缺页时，只允许从该进程自己的物理块中选出一个进行换出。
    *   `动态调整`：若进程频繁缺页，系统会多分配几个物理块；若缺页率低，则减少分配。
*   **【2015 统考真题 Q48 考点】**：**固定分配，全局置换**的组合策略不能组合使用，因为这两种策略的理念相互矛盾。
#### (3) 调页
* **调入页面的时机**
    *   `预调页策略`：一般用于进程运行前，首次调入，由程序员指出应先调入哪些页。
    *   `请求调页策略`：进程运行时，发现缺页再调页。
* 从何处调页
    *   `对换区 (Swap Space)`：采用连续存储方式，速度更快。
    *   `文件区`：采用离散存储方式，速度更慢。
    *   `策略`：
        *   `对换区足够大`：将数据从文件区复制到对换区，之后所有页面调入、调出都在内存与对换区之间进行。
        *   `对换区不够`：未修改的数据每次从文件区调入；已修改的数据调出到对换区，需要时再从对换区调入。
#### (4) 抖动 (Thrashing)
*   `定义`：页面频繁换入换出的现象。
*   `原因`：主要原因是分配给进程的物理块不够，不满足进程正常运行的基本要求。
*   `后果`：系统大部分时间用于换页，CPU利用率急剧下降。
*   **【2011 统考真题 Q43 考点】**：当系统发生抖动时，可以采取的有效措施是**撤销部分进程**、**增加磁盘交换区的容量**。
#### (5) 工作集 (Working Set)
*   `定义`：在某段时间间隔里，进程实际访问页面的集合。
    *   **【2016 统考真题 Q51 考点】**：给定页面引用串和窗口大小 `Δ`，计算当前时刻的工作集。
*   `关系`：进程发生缺页率的时间间隔与进程所获得的物理块数有关。
*   `应用`：用最近访问过的页面来确定工作集。驻留集大小一般不能小于工作集大小。

### 5. 页面置换算法 ( #重点)
*   `目的`：当内存中没有空闲页框且发生缺页时，选择一个页面淘汰。
1.  **最佳置换算法 (OPT, Optimal)**：`#OPT`
    *   `思想`：每次选择淘汰的页面将是以后**永不使用**，或者在**最长时间内不再被访问**的页面。
    *   `优点`：保证最低的缺页率。
    *   `缺点`：**无法实现**，因为操作系统无法提前预判页面访问序列。
    *   `作用`：作为衡量其他算法性能的基准。
2.  **先进先出置换算法 (FIFO, First-In First-Out)**：`#FIFO`
    *   `思想`：每次选择淘汰的页面是**最早进入内存的页面**。
    *   `实现`：把调入内存的页面按调入顺序排成队列，淘汰队头页面。
    *   `缺陷`：**Belady异常**——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。
        *   **【2014 统考真题 Q47 考点】**：只有 **FIFO 算法**会发生 Belady 异常。
    *   `性能`：实现简单，但与进程实际运行规律不符（最早进入的页面也可能经常被访问），算法性能差。
3.  **最近最久未使用置换算法 (LRU, Least Recently Used)**：`#LRU`
    *   `思想`：每次淘汰的页面是**最近最久未使用的页面**。
    *   `实现`：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 `t`。选择 `t` 值最大的页面淘汰。
        *   **【2015 统考真题 Q49 考点】**：模拟 LRU 算法，计算淘汰页的页号。
        *   **【2019 统考真题 Q52 考点】**：模拟 LRU 算法，计算过程中产生置换的总次数。
    *   `性能`：性能较好，但实现开销大（需要硬件支持，记录时间戳或维护链表）。
4.  **时钟置换算法 (CLOCK)**：`#CLOCK`
    *   `思想`：一种性能和开销较均衡的近似LRU算法，又称CLOCK算法、最近未用算法。
    *   `实现`：为每个页面设置一个**访问位 (A)**，将内存中的页面链接成一个循环队列。
        *   `检查`：要淘汰页面时，从当前指针位置开始检查。
        *   `A=0`：选择该页换出。
        *   `A=1`：将 `A` 置为0，暂不换出，继续检查下一个页面。
    *   `特点`：若第一轮扫描所有页面都是1，则将这些页面访问位依次置0后，再进行第二轮扫描（最多经过两轮扫描）。
5.  **改进型时钟置换算法 (Enhanced Clock)**：`#改进型CLOCK`
    *   `思想`：除了考虑访问位，还应考虑**修改位 (M)**。优先淘汰未修改的页面，避免I/O操作。
    *   `页面状态`：用 `(访问位A, 修改位M)` 表示各页面状态。
    *   `淘汰顺序`：
        1.  `(0, 0)`：最近未被访问，且未被修改，是最佳淘汰页。
        2.  `(0, 1)`：最近未被访问，但已被修改。
        3.  `(1, 0)`：最近已被访问，但未被修改。
        4.  `(1, 1)`：最近已被访问，且已被修改，最差淘汰页。
        *   **【2016 统考真题 Q50 考点】**：改进型 CLOCK 算法，按 (A, M) 的状态淘汰页的次序为 **(0,0), (0,1), (1,0), (1,1)**。
### 6. 页框回收 (页面缓冲算法)
**【2025 年大纲新增考点】**
*   **页框回收目的**：当系统可分配的内存不足时，就必须回收一些页框。
    *   **并非所有页框都能回收**：属于内核的大部分页框（如内核栈、内核代码段、内核数据段和大部分内核使用的页框）都是不能回收的，而由进程使用的页框大部分可以回收。
    *   **阈值机制**：在 Linux 内核中，设置了一个负责页面换出的守护进程 `kswapd`，它定期检查内存的使用情况，当空闲页框数量少于特定的阈值时，便发起页框回收操作，以避免内存请求僵局和系统崩溃。
*   **页面缓冲算法 (Page Buffer Algorithm)**：一种优化页面换入/换出效率的算法。
    *   **影响页面换入/换出效率的因素**：
        1.  页面置换算法：好的算法可使缺页率较低。
        2.  已修改页面写回磁盘的频率：频繁写回导致大量磁盘 I/O 开销。
        3.  磁盘内容读入内存的频率：频繁读入导致高磁盘 I/O 频率。
    *   **主要特点**：显著降低页面换入/换出的频率，减少磁盘 I/O 开销。实现简单，不需要特殊硬件支持。
    *   **实现机制（两个链表）**：
        1.  **空闲页面链表** (Empty Page List)：
            *   当进程需要读入页面时，从链首取页框。
            *   当一个**未被修改的页面**要换出时，**不立即写回磁盘**，而是将其所在页框挂在链表的链尾。
            *   `特点`：这些挂在空闲链表的页框中仍然保留着数据。若后续进程再次需要这些数据，可直接从链表上取下，避免从磁盘读入，减少换入开销。
        2.  **修改页面链表** (Modified Page List)：
            *   当一个**已修改的页面**要换出时，系统不立即写回磁盘，而是将其所在页框挂在链表的末尾。
            *   `目的`：批量写回，降低写回磁盘的频率，进而降低将磁盘内容读入内存的频率。
*   **页框回收与伙伴算法**：
    *   在 Linux 系统中，采用"伙伴算法"对内存中连续空闲页框进行统计和记录。
    *   回收页框时，伙伴算法通过逆操作（检查相邻且大小相等的伙伴页框块）将零碎的页框合并成更大的连续页框块，以减少碎片。

### 7. 内存映射文件 (Memory-Mapped Files)
*   **定义**：操作系统向应用程序提供的一种系统调用，在**磁盘文件与进程的虚拟地址空间之间建立映射关系**。
*   **工作方式**：进程通过该系统调用将文件映射到其虚拟地址空间的某个区域，之后就能用**访问内存的方式来读/写文件**，而无需通过传统的文件 I/O 操作。
*   **特点**：
    *   磁盘文件的读/写由操作系统负责，对进程透明。
    *   在映射进程的页面时，不会实际读入文件的内容，而只在**访问页面时才被每次一页地读入**（按需调入）。
    *   当进程退出或关闭文件映射时，所有**被改动的页面才被写回磁盘文件**。
*   **带来的好处**：
    1.  **编程更简单**：程序员只需按访问内存的方式进行读/写。
    2.  **便于多进程共享文件**：
        *   多个进程可以将**同一个文件映射到各自的虚拟地址空间**。
        *   操作系统将对应的这些虚拟地址空间映射到**相同的物理内存**（用页表实现）。
        *   一个进程在共享内存上完成写操作，另一个进程立即能看到结果，实现高效进程间通信。
![图 3.28 采用内存映射 I/O 的共享内存](pasted_image_placeholder_for_diagram_if_needed)

### 8. 虚拟存储器性能影响因素
**命题追踪：请求分页系统性能的影响因素分析（2020、2022 统考真题考点）**
*   **缺页率**：是影响虚拟存储器性能的主要因素。缺页率又受到以下因素影响：
    1.  **页面大小**：
        *   根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。
        *   页面较小时：减少内存碎片，提高内存利用率；但每个进程要求较多页面，导致页表过长，占用大量内存。
        *   页面较大时：减少页表长度；但会使页内碎片增大。
    2.  **分配给进程的物理块数**：
        *   物理块数越多，缺页率越低。
        *   但当物理块超过某个数量时，再增加对缺页率改善不明显，反而浪费内存空间。
        *   只需保证活跃页面（工作集）在内存中，使缺页率保持在很低的范围即可。
    3.  **页面置换算法**：
        *   好的页面置换算法（如 LRU、CLOCK）可使进程在运行过程中具有较低的缺页率。
        *   选择将未来有可能访问的页面尽量保留在内存中，从而提高页面的访问速度。
    4.  **写回磁盘的频率**：
        *   换出已修改过的页面时，应当写回磁盘。若每次换出都立即写回，效率极低。
        *   通过建立**已修改换出页面链表**（如页面缓冲算法），将待换出的脏页暂挂链表，达到一定数量后再批量写回，可显著减少磁盘 I/O 次数。
        *   若进程在脏页写回前再次访问，可直接从链表获取，减少页面从磁盘读入内存的频率。
    5.  **程序的编制方法（局部化程度）**：
        *   编写程序的局部化程度越高（时间局部性和空间局部性越好），执行时的缺页率就越低。
        *   若存储采用按行存储，则访问时应尽量按行访问，避免按列访问造成缺页率过高。
*   **【2022 统考真题 Q56 考点】**：**缓存缓冲长度 (Cache Buffer Length)** 不会影响缺页率，缺页率受页面置换算法、工作集大小、进程数量等影响。
*   **【2020 统考真题 Q53 考点】**：影响请求处理系统平均等待时间的因素包括：**I/O 处理时间、CPU 时间、内存访问时间、中断处理时间**。

### 9. 进程的虚拟地址空间与页表关系
*   **【文件一考点】**：**CPU如何获取虚拟地址**：
    *   **取指令**：CPU的**程序计数器 (PC)** 寄存器中保存的是下一条要执行指令的**虚拟地址**。
    *   **取数据**：当前执行的指令（存储在**指令寄存器 IR** 中）会包含要访问数据的**内存地址相关信息**（操作数）。这些信息结合指令的**寻址方式**（如寄存器间接寻址、基址寻址等）计算出数据的**虚拟地址**。
*   **【文件一考点】**：**进程的虚拟地址空间构成**：
    *   **用户区**：
        *   `代码段 (Code Segment)`：存放程序指令。
        *   `读写数据段 (Data Segment)`：存放全局变量、静态变量等。
        *   `堆 (Heap Segment)`：用于动态分配内存，由程序员管理。
        *   `栈 (Stack Segment)`：用于函数调用信息（参数、局部变量、返回地址），由系统管理。
    *   **内核区 (Kernel Space)**：
        *   由操作系统代码和数据组成，所有进程**共享**物理上同一份内核区数据。
        *   **目的**：提供系统调用、中断处理、驱动程序等服务。
*   **【文件一考点】**：**进程的创建与页表建立**：
    *   操作系统为每个进程创建**PCB (进程控制块)**。
    *   PCB中包含该进程的**页表起始地址**（即页表基址寄存器应加载的值）。
    *   当进程被调度执行时，操作系统会将PCB中的页表起始地址复制到CPU的**页表基址寄存器**中。
    *   进程的指令、数据（如代码段、数据段、堆、栈）在被加载到物理内存时，操作系统会同时在进程的页表中建立相应的**虚拟地址到物理地址的映射关系**。
*   **【文件一考点】**：**进程的地址转换流程 (结合PC、IR寄存器)**：
    1.  CPU通过 **PC寄存器** 获取当前指令的**虚拟地址 (VA)**，或通过 **IR指令寄存器** 中指令的寻址方式获取数据VA。
    2.  将VA拆分为VPN和Offset。
    3.  CPU的MMU (内存管理单元) 使用**页表基址寄存器**的值和VPN，通过查TLB和页表，获得对应的PFN。
    4.  将PFN与Offset拼接形成PA。
    5.  CPU使用PA访问物理内存，获取指令或数据。
*   **【文件一考点】**：**页表与TLB在物理内存中的位置**：
    *   **内核区共享机制**：
        *   所有进程**共享内核区的物理页面**。
        *   物理内存中的内核数据（如操作系统代码、数据、驱动程序、其他进程的PCB）只有一份拷贝。
        *   但这些内核数据会被**映射到每个进程虚拟地址空间的内核区**。
        *   **安全性**：用户态进程不能直接访问内核区。若用户态程序试图访问内核区，会触发**异常**，保护系统安全。

---

## 03-3 地址翻译：TLB与Cache的综合应用（高级）
**【本节结合"计算机组成原理"的 Cache 部分，说明虚实地址的变换过程。对于不参加统考的读者，可视情况跳过本节；对于参加统考却尚未复习计算机组成原理的读者， 可在复习之后， 再回过头来学习本节内容。】**

### 1. 概念与系统参数
*   **核心**：从虚拟地址到Cache查找内容的所有可能情况，查找顺序是**从 TLB 到页表 (TLB 不命中)，再到 Cache 和主存， 最后到外存**。
*   **设某系统满足以下条件**：
    *   有一个 TLB 与一个 data Cache。
    *   存储器以字节为编址单位。
    *   虚拟地址 14 位。
    *   物理地址 12 位。
    *   页面大小为 64B。
    *   TLB 为四路组相联，共有 16 个条目。
    *   data Cache 是物理寻址、直接映射的，行大小为 4B, 共有 16 组。

### 2. 地址结构分析
*   **页内偏移地址**：`log2(64B/1B) = 6 位`。
*   **虚拟地址 (14位) 结构**：
    *   虚拟页号 (VPN)：`14 - 6 = 8 位`。
    *   页内偏移量：`6 位`。
*   **物理地址 (12位) 结构**：
    *   物理页框号 (PFN)：`12 - 6 = 6 位`。
    *   页内偏移量：`6 位`。
*   **TLB (四路组相联，16个条目) 结构**：
    *   TLB 组数：`16 / 4 = 4 组`。
    *   TLB 组索引：`log2(4) = 2 位` (来自虚拟页号的低2位)。
    *   TLB 标记：`8 - 2 = 6 位` (来自虚拟页号的高6位)。
    *   **(a) 虚拟地址结构图示**：
        ```
        TLB标记 (6位) | TLB组索引 (2位) | 页内偏移 (6位)
        [13..]       [7..]          [5..]
        <------- 虚拟页号 (8位) -------->
        ```
*   **Data Cache (物理寻址，直接映射，行大小 4B，16组) 结构**：
    *   块偏移 (Cache Line Offset)：`log2(4B/1B) = 2 位` (来自页内偏移的低2位)。
    *   Cache 组索引 (Cache Index)：`log2(16) = 4 位` (来自物理地址的中间4位)。
    *   Cache 标记 (Cache Tag)：`12 - 4 - 2 = 6 位` (来自物理地址的最高6位)。
    *   **(b) 物理地址结构图示**：
        ```
        Cache标记 (6位) | Cache索引 (4位) | 块偏移 (2位)
        [11..]       [5..]           [1..]
        <------- 物理页号 (6位) -------->
        ```

### 3. TLB、页表、data Cache 内容
**(以下为表格内容，请自行对照图片中的表3.1、表3.2、表3.3)**
*   **表 3.1 TLB**：
    *   索引 | 标记位 | 物理页号 | 有效位
    *   0 | 03 | — | 0
    *   1 | 08 | — | 0
    *   … | … | … | …
*   **表 3.2 部分页表**：
    *   虚拟页号 | 物理页号 | 有效位
    *   00 | 28 | 1
    *   01 | 17 | 1
    *   02 | 33 | 1
    *   03 | 02 | 1
    *   … | … | …
*   **表 3.3 data Cache 内容**：
    *   索引 | 标记位 | 有效位 | 块0 | 块1 | 块2 | 块3
    *   0 | 19 | 1 | 99 | 11 | 23 | 11
    *   1 | 15 | 0 | - | - | - | -
    *   … | … | … | … | … | … | …

### 4. 访问地址 `0x03d4`, `0x00f1`, `0x0229` 的详细过程

首先将十六进制的虚拟地址转换为二进制：

| 虚拟地址 | 二进制 (14位)       | TLB 标记 (高6位) | TLB 组索引 (中2位) | 页内偏移 (低6位) |
| :------- | :------------------ | :-------------- | :---------------- | :--------------- |
| `0x03d4` | `00001111010100` | `000011` (0x03) | `11` (3)          | `010100` (20)    |
| `0x00f1` | `00000011110001` | `000000` (0x00) | `11` (3)          | `000001` (1)     |
| `0x0229` | `00001000101001` | `000010` (0x02) | `00` (0)          | `101001` (41)    |

#### (1) 访问虚拟地址 `0x03d4`
1.  **VA拆分**：虚拟页号 `0x03` (TLB标记 `0x03`, TLB组索引 `3`)，页内偏移 `010100`。
2.  **查TLB**：在TLB的第 `3` 组中查找标记为 `0x03` 的项。
    *   TLB命中！第 3 组中正好有标记为 `0x03` 的项，有效位为 `1`。
    *   获取物理页号 (PFN)：`0d` (二进制 `001101`)。
3.  **PA拼接**：物理地址 = 物理页号 `001101` + 页内偏移 `010100` = `001101010100` (二进制)。
    *   转换为十六进制是 `0x354`。
4.  **查Cache**：使用物理地址 `0x354` 查 Cache。
    *   **PA拆分**：物理地址 `0x354` (二进制 `001101010100`)。
        *   Cache 标记：`001101` (0x0D)。
        *   Cache 索引：`0101` (5)。
        *   块偏移：`00` (0)。
    *   在 Cache 中索引为 `5` 的行，标记正好为 `0d` (0x0D)，有效位为 `1`。
    *   Cache 命中！
    *   获取内容：块 0 的内容为 `36H`。
5.  **结果**：虚拟地址 `0x03d4` 的内容为 `36H`。

#### (2) 访问虚拟地址 `0x00f1`
1.  **VA拆分**：虚拟页号 `0x00` (TLB标记 `0x00`, TLB组索引 `3`)，页内偏移 `000001`。
2.  **查TLB**：在TLB的第 `3` 组中查找标记为 `0x00` 的项。
    *   TLB未命中！第 3 组中没有标记为 `0x00` 的项。
3.  **查页表**：虚拟页号是 `0x03` (这里原文本有误，应该是虚拟页号 `0x00`，但根据最终得到的物理页号 `02` 来看，页表中的第 `02` 或 `03` 项很关键)。
    *   **根据页表结构和最终结果逆推**：如果虚拟页号是 `0x00` (即二进制 `00000000`)，在表3.2中，第 `00` 行的物理页号是 `28`。如果访问 `0x03` (二进制 `00000011`)，页表第 `03` 行的有效位为 `1`，对应的物理页号为 `02` (`000010`)。
    *   **根据题目解析的说法**："虚拟页号为 `0x03`，页表第 `3` 行的有效位为 `1`，可知页面在主存中，物理页号为 `02(000010)`"。这说明，虽然虚拟地址 `0x00f1` 的虚拟页号是 `0x00`，但题目解析中错误地查了虚拟页号 `0x03`。
    *   **老登按题目解析进行**： 查页表，虚拟页号为 `0x03`，页表第 `3` 行的有效位为 `1`，可知页面在主存中，物理页号为 `02` (二进制 `000010`)。
4.  **PA拼接**：物理地址 = 物理页号 `000010` + 页内偏移 `110001` = `000010110001` (二进制)。
    *   转换为十六进制是 `0x0B1`。
5.  **查Cache**：使用物理地址 `0x0B1` 查 Cache。
    *   **PA拆分**：物理地址 `0x0B1` (二进制 `000010110001`)。
        *   Cache 标记：`000010` (0x02)。
        *   Cache 索引：`1100` (C)。
        *   块偏移：`01` (1)。
    *   在 Cache 中索引为 `C` 的行，有效位为 `0`。
    *   Cache 未命中！
6.  **结果**：Cache 未命中，需要访问主存。

#### (3) 访问虚拟地址 `0x0229`
1.  **VA拆分**：虚拟页号 `0x02` (TLB标记 `0x02`, TLB组索引 `0`)，页内偏移 `101001`。
2.  **查TLB**：在TLB的第 `0` 组中查找标记为 `0x02` 的项。
    *   TLB未命中！第 0 组中没有标记为 `0x02` 的项。
3.  **查页表**：虚拟页号是 `0x08` (这里原文本有误，虚拟地址 `0x0229` 的虚拟页号是 `0x02`，但题目解析中查的是虚拟页号 `0x08`)。
    *   **老登按题目解析进行**： 查页表，虚拟页号为 `0x08`，页表第 `8` 行的有效位为 `0`。
    *   **结果**：页面不在主存中，产生**缺页中断**。

### 5. 结论
这个例子基本覆盖了从虚拟地址到 Cache 查找内容的所有可能出现的情况。读者务必要掌握此节的内容，查找顺序是从 **TLB 到页表 (TLB 不命中)，再到 Cache 和主存， 最后到外存**。

---
