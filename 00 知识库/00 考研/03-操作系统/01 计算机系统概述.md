---
科目: "408"
课程名称: 操作系统
tags: [操作系统]
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度:
考频:
备注:
---

# 01 计算机系统概述
## 01-1 操作系统的基本概念

### 1.1.1 操作系统的概念

操作系统（Operating System，简称 OS）是配置在计算机硬件上的**第一层软件**，也是对硬件系统的**首次扩充**。它作为计算机系统中最基本的系统软件，肩负着**管理和控制计算机的硬件和软件资源**的重任，同时还要为用户提供一个**友好、方便的接口和运行环境**。

### 1.1.2 操作系统的功能和目标
**主要功能 (职责)：**
1.  **处理机管理 (CPU管理)**：
    *   **管什么**：负责 CPU 的分配、调度和回收，确保多个程序能合理、高效地共享 CPU 资源。
    *   **白话**：你的电脑里 CPU 有限，但同时运行着众多程序。操作系统就是那个"交通警察"，决定哪个程序现在可以用 CPU，用多久，用完了给谁。
    *   **对应后续章节**：[[02 进程与线程]]
2.  **存储器管理 (内存管理)**：
    *   **管什么**：负责内存的分配、回收、地址映射和保护，以高效利用有限内存并保障程序运行安全。
    *   **白话**：内存是程序运行的"临时住所"。操作系统要确保每个程序都有足够的空间，而且不能互相踩踏，还要想办法让程序觉得内存很大（虚拟内存）。
    *   **对应后续章节**：[[03 内存管理]]
3.  **文件管理**：
    *   **管什么**：负责文件的存储、检索、共享、保护和目录管理，确保数据持久化和易于访问。
    *   **白话**：你辛辛苦苦写的文件、下载的电影，都得好好保存起来。操作系统就是那个"档案管理员"，帮你把文件分门别类放好，你想找的时候能快速找到，还能设置权限，不让别人随便看。
    *   **对应后续章节**：[[04 文件管理]]
4.  **设备管理 (I/O管理)**：
    *   **管什么**：负责 I/O 设备的分配、回收、控制和缓冲，协调设备与 CPU/内存之间的数据交换。
    *   **白话**：键盘、鼠标、打印机、显示器、硬盘……这些都是 I/O 设备。操作系统就是它们的"协调员"，确保它们能正常工作，而且能和 CPU、内存顺畅地交换数据。
    *   **对应后续章节**：[[05 输入输出管理]]

5.  **作为用户与计算机硬件之间的接口**：
    *   **命令接口 (作业管理)**：
        *   **联机命令接口 (交互式命令接口)**：用户通过键盘输入命令，系统立即响应（如 Shell、命令行界面）。
        *   **脱机命令接口 (批处理命令接口)**：用户提交批处理作业（脚本），系统自动按序执行。
        *   **管什么**：负责用户提交的作业（任务）的组织、调度和控制。
        *   **白话**：早期计算机用户提交的是"作业"（如运行一个程序）。操作系统管理这些作业的执行顺序。现在虽然"作业"概念不常提，但其思想融入到了进程管理中。
    *   **程序接口 (系统调用)**：用户程序通过**系统调用**间接请求操作系统为其提供服务，如使用外部设备、申请内存、创建进程等。

6.  **对硬件机器的扩展**：操作系统通过软件层对硬件进行抽象和扩充，使得用户程序无需关心硬件细节。

**主要目标 (KPI)：**
1.  **方便性**：让用户更容易、更高效地使用计算机。
2.  **有效性**：提高系统资源的利用率（CPU、内存、I/O 设备不能闲着，要充分利用）和系统吞吐量。
3.  **可扩充性**：方便增加新功能、新硬件，系统能够不断升级和发展。
4.  **开放性**：遵循国际标准，方便不同系统之间的互联互通和软件移植。

### 1.1.3 操作系统的特征
1.  **并发性 (Concurrency)**：
    *   **概念**：指宏观上在一段时间内有多道程序在**交替执行**，使得它们看起来像在"同时运行"。但微观上，在单处理器系统中，任何时刻只有一个程序在执行。
    *   **白话**：你的电脑好像同时开了微信、QQ、浏览器，它们都在"跑"。但如果你的电脑只有一个 CPU，那其实 CPU 在它们之间快速切换，轮流为它们服务，速度太快了，你感觉不到而已。
    *   **与并行性 (Parallelism) 的区别**：
        *   **并发性**是"假同时"，指多个事件在同一时间**间隔**内发生。
        *   **并行性**是"真同时"，指多个事件在**同一时刻**真正地同时发生（需要多处理器或多核 CPU）。
    *   **重要性**：并发性是操作系统最重要的特征之一，也是区分操作系统与普通程序的根本标志。

2.  **共享性 (Sharing)**：
    *   **概念**：指系统中的资源（如 CPU、内存、打印机、文件等）可以被多个并发执行的进程**共同使用**。
    *   **白话**：你的打印机只有一台，但你和你的室友都可以用它来打印。操作系统就是那个协调者，让大家都能用，但又不会互相打架。
    *   **两种共享方式**：
        *   **互斥共享**：资源在一段时间内只能被一个进程**独占**使用（如打印机、一次只能访问的临界区数据）。
        *   **同时共享**：资源在一段时间内可以被多个进程**宏观上同时**使用（如硬盘上的文件，通过分时复用）。
    *   **与并发性关系**：**只有并发才能共享，没有并发就没有共享。** 共享是并发的前提，并发是共享的条件。

3.  **虚拟性 (Virtuality)**：
    *   **概念**：指操作系统通过某种技术，把一个物理实体变成若干个逻辑上的对应物，向用户提供抽象的、更丰富的资源。
    *   **白话**：你的电脑可能只有 8GB 内存，但你打开的程序加起来可能需要 16GB 内存。操作系统通过"虚拟内存"技术，让你感觉自己有无限大的内存。再比如，一个物理 CPU，通过分时技术，让多个用户感觉自己独占一个 CPU（虚拟处理器）。
    *   **实现方式**：
        *   **时分复用**：将一个物理设备（如 CPU）分时提供给多个用户，形成多个**虚拟设备**（如虚拟处理器）。
        *   **空分复用**：将一个物理设备（如磁盘空间）划分为多个部分提供给多个用户，形成多个**虚拟设备**（如虚拟磁盘）。

4.  **异步性 (Asynchronism)**：
    *   **概念**：指进程的执行不是一气呵成的，而是走走停停，以**不可预知**的速度向前推进。
    *   **白话**：你的程序在运行过程中，可能会因为等待 I/O 操作（比如读硬盘）、等待 CPU 调度、等待其他资源而暂停。它什么时候能继续运行，你无法精确预测。
    *   **重要性**：异步性是操作系统并发性的必然结果，也是其设计复杂性的体现。

---

## 01-2 操作系统的发展历程

主公，操作系统的发展史，就是一部计算机效率不断提升、功能不断强大的演变史。

### 1.2.1 手工操作阶段
*   **特点**：**没有操作系统**。用户直接操作硬件。
*   **流程**：用户把程序和数据（通常在纸带或卡片上）手动送到计算机，机器执行完再手动取走结果。
*   **缺点**：**效率极低**，CPU 大量时间空闲，人机速度矛盾突出。

### 1.2.2 批处理阶段
*   **目的**：提高 CPU 利用率，解决人机速度矛盾。
*   **特点**：引入了**监督程序 (Monitor)**，这是操作系统的雏形。用户提交的作业先存到外存，监督程序自动按批次执行，减少人工干预。
*   **分类**：
    *   **单道批处理系统**：
        *   **特点**：内存中只允许一道程序运行。CPU 和 I/O 设备轮流工作，但总有一个闲着，导致资源利用率依然不高。
        *   **优点**：缓解了一定程度的人机速度矛盾，资源利用率有所提升。
        *   **缺点**：**内存中只能容纳一道程序**，CPU 和 I/O 设备无法并行工作，系统吞吐量受限。
    *   **多道批处理系统 #多道系统 (重要！)**：
        *   **特点**：**内存中同时存放多道程序。** 当一道程序等待 I/O 时，CPU 可以切换到另一道程序执行，实现 CPU 和 I/O 设备的并行工作（宏观并行，微观串行）。
        *   **优点**：显著提高了 CPU 和 I/O 设备的利用率，系统吞吐量大。
        *   **缺点**：**缺少交互性 (考点: 批处理系统的缺点)**：用户不能直接与程序交互，作业周转时间长，不便于调试。

### 1.2.3 分时操作系统
*   **目的**：满足用户对**交互性**的需求。
*   **特点**：采用**时间片轮转 (Round Robin)** 的方式，将 CPU 的时间分成很小的时间片，轮流分配给多个用户。每个用户都感觉自己独占一台计算机。
*   **主要特性**：**同时性、交互性、独立性、及时性。**
*   **优点**：提供了人机交互能力，多用户共享系统，系统资源利用率进一步提高。
*   **缺点**：**不能优先处理一些紧急任务**，响应时间可能较长，不适合实时控制。
*   **考点**：时间片轮转、交互性。

### 1.2.4 实时操作系统 (RTOS)
*   **目的**：及时响应外部事件，在某个时间限制内完成某些**紧急任务**，强调**实时性**和**可靠性**，而不需要排队。
*   **特点**：
    *   **实时性**：对任务的响应时间有严格要求。
    *   **可靠性**：系统必须高度稳定，不允许出现错误。
    *   **可预测性**：任务执行的时间必须是可预测的。
*   **分类**：
    *   **硬实时系统 (Hard Real-time System)**：必须在严格的截止时间前完成任务，否则可能导致灾难性后果（如导弹控制系统、工业控制）。
    *   **软实时系统 (Soft Real-time System)**：允许偶尔超出截止时间，但最好能及时完成，性能下降但不会造成系统崩溃（如多媒体播放系统、在线交易）。
*   **考点**：实时性的概念，硬实时与软实时的区别。

### 1.2.5 网络操作系统和分布式计算机系统
*   **网络操作系统**：管理网络资源，提供网络服务（如文件共享、打印共享、远程登录）。
*   **分布式计算机系统**：多个独立的计算机通过网络连接，共同完成一个任务，用户感觉像在使用一台机器，具有高可用性、可伸缩性。

### 1.2.6 个人计算机操作系统
*   **特点**：强调易用性、图形用户界面（GUI），如 Windows、macOS、Linux 等，为单用户提供强大的桌面应用。

---

## 01-3 操作系统的运行环境

主公，操作系统要在计算机上"跑起来"，并保证安全稳定，就必须依赖于特定的运行环境和机制。

### 1. 处理器运行模式 (CPU 的工作模式)

**目的**：保护操作系统和关键数据不被用户程序破坏，实现系统的安全性和稳定性。

*   **特权指令 (Privileged Instruction)**：
    *   **定义**：不允许用户程序直接修改或执行的指令。这些指令直接访问或修改敏感硬件资源（如 I/O 设备、内存保护寄存器、中断控制器）或改变 CPU 运行状态。
    *   **示例**：I/O 指令、关中断指令、内存清零指令、修改程序状态字寄存器（PSW）的指令、存取用于内存保护的寄存器等的指令。
    *   **考点**：Q20 (2014), Q28 (2021)
*   **非特权指令 (Non-privileged Instruction)**：
    *   **定义**：用户程序可以直接使用的指令，不会直接访问系统中的敏感硬件资源或影响系统安全，仅限于访问用户的地址空间和执行普通运算。
    *   **示例**：普通的算术/逻辑指令、跳转指令、压栈指令、数据传送指令（访问用户内存）。
    *   **考点**：Q30 (2022)

操作系统通过硬件支持（如 CPU 的特权级寄存器）实现两种工作模式：

1.  **内核态 (Kernel Mode / 管态 / 特权态 / 核心态)**：
    *   **权限**：**最高权限**。CPU 可以执行**所有指令**（包括特权指令和非特权指令），访问所有内存和硬件资源。
    *   **运行实体**：执行**操作系统内核代码**（如进程调度、中断/异常处理、系统调用服务例程、内存管理器、设备驱动程序）。
    *   **白话**：操作系统是"管理员"，它在内核态下拥有"最高权限"，可以随意操作硬件，保障系统安全。
    *   **考点**：Q16 (2011), Q17 (2012), Q19 (2013), Q22 (2015), Q26 (2019-I), Q30 (2022), Q33 (2024-A, C)

2.  **用户态 (User Mode / 目态 / 普通态)**：
    *   **权限**：**受限权限**。CPU **只能执行非特权指令**，只能访问本进程的内存空间，不能直接访问硬件。
    *   **运行实体**：执行**应用程序**（如命令解释程序 Shell、浏览器、游戏），以及库函数调用（如 `sino`）。
    *   **白话**：你的微信、游戏这些应用是"普通用户"，它们在用户态下权限受限，不能直接操作硬件，也不能访问其他程序的内存，这样就保证了系统的安全和稳定。
    *   **考点**：Q16 (2011), Q17 (2012), Q19 (2013), Q22 (2015), Q30 (2022)

**模式切换**：

*   **用户态 → 内核态**：**【考点: Q19 (2013), Q22 (2015), Q24 (2017), Q31 (2022-IV), Q33 (2024-A)】**
    *   只能通过**中断、异常、系统调用（陷阱）**这三种**受控**的方式进入。这是用户态程序主动或被动进入内核态的**唯一合法入口**。
*   **内核态 → 用户态**：
    *   通过设置程序状态字（PSW）的标志位来切换。通常在操作系统处理完事件后，通过**特权指令**切换回用户态，将 CPU 控制权交还给用户程序。

大部分操作系统的**内核**通常包括以下四方面的内容：
1.  时钟管理
2.  中断机制
3.  **原语 (Primitive)**：原子操作，不可中断。
4.  系统控制的数据结构及处理

### 2. 中断和异常的概念
**【考点: Q23 (2016), Q33 (2024)】**
中断和异常是操作系统接管 CPU 控制权、处理突发事件或错误的关键机制。

*   **中断 (Interrupt)**：**【考点: Q17 (2012), Q23 (2016-A, C), Q25 (2018), Q27 (2020), Q33 (2024-A, C, D)】**
    *   **概念**：来自 **CPU 外部的事件**（如 I/O 设备完成操作、定时器到期、键盘鼠标输入、网络数据包到达、电源故障等）触发的信号，导致 CPU 暂停当前执行的程序，转去处理这些突发事件。
    *   **特性**：**异步性**。中断的发生与当前 CPU 正在执行的指令无关，是**不可预测**的。
    *   **示例**：时钟中断、I/O 完成中断、键盘鼠标输入。
    *   **处理流程**：
        1.  **硬件检测**并向 CPU 发送中断信号。
        2.  CPU 暂停当前程序，**进入内核态 (Q33-C)**。
        3.  执行**中断处理程序**（由操作系统内核提供，**Q27-II**）。
        4.  处理完毕后，**切换回用户态**，恢复被中断的程序执行。

*   **异常 (Exception) / 陷阱 (Trap) (内中断)**：**【考点: Q19 (2013-I), Q23 (2016-B, D), Q33 (2024-A)】**
    *   **概念**：来自 **CPU 内部的事件**（通常是当前正在执行的指令所引发的错误或特殊情况，或用户程序主动发起的请求），导致 CPU 暂停当前执行的程序，转去处理这些事件。
    *   **特性**：**同步性**。异常的发生与当前 CPU 正在执行的指令**直接相关**，是**可预测**的。
    *   **常见类型**：
        *   **故障 (Fault)**：可恢复的错误，如**缺页中断 (Page Fault) (Q16-B, Q17-D, Q23-A)**、除零错误 **(Q19-I, Q23-B)**、存储保护错 **(Q23-D)**。处理完后通常可以返回到引发异常的指令**重新执行**。
        *   **陷阱 (Trap)**：有意为之的特殊事件，如**系统调用**（通过 `INT n` 或 `syscall` 指令触发）。处理完后返回到引发陷阱的指令的**下一条指令**执行。
        *   **终止 (Abort)**：不可恢复的严重错误，如硬件故障。通常导致程序或系统终止。
    *   **处理流程**：
        1.  当前执行的指令引发错误或特殊情况。
        2.  CPU 暂停当前程序，**进入内核态 (Q33-A)**。
        3.  执行**异常处理程序**（由操作系统内核提供）。
        4.  根据异常类型，可能返回原指令重试，或返回下一指令，或终止程序。

### 中断处理 vs. 子程序调用
**【考点: Q18 (2012), Q21 (2015), Q31 (2022)】**

| **特征**             | **中断处理 (Interrupt Handling)**                                                                                    | **子程序调用 (Subroutine Call)**                                                                  |
| :------------------- | :------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------- |
| **1. 触发方式**      | 硬件或软件**突发事件**引起，具有**随机性、异步性**。                                                                 | 通过**调用指令 (如 `CALL` 指令)** 显式触发，是由程序员**事先安排**好的。                            |
| **2. 与当前程序关系** | **独立性**：中断处理程序与被中断的当前程序是相互独立的两个任务，没有确定的主从关系。                                 | **主从关系**：子程序是被主程序"调用"和"控制"的，它们是同一程序的两个组成部分。                    |
| **3. 发生时机**      | **随机**：中断在 CPU 允许中断的任意时刻都可能发生，不可预测。                                                        | **预定**：在程序执行到 `CALL` 指令时发生，可预测，由程序流程决定。                                  |
| **4. 实现方式**      | **软硬件协同**：需要专门的**硬件电路**（中断控制器）来检测、响应、屏蔽中断，并生成中断向量地址。                   | **纯软件实现**：通过指令集中的调用指令完成，是程序控制结构的一部分。                              |
| **5. 入口地址获取**  | **硬件向量法**：由硬件（或中断控制器）根据中断类型**自动产生**中断向量地址（或向量号），系统再根据向量地址找到中断处理程序的入口地址。 | **指令给出**：子程序的入口地址直接由 `CALL` 指令的**地址码字段**给出。                          |
| **6. 现场保护**      | 需要保护 CPU 现场（如 **PC、PSW (Q18-B)、通用寄存器 (Q21-B, Q31-II)** 等）。通常由**中断隐指令**（硬件自动执行）或中断处理程序的起始部分**软件保存**。 | 需要保护主程序的返回地址（**PC (Q31-I)**）。通常由 `CALL` 指令自动完成（将 PC 值压栈）。PSW 通常不需要自动保存 **(Q18-B)**；其他通用寄存器由软件按需保护。 |
| **7. 返回方式**      | 通过**中断返回指令 (如 `IRET`, `RETF`)** 返回到被中断的程序继续执行。                                               | 通过**子程序返回指令 (如 `RET`)** 返回到调用它的指令的下一条指令处继续执行。                   |
| **8. 中断裁决**      | 当多个中断请求同时发生时，需要由**硬件中断控制器**进行优先级判断和**中断裁决**。                                     | 调用子程序时，**没有**这种裁决过程。                                                          |
| **9. 嵌套关系**      | 可以嵌套。优先级高的中断可以中断优先级低的中断处理程序。                                                         | 可以嵌套。子程序可以调用其他子程序。                                                        |
| **10. 目的**         | 应对突发事件、提高 CPU 利用率、实现并发处理、处理异常。                                                            | 模块化程序设计、代码复用、简化程序结构。                                                    |

*   **中断隐指令 (Interrupt Microinstruction)**：
    *   这是 CPU 响应中断时**硬件自动执行**的一系列操作，不为程序员所见。
    *   主要包括：**关中断**（防止更低优先级中断干扰）、**保存 PC 值**（通常压栈，**Q31-I**）、**获取中断服务程序入口地址**（通过中断向量表），并**将该地址装入 PC**。
*   **现场保护与恢复**：
    *   **中断**：通常需要保护的现场包括 **PC (Q31-I)**、**PSW (Q18-B, Q31-I)**，以及中断服务程序可能修改的**通用寄存器 (Q21-B, Q31-II)**。这些工作一部分由硬件隐指令完成，一部分由中断服务程序开头部分的操作系统代码（通过 `PUSH` 指令）完成。
    *   **子程序**：`CALL` 指令通常只负责将当前的 `PC`（即返回地址）压入栈中。其他寄存器（如通用寄存器）的保护由子程序自己决定，通过 `PUSH`/`POP` 指令完成。

### 3. 系统调用 (System Call )
**【考点: Q17 (2012), Q19 (2013-III), Q24 (2017), Q26 (2019), Q29 (2021), Q31 (2022), Q33 (2024-B, D)】**

*   **定义**：是用户程序**主动**请求操作系统内核提供服务的接口。它通过执行特殊的陷阱指令（`trap`, `INT n` 或 `syscall`）触发一个内部事件，从而从用户态切换到内核态，让操作系统为它提供特权服务。
*   **本质**：系统调用是一种**特殊的异常（陷阱）**。用户程序通过执行一条特殊的指令（如 `trap` 指令 **(Q20-A, Q22-A, Q28-A)**、软中断指令 `INT n` **(Q22-B)** 或 `syscall` 指令），故意引发一个"陷阱"来进入内核态。
*   **特性**：
    *   **主动性**：由用户程序**主动发起**。
    *   **同步性**：其发生与用户程序指令**直接相关**。
    *   **是用户态程序进入内核态的唯一合法（主动）途径 (Q26-II, Q26-IV)**。
*   **系统调用的功能 (Q29-C)**：
    *   **设备管理**：如读写设备。
    *   **文件管理**：如创建文件、删除文件、读写文件。
    *   **进程控制**：如创建进程、终止进程、加载程序。
    *   **进程通信**：如管道通信、消息队列。
    *   **内存管理**：如申请内存、释放内存。

*   **系统调用实现机制 (Q24, Q31)**：
    1.  **用户态程序执行陷入指令**：这是发起系统调用的入口。
    2.  **CPU 硬件响应，将 CPU 模式改为内核态 (Q24-④, Q31-IV)**：执行陷入指令后，CPU 硬件会自动完成模式切换。
    3.  **操作系统内核保存现场 (Q24-③, Q31-I, Q31-II)**：进入内核态后，硬件和操作系统内核程序保护中断进程的现场，将**程序计数器（PC）、程序状态字（PSW）及通用寄存器**内容等压入栈堆。
    4.  **检查参数合法性 (Q24-②)**：分析系统调用类型，转入相应的系统调用处理子程序。操作系统在系统中配置了一张**系统调用入口表**（或系统调用分派表），表中的每个表项都对应一个系统调用，根据系统调用号可以找到该系统调用处理子程序的入口地址。
    5.  **执行相应的服务程序 (Q24-⑤, Q31-III)**：参数合法后，执行实际的系统调用功能 **(Q26-I, Q33-B)**。
    6.  在系统调用处理子程序执行结束后，恢复被中断的或设置新进程的 CPU 现场，然后返回被中断进程或新进程，继续往下执行。

*   **硬件 (CPU) 在中断/异常/系统调用中的职责**：
    *   检测中断/异常信号。
    *   响应中断/异常/系统调用，**自动**切换 CPU 模式（用户态→内核态） **(Q24-④, Q31-IV)**。
    *   **自动保存最基本的现场**（如 PC、PSW）**(Q31-I)**。
    *   通过中断控制器等，提供中断向量表的索引。
*   **操作系统 (OS) 软件 在中断/异常/系统调用中的职责 (Q27, Q31)**：
    *   **编写和提供**中断/异常/系统调用**服务程序 (Q27-II, Q31-III)**。
    *   **初始化中断向量表 (Q27-III, Q32-A)**。
    *   **保存**除硬件自动保存之外的**其他现场**（如通用寄存器）** (Q27-I, Q31-II)**。
    *   **检查系统调用参数合法性**。
    *   执行实际的**服务功能**。
    *   在处理完毕后，**恢复现场**并切换回用户态。
    *   **系统添加新类型设备时，需要注册相应的中断服务例程 (Q33-D)**。

*   **系统调用 vs 库函数**：用户程序与操作系统的"沟通方式"

| 特征       | 系统调用 (System Call)                               | 库函数 (Library Function)                                    |
| :--------- | :--------------------------------------------------- | :----------------------------------------------------------- |
| **调用者** | 用户程序直接请求操作系统服务                       | 用户程序调用，通常是对系统调用的封装或纯计算操作           |
| **执行模式** | **内核态** (需要模式切换)                            | **用户态** (大部分时间在用户态执行，无需模式切换)            |
| **权限**   | **特权操作**，可直接操作硬件和管理资源               | **非特权操作**，不能直接操作硬件                             |
| **开销**   | **大** (涉及用户态/内核态切换)                       | **小** (大部分在用户态，无模式切换开销)                      |
| **数量**   | **少** (几十到几百个)                                | **多** (成千上万个)                                          |
| **封装性** | 操作系统提供的底层接口                               | 对系统调用或其他功能的**高级封装** (如 `printf()` 封装了 `write()` 系统调用) |
| **可移植性** | 依赖于操作系统，可移植性差                           | 跨平台性好（若无系统调用），可移植性强                       |
| **目的**   | 提供操作系统核心服务，保护系统安全                   | 方便程序员编程，提高开发效率                                 |

### 4. 操作系统结构
不同的结构模式会影响系统的效率、可靠性和可维护性。
1.  **分层结构 (Layered Structure)**：
    *   **特点**：将操作系统功能按层次划分，每层只能调用其直接**下层**提供的服务（单向依赖）。
    *   **优点**：
        *   便于系统的**调试和验证**，简化了系统的设计和实现。
        *   **易扩充和易维护**。在系统中增加、修改或替换一层中的模块或整层时，只要不改变相应层间的接口，就不会影响其他层。
    *   **缺点**：设计时要求严格的层次划分，效率可能降低（数据传输需要经过多层）。

2.  **模块化结构 (Modular Structure)**：
    *   **特点**：将操作系统功能划分为相对独立的模块，模块之间通过明确定义的**接口**进行调用（模块之间可以相互调用）。
    *   **优点**：
        *   设计灵活，易于理解和实现。
        *   易于扩展和维护。
        *   效率相对较高（因为没有严格的单向层次限制）。
    *   **缺点**：模块间的依赖关系可能复杂，管理不当易出错。

3.  **大内核 (Monolithic Kernel)**：
    *   **特点**：操作系统所有功能模块（进程管理、内存管理、文件系统、设备驱动、网络协议栈等）都**紧密集成**在一个大的内核中，**全部运行在内核态**。
    *   **优点**：
        *   **效率高**，模块间通信开销小（都是内核态内部函数调用）。
        *   系统性能好。
    *   **缺点**：
        *   结构复杂庞大，难以调试、维护和扩展。
        *   **可靠性低**：一个模块出错可能导致整个系统崩溃。
    *   **代表**：早期 UNIX、Linux。
    *   **考点**：**大内核与微内核的优缺点对比**。

4.  **微内核 (Microkernel)**：
    *   **特点**：只有最基本的核心功能（如**进程间通信、低级内存管理、中断处理**）在内核态运行，其他大部分操作系统服务（如文件系统、设备驱动程序、网络协议栈、内存管理的高级功能）都作为独立的**服务器进程运行在用户态**。
    *   **优点**：
        *   **结构清晰**，易于调试、维护和扩展（模块在用户态崩溃不影响内核）。
        *   **可靠性高**：大部分服务在用户态运行，一个模块崩溃不影响整个内核，系统更稳定。
        *   **可移植性好**（内核代码量小、与硬件相关性降低）。
        *   支持**分布式计算**（用户态的服务可以更方便地部署在不同机器上）。
    *   **缺点**：
        *   **性能（效率）可能较低**：用户态和内核态切换频繁，进程间通信开销大（尤其在请求服务时）。
    *   **代表**：Mach、QNX。
    *   **考点**：**大内核与微内核的优缺点对比**。

5.  **外核 (Exokernel)**：
    *   **特点**：是一种**极简内核**。它只负责资源的保护和复用（确保安全隔离），而将**硬件抽象和资源管理的大部分细节交给用户态程序（应用）**来完成。
    *   **目的**：让用户程序可以更灵活、高效地直接管理物理资源，避免内核的过度抽象带来的性能损失。
    *   **应用**：多用于为**虚拟机**分配资源，并检查这些资源使用的安全性，以确保没有机器会使用他人的资源。

## 01-5 操作系统引导

主公，计算机开机后，操作系统是如何一步步加载并运行起来的？这就像一场精心策划的"接力赛"！

*   **概念**：计算机通电后，经过一系列硬件自检和程序加载，最终将操作系统的核心部分（内核）加载到内存中，并启动系统。
*   引导程序通常分为两种：
    *   **自举程序 (Bootstrap Program)**：这是计算机通电后，CPU执行的**第一个程序**，通常固化在主板的 **BIOS/UEFI 芯片**中。它的任务是初始化硬件，然后**找到并加载操作系统的引导程序**。
    *   **操作系统的引导程序 (Bootloader)**：这是操作系统自己的一部分，由自举程序加载，位于装有操作系统的硬盘的活动分区的引导扇区中（如 GRUB for Linux, Windows Boot Manager）。它的任务是加载操作系统的核心部分（内核）到内存中，并把控制权交给操作系统。

### **第一棒：CPU被激活与固件（BIOS/UEFI）登场**
1.  **CPU通电与复位 (Power-On and Reset)**：按下电源按钮后，CPU被激活并被强制将**程序计数器 (PC)** 指向主板上固件（BIOS/UEFI）的起始地址。
2.  **固件（BIOS/UEFI）启动 (Firmware Initialization)**：CPU 从固件芯片（闪存）中执行指令。
    *   **POST (Power-On Self-Test)**：固件首先执行自检，检查 CPU、内存、显卡等关键硬件是否正常工作。
    *   **硬件初始化**：初始化一些基本的硬件设备（如 USB、SATA）。
    *   **建立中断向量表**：设置一些基本的中断处理程序。
    *   **BIOS** 包括：系统设置程序、基本输入输出程序、开机自检程序、系统启动自检程序。

### **第二棒：寻找并加载操作系统的引导程序 (Bootloader)**
1.  **确定启动设备 (Boot Device Selection)**：固件根据用户在 BIOS/UEFI 设置中配置的**启动顺序**（例如：硬盘、U盘），尝试从第一个设备开始寻找引导程序。
2.  **加载引导程序 (Loading the Bootloader)**：
    *   **传统 BIOS/MBR 模式**：
        *   BIOS 读取选定硬盘的**第一个扇区（MBR - 主引导记录）**。
        *   MBR 中的**引导代码**（512字节）被加载到内存并执行。
        *   MBR 引导代码扫描分区表，找到**活动分区**。
        *   加载活动分区的**引导扇区 (PBR - 分区引导记录)**，这是操作系统的**第二阶段引导程序**。PBR 被加载到内存并执行。
    *   **现代 UEFI/GPT 模式**：
        *   UEFI 固件扫描硬盘上的 **EFI 系统分区 (ESP)**。
        *   UEFI 固件根据启动项配置，找到 ESP 中存储的**操作系统的引导程序文件**（`.efi` 文件）。
        *   UEFI 固件直接将这个 `.efi` 引导程序文件加载到内存中并执行。

### **第三棒：操作系统的引导程序 (Bootloader) 接管**
1.  **引导程序初始化 (Bootloader Initialization)**：控制权完全交给操作系统的引导程序（例如 Windows Boot Manager, GRUB）。
2.  **加载操作系统内核 (Loading the OS Kernel)**：引导程序的核心任务是找到并加载操作系统的**内核文件**（例如 Linux 的 `vmlinuz`，Windows 的 `ntoskrnl.exe`）到内存中。它还会加载一些必要的驱动程序和初始化文件系统。
3.  **将控制权交给内核 (Handing Over to the Kernel)**：一旦内核被加载到内存，引导程序就会将 CPU 的控制权**跳转**到内核的入口点。

### **第四棒：操作系统内核启动 (OS Kernel Startup)**
1.  **内核初始化 (Kernel Initialization)**：内核开始执行，进行更全面的硬件检测和初始化。
    *   设置内存管理单元 (MMU)，建立**虚拟内存**系统。
    *   初始化进程调度器、文件系统、设备驱动程序等核心组件。
    *   创建第一个用户态进程（通常是 `init` 或 `systemd` 进程，PID为1）。
2.  **启动用户态服务 (Starting User-Space Services)**：内核启动 `init` 进程后，`init` 进程会负责启动其他所有的用户态服务和守护进程（如网络服务、图形界面服务等）。
3.  **用户登录与桌面环境 (User Login and Desktop Environment)**：最终，系统会显示登录界面，等待用户输入用户名和密码。用户登录成功后，桌面环境启动，计算机完全进入可用状态。

## 01-6 虚拟机 (Virtual Machine, VM) #虚拟机

*   **概念**：虚拟机技术允许在一台物理计算机（宿主机）上运行多个独立的操作系统实例（客户机）。一台通过软件模拟出来的、拥有完整硬件系统功能的计算机。

1.  **宿主机 (Host Machine)**：
    *   **定义**：就是真实的、物理存在的计算机，提供 CPU、内存、硬盘等所有物理资源。
    *   **宿主操作系统 (Host OS)**：运行在宿主机上的操作系统（如 Windows 10）。
2.  **客户机 (Guest Machine / Virtual Machine)**：
    *   **定义**：通过软件模拟出来的计算机，在其上运行客户操作系统。
    *   **客户操作系统 (Guest OS)**：运行在客户机上的操作系统（如在 Windows 10 里安装的 Ubuntu Linux）。
3.  **虚拟机监控器 (Hypervisor / VMM - Virtual Machine Monitor)**：
    *   **核心技术**：这是最关键的软件层，负责创建、运行和管理虚拟机。它在宿主机和客户机之间充当"翻译官"和"资源分配者"，让客户机以为自己直接在和硬件打交道，但实际上所有对硬件的请求都由 Hypervisor 来协调和转发。
    *   **实现方式**：Hypervisor 通过各种技术来模拟 CPU、内存、I/O 设备：
        *   **CPU 虚拟化**：Hypervisor 会拦截客户操作系统发出的特权指令，并进行模拟或直接转发给物理 CPU 执行。现代 CPU 通常有硬件辅助虚拟化技术（如 Intel VT-x, AMD-V），大大提高了效率。
        *   **内存虚拟化**：Hypervisor 会为每个虚拟机维护一个虚拟地址空间到物理地址空间的映射，确保它们互不干扰。
        *   **I/O 虚拟化**：Hypervisor 会模拟网卡、硬盘控制器等设备，或者通过**半虚拟化 (Paravirtualization)** 技术，让客户操作系统知道自己运行在虚拟机中，从而使用专门的驱动程序直接与 Hypervisor 通信，提高 I/O 性能。
*   **分类**：
    1.  **Type 1 Hypervisor (原生型 / Bare-Metal)**：
        *   **特点**：Hypervisor **直接安装在物理硬件上**，它本身就是个"小操作系统"，然后把硬件资源分给下面的虚拟机。
        *   **优点**：性能高、安全性好、资源开销小。
        *   **应用场景**：主要用于服务器虚拟化、云计算数据中心。
        *   **例子**：VMware ESXi, Microsoft Hyper-V, Xen。
    2.  **Type 2 Hypervisor (寄居型 / Hosted)**：
        *   **特点**：Hypervisor 是作为**宿主操作系统上的一个应用程序**运行的。它像个"App"一样，安装在 Windows 或 macOS 上，然后在这个 App 里再运行其他操作系统。
        *   **优点**：安装和使用简单方便。
        *   **缺点**：性能相对较低，因为多了一层宿主操作系统的开销。
        *   **应用场景**：个人电脑上运行多个操作系统、开发测试环境。
        *   **例子**：VMware Workstation/Fusion, VirtualBox。
*   **优点**：
    1.  **资源利用率最大化 (Server Consolidation)**：一台物理服务器运行多个虚拟机，提高硬件利用率，减少物理服务器数量。
    2.  **隔离性与安全性 (Isolation & Security)**：每个虚拟机独立运行，相互隔离，一个虚拟机故障不影响其他。
    3.  **可移植性 (Portability)**：虚拟机可打包成文件，轻松迁移。
    4.  **开发与测试 (Development & Testing)**：方便模拟不同环境，测试软件兼容性，创建快照进行回滚。
    5.  **遗留应用支持 (Legacy Applications)**：在兼容性问题上提供解决方案。
    6.  **灾难恢复 (Disaster Recovery)**：备份和恢复方便快捷。

---
