---
科目: 
课程名称: 
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度: 
考频: 
备注:
---

## 04 数组

---

## C语言 #基础 #数组 #一维数组 #二维数组 #字符数组 #指针与数组

> [!NOTE] 学习目标
> *   理解数组的定义和作用：存储同类型数据的集合。
> *   掌握一维数组的定义、初始化和元素访问方法。
> *   掌握二维数组（矩阵）的定义、初始化和元素访问方法。
> *   理解数组在内存中的存储方式（连续存储）。
> *   理解数组名与指针的密切关系，掌握通过指针访问数组元素的方法。
> *   掌握字符数组和字符串的概念，以及常用字符串处理函数。
> *   了解数组作为函数参数的传递方式。

### 04-1 数组：同类型数据的"集合管家"

想象一下，你有一个班级，有50个学生，你需要记录他们每个人的C语言成绩。如果定义50个 `int score1, score2, …, score50;` 变量，那真是要累死"老登"了！而且，如果想找出最高分，还得写50个 `if` 比较。

**数组 (Array)** 就是来解决这个问题的"大管家"！它允许你：
* **存储一组** (Collection) **相同数据类型** (Same Data Type) 的数据。
* 这些数据在内存中是**连续存放**的。
* 你可以用**一个统一的名字**来引用这组数据，并通过**下标 (Index)** 来访问组内每一个成员。

所以，数组就是把同类型数据集中管理起来的利器！

### 04-2 一维数组：线性的数据队列

一维数组是最简单的数组形式，它就像一条直线，数据元素一个接一个地排列。

#### 1. 定义和声明

在使用数组之前，必须先定义它，告诉编译器数组的数据类型、数组名以及它能存储多少个元素。

* **语法**：`数据类型 数组名[数组长度];`
    * `数据类型`：数组中每个元素的数据类型（如 `int`, `char`, `float` 等）。
    * `数组名`：你自己给数组起的名字，遵循标识符命名规则。
    * `数组长度`：一个**常量表达式**（必须是正整数），表示数组能存储的元素个数。
* **示例**：

    ```c
    int scores[5];           // 定义一个名为scores的整型数组，可以存储5个整数
    float temperatures[7];   // 定义一个名为temperatures的浮点型数组，可以存储7个浮点数
    char name[20];           // 定义一个名为name的字符型数组，可以存储20个字符
    ```

#### 2. 初始化

定义数组时，可以同时给它赋初始值，这叫数组的初始化。

##### (1) 完全初始化

当提供的初始值数量与数组长度一致时。

```c
int numbers[5] = {10, 20, 30, 40, 50}; // 数组长度为5，提供了5个初始值
```

##### (2) 部分初始化

当提供的初始值数量少于数组长度时，**未被初始化的元素会自动被赋为0** (对于数值类型) 或空字符 `\0` (对于字符类型)。

```c
int ages[5] = {20, 22}; // ages[0]=20, ages[1]=22, ages[2]=0, ages[3]=0, ages[4]=0
float prices[3] = {9.9f}; // prices[0]=9.9f, prices[1]=0.0f, prices[2]=0.0f
```

##### (3) 不指定数组长度 (由编译器推断)

如果定义时提供了初始值，但没有指定数组长度，编译器会根据初始值的数量自动计算数组的长度。

```c
int data[] = {1, 2, 3, 4, 5, 6}; // 编译器会自动推断data数组的长度为6
char letters[] = {'A', 'B', 'C'}; // 编译器推断长度为3
```

##### (4) 初始化为全0 (或全`\0`)

一个常用的技巧是，如果想把整个数组都初始化为0，只需提供一个0即可。

```c
int arr[10] = {0}; // arr中所有10个元素都会被初始化为0
```

> [!WARNING] 未初始化数组的风险
> 如果数组定义后没有初始化，它的元素会包含**随机的"垃圾值"**。使用这些未初始化的值可能导致程序行为异常或崩溃。所以，**尽量在定义时初始化数组！**

#### 3. 访问数组元素

通过数组名和下标来访问数组中的单个元素。

* **语法**：`数组名[下标]`
* **重要概念**：
    * **下标 (Index)**：数组的下标是从**0开始**的，不是1！
    * 如果数组有 `N` 个元素，那么它们的下标范围是 `0` 到 `N-1`。
    * `scores[0]` 访问第一个元素。
    * `scores[N-1]` 访问最后一个元素。
* **示例**：

    ```c
    int numbers[5] = {10, 20, 30, 40, 50};

    printf("第一个元素: %d\n", numbers[0]); // 输出 10
    printf("第三个元素: %d\n", numbers[2]); // 输出 30

    numbers[1] = 25; // 修改第二个元素的值
    printf("修改后的第二个元素: %d\n", numbers[1]); // 输出 25
    ```

#### 4. 数组在内存中的存储

数组的元素在内存中是**连续存放**的。这意味着 `numbers[0]` 和 `numbers[1]` 在内存中是紧挨着的。
* `&numbers[0]` (第一个元素的地址)
* `&numbers[1]` (第二个元素的地址) = `&numbers[0] + sizeof(int)`
* `&numbers[i]` (第i个元素的地址) = `&numbers[0] + i * sizeof(int)`

#### 5. 数组越界访问 (Out-of-bounds Access)

C语言**不提供数组下标越界检查**！这意味着你可以尝试访问 `scores[-1]` 或 `scores[100]`，编译器不会报错，程序也不会立即崩溃。但是：
* 这种行为是**未定义行为** (Undefined Behavior)，非常危险！
* 它可能访问到不属于你的内存区域，导致数据损坏、程序崩溃或产生意想不到的结果。
* **小可爱务必警惕！** 在编程时要确保下标始终在合法范围内 `[0, 数组长度-1]`。

#### 6. 获取数组长度

C语言本身没有直接获取数组长度的内置函数。但可以利用 `sizeof` 运算符来计算：

```c
int arr[] = {10, 20, 30, 40, 50};
int length = sizeof(arr) / sizeof(arr[0]);
printf("数组的长度是: %d\n", length); // 输出 5
```

* `sizeof(arr)`：获取整个数组占用的总字节数。
* `sizeof(arr[0])`：获取数组中一个元素占用的字节数。
* 两者相除即可得到数组的元素个数。

    > [!WARNING] 注意：此方法只适用于在定义数组的**同一作用域内**。当数组作为函数参数传递时，`sizeof(arr)` 会得到**指针的大小**（通常是4或8字节），而不是整个数组的大小！这一点我们在"数组作为函数参数"中会详细说明。

### 04-3 二维数组：表格状的数据结构

二维数组可以看作是"数组的数组"，它能存储表格状（行和列）的数据，例如数学中的矩阵。

#### 1. 定义和声明

* **语法**：`数据类型 数组名[行数][列数];`
* **示例**：

    ```c
    int matrix[3][4]; // 定义一个3行4列的整型二维数组
    float grades[5][2]; // 定义一个5行2列的浮点型二维数组
    ```

#### 2. 初始化

##### (1) 分行初始化

最常见和清晰的初始化方式，用花括号把每一行的元素括起来。

```c
int matrix[2][3] = {
    {1, 2, 3},   // 第一行
    {4, 5, 6}    // 第二行
};
```

##### (2) 连续初始化

也可以不分行，直接提供所有元素，它们会按顺序填充。

```c
int matrix[2][3] = {1, 2, 3, 4, 5, 6}; // 效果同上
```

##### (3) 省略行数，但不能省略列数

定义时可以省略行数，由编译器根据初始值推断，但**列数不能省略**！因为编译器需要知道每行的长度才能正确地计算元素地址。

```c
int matrix[][3] = { // 行数省略，列数必须指定
    {10, 11, 12},
    {20, 21, 22}
}; // 编译器推断为2行3列
```

##### (4) 初始化部分元素

未被初始化的元素也会自动置零。

```c
int matrix[2][3] = {{1, 2}}; // matrix[0][0]=1, matrix[0][1]=2, 其他全为0
```

#### 3. 访问二维数组元素

通过两个下标来访问二维数组中的单个元素：第一个下标表示行号，第二个下标表示列号。

* **语法**：`数组名[行下标][列下标]`
* **下标范围**：行下标从 `0` 到 `行数-1`，列下标从 `0` 到 `列数-1`。
* **示例**：

    ```c
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};

    printf("matrix[0][0] = %d\n", matrix[0][0]); // 输出 1
    printf("matrix[1][2] = %d\n", matrix[1][2]); // 输出 6

    matrix[0][1] = 20; // 修改第一行第二列的元素
    printf("修改后 matrix[0][1] = %d\n", matrix[0][1]); // 输出 20
    ```

#### 4. 二维数组在内存中的存储

二维数组在内存中仍然是**连续存放**的，采取**按行优先** (Row-Major Order) 的方式。
这意味着 `matrix[0][0]`, `matrix[0][1]`, `matrix[0][2]` 是连续存放的，接着才是 `matrix[1][0]`, `matrix[1][1]`, `matrix[1][2]`。

### 04-4 数组与指针："形影不离"的好兄弟

在C语言中，数组和指针之间有着非常紧密而又特殊的联系。理解它们的关系是掌握C语言内存操作的关键。

#### 1. 数组名就是指向第一个元素的常量指针

* 当数组名单独使用时（不带下标），它**代表数组第一个元素的地址**。
* 因此，`数组名` 本身可以被看作是一个**常量指针**，它指向数组的起始位置。这个指针的值不能被改变。
* `arrayName` 等价于 `&arrayName[0]`。
* **示例**：

    ```c
    int arr[5] = {10, 20, 30, 40, 50};
    int *p = arr; // 将数组名arr赋值给指针p，此时p指向arr[0]
                  // 等价于 int *p = &arr[0];

    printf("arr的地址: %p\n", arr);
    printf("arr[0]的地址: %p\n", &arr[0]);
    printf("指针p的值 (指向的地址): %p\n", p);
    // 三者输出的地址应该相同
    ```

#### 2. 通过指针访问数组元素

既然数组名是地址，我们就可以利用指针的算术运算来访问数组的各个元素。

* `*(p + i)` 等价于 `p[i]`
* `*(arr + i)` 等价于 `arr[i]`
* **示例**：

    ```c
    int arr[5] = {10, 20, 30, 40, 50};
    int *p = arr;

    // 使用下标访问
    printf("arr[2] = %d\n", arr[2]); // 输出 30

    // 使用指针偏移访问
    printf("*(arr + 2) = %d\n", *(arr + 2)); // 输出 30

    // 使用指针变量p偏移访问
    printf("*(p + 2) = %d\n", *(p + 2)); // 输出 30
    printf("p[2] = %d\n", p[2]);         // 输出 30
    ```

    > [!NOTE] 指针算术  
    > 当一个指针加上一个整数 `i` 时 (`p + i`)，它实际上是向前移动了 `i * sizeof(它指向的类型)` 个字节。这就是为什么 `(p + 1)` 会指向数组的下一个元素。

#### 3. `&arr` vs `arr`：微妙但重要的区别

虽然 `arr` 和 `&arr` 在数值上通常是相同的（都表示数组的起始地址），但它们的**类型**不同：
* `arr`：类型是 `int*` (指向 `int` 的指针)，表示第一个元素的地址。当你 `arr + 1` 时，地址会增加 `sizeof(int)`。
* `&arr`：类型是 `int(*)[5]` (指向包含5个 `int` 元素的数组的指针)，表示整个数组的地址。当你 `(&arr) + 1` 时，地址会增加 `sizeof(int[5])`，也就是 `5 * sizeof(int)`。

这个区别在日常访问数组时可能不明显，但在涉及多维数组或指向数组的指针时会变得非常重要。

### 04-5 数组作为函数参数：传递的不是数组，是地址

当我们将数组作为参数传递给函数时，C语言实际上执行的是**"传址调用"**，或者说，**传递的是数组的起始地址**（一个指针）。函数接收的只是数组的地址，它并不知道数组的原始大小。

#### 1. 为什么不是"传值调用"？

如果按值传递，函数会复制整个数组。这对于大数组来说效率非常低，会消耗大量的内存和时间。所以C语言选择传递地址。

#### 2. 函数参数的声明方式

在函数参数列表中声明数组时，可以有以下几种等价方式：

```c
// 方式一：最像数组的声明，但方括号内数字是可选的
void printArray(int arr[], int size) {
    // …
}

// 方式二：明确表示接收的是一个指向int的指针（最常用和推荐）
void printArray(int *arr, int size) {
    // …
}

// 方式三：显式指定数组大小（但这个大小在函数内部没有实际意义，编译器会忽略）
void printArray(int arr[10], int size) { // 即使这里写10，函数内部也只知道是一个int*
    // …
}
```

* 无论哪种方式，函数内部 `arr` 的本质都是一个 `int*` 指针。
* 因此，在函数内部使用 `sizeof(arr)` 将得到**指针变量本身的大小**（4或8字节），而不是整个数组的大小！
* **为了让函数知道数组的实际长度，我们需要额外传递一个表示长度的参数**。

#### 3. 示例

```c
#include <stdio.h>

// 函数声明：接收一个整型数组（实际是地址）和数组的长度
void printArray(int arr[], int size) {
    printf("在函数内部：\n");
    printf("sizeof(arr) = %zu (这是指针的大小，不是数组的总大小)\n", sizeof(arr)); // 通常是4或8

    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]); // 通过下标访问
        // 也可以通过指针访问：printf("%d ", *(arr + i));
    }
    printf("\n");

    // 在函数内部修改数组元素，会影响到主函数中的原始数组
    arr[0] = 999;
}

int main() {
    int myNumbers[] = {10, 20, 30, 40, 50};
    int len = sizeof(myNumbers) / sizeof(myNumbers[0]); // 计算数组实际长度

    printf("在主函数中，调用前：\n");
    for (int i = 0; i < len; i++) {
        printf("%d ", myNumbers[i]);
    }
    printf("\n");

    printArray(myNumbers, len); // 传递数组名（地址）和长度

    printf("在主函数中，调用后：\n");
    for (int i = 0; i < len; i++) {
        printf("%d ", myNumbers[i]); // 0号元素已被修改！
    }
    printf("\n");
    return 0;
}
/*
输出：
在主函数中，调用前：
10 20 30 40 50
在函数内部：
sizeof(arr) = 8 (或 4, 取决于系统)
10 20 30 40 50
在主函数中，调用后：
999 20 30 40 50
*/
```

### 04-6 字符数组与字符串：文本处理的基石

在C语言中，**字符串 (String) 是以空字符 `\0` 结尾的字符数组**。

#### 1. 字符数组的定义和初始化

* **普通字符数组**：

    ```c
    char charArr[5] = {'H', 'e', 'l', 'l', 'o'}; // 没有null终止符，不是一个标准字符串
    ```

* **字符串**：
    * 使用字符串字面量初始化：编译器会自动添加 `\0`。

    ```c
    char str1[6] = "Hello"; // 长度为6，因为"Hello"占5个字符，'\0'占1个
    char str2[] = "World";  // 编译器自动计算长度为6 (5字符 + '\0')
    ```

    * 通过字符逐个初始化（需要手动添加 `\0`）：

    ```c
    char str3[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; // 手动添加空字符
    ```

#### 2. 空字符 `\0` 的重要性

* 空字符 (Null Terminator) 是一个特殊的字符，其ASCII值为0。
* 它标志着字符串的**结束**。C语言标准库中所有处理字符串的函数（如 `printf("%s", …)`，`strlen`, `strcpy` 等）都依赖于 `\0` 来判断字符串的终点。
* 如果字符数组没有 `\0` 结尾，那么它就不是一个标准意义上的C字符串，对它进行字符串操作可能导致**越界访问**和**未定义行为**。

#### 3. 常用字符串处理函数 (`<string.h>`)

为了方便处理字符串，C语言标准库 `<string.h>` 提供了许多有用的函数。

* `strlen(char *s)`：
    * **作用**：计算字符串 `s` 的长度（不包括 `\0`）。
    * **返回**：`size_t` 类型（无符号整数），表示字符串的字符数。
    * **示例**：`strlen("Hello")` 返回 5。
* `strcpy(char *dest, const char *src)`：
    * **作用**：将源字符串 `src` 复制到目标字符串 `dest`。
    * **注意**：`dest` 必须有足够的空间容纳 `src` (包括 `\0`)，否则会导致缓冲区溢出！
    * **示例**：`strcpy(str_dest, "New string");`
* `strcat(char *dest, const char *src)`：
    * **作用**：将源字符串 `src` 连接（追加）到目标字符串 `dest` 的末尾。
    * **注意**：`dest` 必须有足够的空间容纳连接后的字符串！
    * **示例**：`strcat(str_dest, " World");`
* `strcmp(const char *s1, const char *s2)`：
    * **作用**：比较两个字符串 `s1` 和 `s2`。
    * **返回**：
        * `0`：如果 `s1` 和 `s2` 相等。
        * `< 0`：如果 `s1` 小于 `s2` (按字典序)。
        * `> 0`：如果 `s1` 大于 `s2` (按字典序)。
    * **注意**：**不能直接使用 `==` 比较字符串**，`==` 比较的是字符串的地址，而不是内容！
* **示例**：

    ```c
    #include <stdio.h>
    #include <string.h> // 使用字符串函数需要包含此头文件

    int main() {
        char s1[20] = "Hello";
        char s2[20] = "World";
        char s3[20];

        printf("s1的长度: %zu\n", strlen(s1)); // 输出 5

        strcpy(s3, s1); // 将s1复制到s3
        printf("s3: %s\n", s3); // 输出 Hello

        strcat(s1, s2); // 将s2追加到s1后面
        printf("连接后s1: %s\n", s1); // 输出 HelloWorld

        if (strcmp(s1, s2) == 0) {
            printf("s1和s2相等\n");
        } else {
            printf("s1和s2不相等\n"); // 会输出这个
        }
        return 0;
    }
    ```

---
