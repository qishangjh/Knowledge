---
科目: 
课程名称: 
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度: 
考频: 
备注:
---

# 05 函数

# C语言 #基础 #函数 #函数定义 #函数声明 #函数调用 #参数传递 #递归 #作用域

> [!NOTE] 学习目标
> *   理解函数在程序设计中的作用：模块化、代码重用、提高可读性。
> *   掌握函数的**定义**方法，包括返回类型、函数名、参数列表和函数体。
> *   理解函数**声明**（原型）的必要性及其语法。
> *   掌握函数**调用**的方法，理解实参和形参的概念。
> *   区分并掌握两种主要的参数传递方式：**值传递**和**地址传递**（通过指针实现）。
> *   掌握 `return` 语句的使用，理解函数如何返回结果。
> *   了解C语言中函数的一些分类（标准库函数和用户自定义函数）。
> *   理解递归函数的基本思想和构成。
> *   理解变量的**作用域**和**生命周期**在函数中的体现。

## 05-1 函数的引入：为什么要用"小助手"？

小可爱，想象一下你正在建造一个乐高城堡：
* 如果没有函数，你就得从最底层的每一块砖开始搭，每次想搭一个窗户，就得重复一遍搭窗户的所有步骤。
* 有了函数，你就可以先设计好一个"窗户"模块（一个函数），然后需要窗户的地方，直接把这个模块"拿来用"就行了！

在C语言程序中，**函数 (Function)** 就是这样一个个独立的、完成特定任务的"代码块"。

**使用函数的好处：**

1. **模块化 (Modularity)**：把大程序分解成一个个小模块，每个函数负责一个独立的功能，使程序结构更清晰，更容易理解和管理。
2. **代码重用 (Code Reusability)**：一旦定义了一个函数，就可以在程序的任何地方多次调用它，避免重复编写相同的代码。
3. **提高可读性 (Readability)**：每个函数有明确的功能，程序的主逻辑会变得更简洁，更容易阅读。
4. **易于维护 (Maintainability)**：修改某个功能时，只需修改对应的函数，不会影响程序的其他部分。
5. **隐藏细节 (Abstraction)**：函数把实现细节封装起来，调用者只需要知道函数的功能和如何使用，而不需要关心具体实现。

`main()` 函数就是C程序的主入口函数，它是我们程序开始执行的地方。

## 05-2 函数的定义：函数的"骨架"

函数定义是告诉编译器函数长什么样子，它做什么事情。就像给你的"小助手"画一张设计图，说明它的功能和工作流程。

### 1. 语法

```c
返回类型 函数名 (参数类型 形参名1, 参数类型 形参名2, …) {
    // 函数体：实现特定功能的代码块
    // …
    return 表达式; // 如果返回类型不是void，则需要return一个值
}
```

### 2. 各部分详解

#### (1) `返回类型 (Return Type)`

* 表示函数执行完毕后会返回给调用者的值的类型。
* 可以是任何C语言的合法数据类型（`int`, `float`, `char`, `double`, 指针类型，结构体类型等）。
* 如果函数不返回任何值，则使用关键字 `void`。

#### (2) `函数名 (Function Name)`

* 给函数起的名字，遵循标识符命名规则。
* 应该"见名知意"，反映函数的功能。

#### (3) `参数列表 (Parameter List / Formal Parameters)`

* 括号 `()` 内列出函数在被调用时需要接收的输入值。
* 每个参数由**类型**和**名称**组成，多个参数之间用逗号 `,` 分隔。
* 这些参数被称为**形参** (Formal Parameters)，它们是函数内部的局部变量，用于接收函数调用时传递过来的数据。
* 如果函数不需要任何输入，参数列表可以写 `()` 或 `(void)`。

#### (4) `函数体 (Function Body)`

* 用花括号 `{}` 括起来的代码块，包含了函数实际执行的任务。
* 函数体内部可以声明局部变量，进行各种运算、调用其他函数等。

#### (5) `return 语句` (见05-5节)

* 用于结束函数的执行，并将一个值（如果返回类型不是 `void`）返回给调用者。

### 3. 示例

```c
#include <stdio.h> // 包含printf函数所在的头文件

// 这是一个计算两个整数之和的函数定义
// 返回类型：int (因为它返回一个整数和)
// 函数名：add
// 参数列表：两个整型参数a和b
int add(int a, int b) { // add函数定义开始
    int sum; // 局部变量
    sum = a + b;
    return sum; // 返回计算得到的和
} // add函数定义结束

// 这是一个打印欢迎信息的函数定义
// 返回类型：void (因为它不返回任何值)
// 函数名：printWelcomeMessage
// 参数列表：无参数
void printWelcomeMessage() { // printWelcomeMessage函数定义开始
    printf("欢迎来到C语言世界！\n");
    // void函数可以省略return语句，或者只写return;
} // printWelcomeMessage函数定义结束

int main() {
    // … (主函数代码)
    return 0;
}
```

## 05-3 函数的声明 (原型)：函数的"身份证"

函数声明 (Function Declaration)，也称为函数原型 (Function Prototype)，是告诉编译器函数的"长相"——它的**返回类型、函数名以及参数的类型和顺序**。

### 1. 为什么需要函数声明？

在C语言中，如果一个函数在被调用之前没有被定义或声明，编译器就不知道这个函数是否存在，也不知道它的返回类型和参数类型，这会导致编译错误。

* **编译器从上到下读取代码**：当编译器遇到一个函数调用时，它需要提前知道这个函数的完整信息。
* **提前告知**：函数声明就是提前给编译器一张"身份证"，让它知道这个函数以后会出现，并且它的类型是怎样的。

### 2. 语法

函数声明只需要函数定义中的第一行，并在末尾加上分号 `;`。参数的名称是可选的，但为了可读性，通常会保留。

```c
返回类型 函数名 (参数类型1, 参数类型2, …); // 参数名可选
// 或者
返回类型 函数名 (参数类型 形参名1, 参数类型 形参名2, …); // 推荐
```

### 3. 声明的位置

函数声明通常放在 `main` 函数之前，或者放在头文件 `.h` 中（当项目有多个源文件时）。

### 4. 示例

```c
#include <stdio.h>

// --- 函数声明 (Function Prototypes) ---
int add(int a, int b); // 声明add函数，告知编译器它接收两个int，返回一个int
void printWelcomeMessage(); // 声明printWelcomeMessage函数，告知编译器它无参数，无返回值
// ------------------------------------

int main() {
    // 现在可以在main函数中正常调用这些函数了
    int result = add(5, 3); // 调用add函数
    printf("5 + 3 = %d\n", result); // 输出 8

    printWelcomeMessage(); // 调用printWelcomeMessage函数

    return 0;
}

// --- 函数定义 (Function Definitions) ---
// 函数定义可以放在main函数之后
int add(int a, int b) {
    return a + b;
}

void printWelcomeMessage() {
    printf("欢迎来到C语言世界！\n");
}
// ------------------------------------
```

> [!TIP]
> 如果函数定义在调用之前（比如在 `main` 函数前面），那么可以省略函数声明，但为了代码规范和大型项目的管理，**最佳实践是始终提供函数声明**。

## 05-4 函数的调用：让函数"动起来"

函数调用是程序执行函数代码的过程。当函数被调用时，程序会暂停当前函数的执行，转而执行被调用函数的代码，直到被调用函数执行完毕并返回。

### 1. 语法

```c
函数名 (实际参数1, 实际参数2, …);
```

### 2. 各部分详解

* `函数名`：要调用的函数的名字。
* `实际参数 (Actual Arguments / Actual Parameters)`：
    * 括号 `()` 内列出传递给函数形参的真实值。
    * 这些值可以是常量、变量、表达式，它们会按照顺序匹配并传递给函数定义中的形参。
    * **实参和形参的类型和顺序必须匹配**。

### 3. 示例

```c
#include <stdio.h>

int multiply(int x, int y) { // 函数定义
    return x * y;
}

int main() {
    int num1 = 10, num2 = 5;
    int product;

    // 函数调用：传递变量作为实参
    product = multiply(num1, num2);
    printf("乘积是: %d\n", product); // 输出 50

    // 函数调用：传递常量作为实参
    product = multiply(7, 8);
    printf("乘积是: %d\n", product); // 输出 56

    // 函数调用：传递表达式作为实参
    product = multiply(num1 + num2, num1 - num2);
    printf("乘积是: %d\n", product); // 输出 (10+5)*(10-5) = 15 * 5 = 75
    return 0;
}
```

### 4. 参数传递机制：值传递 vs 地址传递

这是C语言中非常重要的概念，小可爱一定要搞清楚哦！

#### (1) 值传递 (Call by Value)：传的是"副本"

* **C语言默认的参数传递方式**。
* 当调用函数时，**实参的值会被复制一份**，然后将这个副本传递给函数的形参。
* 函数内部对形参的任何修改，都**只影响形参这个副本**，不会影响到主调函数中对应的实参变量的原始值。
* 就像你把一份文件"复印件"给了小助手，小助手在复印件上做了修改，你的原件不受影响。

```c
#include <stdio.h>

// 尝试通过值传递修改变量
void tryToChange(int val) { // val是实参x的副本
    printf("函数内，修改前 val = %d\n", val); // val = 10
    val = 100; // 只修改了副本val的值
    printf("函数内，修改后 val = %d\n", val); // val = 100
}

int main() {
    int x = 10;
    printf("主函数，调用前 x = %d\n", x); // x = 10
    tryToChange(x); // 传递x的值（10）给val
    printf("主函数，调用后 x = %d\n", x); // x 仍然是 10！没有被修改
    return 0;
}
```

#### (2) 地址传递 (Call by Address / Call by Reference)：传的是"地址"

* 如果你希望函数能够**修改主调函数中的变量**，就需要使用**地址传递**。
* 通过**指针**来实现：实参传递变量的**地址** (`&变量名`)，形参使用**指针变量** (`数据类型 *形参名`) 来接收这个地址。
* 函数内部通过**解引用指针** (`*形参名`) 来访问和修改该地址所指向的内存单元，从而改变主调函数中原始变量的值。
* 就像你把藏宝图（地址）给了小助手，小助手直接去地图上的宝藏地点挖宝并修改了宝藏。

```c
#include <stdio.h>

// 通过地址传递来修改变量
void changeByPointer(int *ptr) { // ptr接收的是x的地址
    printf("函数内，ptr指向的值(*ptr)修改前 = %d\n", *ptr); // *ptr = 10
    *ptr = 100; // 通过指针解引用，修改了ptr指向的内存（也就是main函数中x的内存）
    printf("函数内，ptr指向的值(*ptr)修改后 = %d\n", *ptr); // *ptr = 100
}

int main() {
    int x = 10;
    printf("主函数，调用前 x = %d\n", x); // x = 10
    changeByPointer(&x); // 传递x的地址给ptr
    printf("主函数，调用后 x = %d\n", x); // x 变成了 100！被成功修改了
    return 0;
}
```

> [!NOTE] 数组作为函数参数
> 还记得我们"04 数组"里讲的吗？当数组作为函数参数传递时，C语言默认就是传递**数组的起始地址**（即数组名作为指针），这本身就是一种地址传递。所以，在函数内部修改数组元素，会直接影响到原始数组。

## 05-5 `return` 语句：函数的"出口"和"返回值"

`return` 语句用于**结束函数执行**，并将控制权交还给调用者。同时，如果函数有返回类型（非 `void`），`return` 语句还会把一个值返回给调用者。

### 1. 语法

* **对于非 `void` 函数**：`return 表达式;`
    * `表达式` 的类型必须与函数的返回类型兼容。
* **对于 `void` 函数**：`return;` 或可以省略不写。

### 2. `return` 的作用

1. **结束函数**：`return` 语句一旦执行，函数立即停止，它后面的代码不再执行。
2. **返回值**：将 `表达式` 的值传递给调用者。这个值可以在调用点被赋值给一个变量，或者用作另一个表达式的一部分。

### 3. 示例

```c
#include <stdio.h>

// 返回一个整数
int getMax(int a, int b) {
    if (a > b) {
        return a; // 如果a大，返回a
    } else {
        return b; // 否则返回b
    }
    // 注意：这里的代码将永远不会被执行，因为前面有return
    // printf("这行不会被打印\n");
}

// 不返回任何值
void showMessage(const char *msg) {
    printf("消息：%s\n", msg);
    return; // 可以写return; 也可以省略，效果一样
}

int main() {
    int m = getMax(10, 20); // 调用getMax，并将返回值赋给m
    printf("最大值是: %d\n", m); // 输出 20

    showMessage("Hello Functions!"); // 调用showMessage

    return 0; // main函数也需要返回一个值，0表示程序正常结束
}
```

## 05-6 函数的分类：标准库 vs 用户自定义

C语言的函数可以分为两大类：

1. **标准库函数 (Standard Library Functions)**：
    * C语言标准库预先定义好的函数，涵盖了各种常用的功能，如输入输出、数学运算、字符串处理、内存管理等。
    * 使用时需要包含对应的**头文件**（例如 `printf()` 和 `scanf()` 需要 `#include <stdio.h>`，`strlen()` 需要 `#include <string.h>`）。
    * 我们只需要知道它们的功能和如何使用，不需要关心它们的具体实现。

2. **用户自定义函数 (User-Defined Functions)**：
    * 由程序员根据自己的需求编写的函数，用于实现特定功能。
    * 它们的定义、声明和调用都遵循我们前面学到的规则。

## 05-7 递归函数：函数自己"呼唤"自己

**递归 (Recursion)** 是一种特殊的函数调用方式，指一个函数在它的函数体内**直接或间接地调用它自身**。

递归是解决某些问题（如树的遍历、阶乘计算、斐波那契数列等）非常优雅和强大的方法，但它也需要小心使用，否则容易导致栈溢出。

### 1. 递归的两个基本要素

1. **递归结束条件 (Base Case)**：这是最重要的！必须有一个或多个条件，当满足这些条件时，函数不再进行递归调用，而是直接返回一个确定的值。这就像是递归的"安全出口"，防止无限递归。
2. **递归调用 (Recursive Step)**：在函数体内部调用自身，并且每次调用时，问题规模都必须比上一次调用时有所**减小**，并最终能够达到递归结束条件。

### 2. 示例：计算阶乘 (Factorial)

* `n!` (n的阶乘) 定义为 `n * (n-1) * (n-2) * … * 1`。
* 数学定义：`n! = n * (n-1)!` (当 n > 1)；`1! = 1`；`0! = 1`。

```c
#include <stdio.h>

// 递归函数：计算n的阶乘
long long factorial(int n) {
    if (n == 0 || n == 1) {
        return 1; // 递归结束条件 (Base Case)
    } else {
        return n * factorial(n - 1); // 递归调用 (Recursive Step)
                                     // n乘以 (n-1)的阶乘
    }
}

int main() {
    int num = 5;
    printf("%d的阶乘是：%lld\n", num, factorial(num)); // 输出 120 (5 * 4 * 3 * 2 * 1)

    int num0 = 0;
    printf("%d的阶乘是：%lld\n", num0, factorial(num0)); // 输出 1

    return 0;
}
```

**`factorial(5)` 的调用过程分析：**
1. `factorial(5)` → `5 * factorial(4)`
2. `factorial(4)` → `4 * factorial(3)`
3. `factorial(3)` → `3 * factorial(2)`
4. `factorial(2)` → `2 * factorial(1)`
5. `factorial(1)` → `1` (达到Base Case，返回1)
6. 现在，调用链开始回溯计算：
    * `factorial(2)` 得到 `2 * 1 = 2`
    * `factorial(3)` 得到 `3 * 2 = 6`
    * `factorial(4)` 得到 `4 * 6 = 24`
    * `factorial(5)` 得到 `5 * 24 = 120`

## 05-8 变量的作用域与生命周期 (与函数相关)

理解变量的作用域和生命周期对于编写正确且无Bug的C程序至关重要。

### 1. 作用域 (Scope)

作用域指的是一个变量或标识符在程序中可以被访问的区域。

* **局部变量 (Local Variables)**：
    * 在函数内部或某个代码块 `{}` 内部定义的变量。
    * **作用域**：只在定义它的函数或代码块内部有效。出了这个范围，就无法访问它。
    * 不同函数中可以定义同名的局部变量，它们互不影响。
* **全局变量 (Global Variables)**：
    * 在所有函数外部定义的变量。
    * **作用域**：从定义它的位置开始，直到文件结束，可以在程序中的任何函数内被访问。
    * **不建议过度使用**：全局变量使得函数之间耦合度高，难以追踪变量的修改，不利于模块化和代码维护。
* **示例**：

    ```c
    #include <stdio.h>

    int globalVar = 100; // 全局变量

    void func1() {
        int localVar1 = 10; // 局部变量，只在func1内有效
        printf("func1中：globalVar = %d, localVar1 = %d\n", globalVar, localVar1);
        // printf("func1中：localVar2 = %d\n", localVar2); // 错误！无法访问func2的局部变量
    }

    void func2() {
        int localVar2 = 20; // 局部变量，只在func2内有效
        printf("func2中：globalVar = %d, localVar2 = %d\n", globalVar, localVar2);
    }

    int main() {
        printf("main中：globalVar = %d\n", globalVar);
        // printf("main中：localVar1 = %d\n", localVar1); // 错误！无法访问func1的局部变量

        func1();
        func2();
        return 0;
    }
    ```

### 2. 生命周期 (Lifetime / Storage Duration)

生命周期指的是一个变量从创建到销毁的时间段。

* **自动变量 (Automatic Variables)**：
    * 大部分局部变量都是自动变量（默认是 `auto` 存储类型，但通常省略）。
    * **生命周期**：当进入定义它的函数或代码块时被创建并分配内存，当函数或代码块结束时被销毁并释放内存。
    * 每次函数调用，局部变量都会重新创建、初始化。
* **静态局部变量 (Static Local Variables)**：
    * 在函数内部使用 `static` 关键字修饰的局部变量。
    * **生命周期**：在程序开始执行时被创建并初始化一次，直到程序结束才销毁。
    * **作用域**：仍然是局部作用域（只能在定义它的函数内部访问）。
    * **特点**：在函数多次调用之间，它会**保留上次函数调用结束时的值**。
* **全局变量**：
    * **生命周期**：在程序开始执行时被创建并初始化一次（如果没有显式初始化，数值类型默认为0），直到程序结束才销毁。
* **示例 (静态局部变量)**：

    ```c
    #include <stdio.h>

    void countCalls() {
        int autoVar = 0;           // 自动局部变量，每次调用都会重新初始化为0
        static int staticVar = 0;  // 静态局部变量，只在第一次调用时初始化为0

        autoVar++;
        staticVar++;
        printf("自动变量 autoVar = %d, 静态变量 staticVar = %d\n", autoVar, staticVar);
    }

    int main() {
        countCalls(); // autoVar=1, staticVar=1
        countCalls(); // autoVar=1, staticVar=2
        countCalls(); // autoVar=1, staticVar=3
        return 0;
    }
    ```

---
