---
科目: 
课程名称: 
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度: 
考频: 
备注:
---

# 07 结构体
 #基础 #结构体 #复合数据类型 #成员访问 #结构体数组 #结构体指针 #结构体传参

> [!NOTE] 学习目标
> *   理解结构体的概念和作用：将不同类型的数据组合成一个复合数据类型。
> *   掌握结构体的**定义**方法。
> *   掌握结构体变量的**声明**和**初始化**方法。
> *   学会通过`.` (成员运算符) 和 `->` (指针成员运算符) 访问结构体成员。
> *   理解结构体数组的定义、初始化和使用。
> *   掌握结构体指针的概念和应用。
> *   了解结构体作为函数参数的传递方式（值传递 vs 地址传递）。
> *   理解结构体内存对齐的基本概念。
> *   了解联合体 (union) 和枚举 (enum) 的基本概念。

## 07-1 结构体的引入：自定义的"数据包"

在C语言中，我们已经学习了 `int`、`char`、`float` 等基本数据类型，以及数组（用来存储同类型数据）。但是，这些类型无法很好地描述一个拥有多个属性、且这些属性可能类型各异的复杂实体。

例如，要存储一个学生的信息：
* 姓名 (`char[]`)
* 学号 (`int`)
* 年龄 (`int`)
* C语言成绩 (`float`)

这些数据虽然类型不同，但它们共同描述了一个学生。如果用单独的变量来存储，管理起来会非常麻烦，也难以体现它们之间的关联性。

**结构体 (Structure)** 应运而生！它允许我们把这些**不同类型但逻辑上相关联的数据项组合在一起，形成一个新的、自定义的复合数据类型**。你可以把它看作是你自己设计的一个"数据包"，里面可以装各种你想要的数据。

## 07-2 结构体的定义：设计你的"数据包"

定义结构体，就像是设计一个"模具"或"蓝图"，它只规定了结构体的**组成结构**，并**不分配实际的内存空间**。

### 1. 语法

```c
struct 结构体名 {
    数据类型 成员名1;
    数据类型 成员名2;
    // … 可以有任意多个成员，类型可以不同
}; // 注意末尾的分号！
```

* `struct`：关键字，表示正在定义一个结构体。
* `结构体名`：你自己给这个结构体类型起的名字（例如 `Student`, `Point`, `Book` 等），遵循标识符命名规则。通常首字母大写。
* `成员名`：结构体内部的各个数据项，可以是任何基本数据类型、数组、甚至其他结构体。

### 2. 示例

```c
// 定义一个名为 Student 的结构体
struct Student {
    char name[20]; // 姓名 (字符数组)
    int id;        // 学号 (整型)
    int age;       // 年龄 (整型)
    float score;   // 成绩 (浮点型)
}; // 定义结束，注意分号！

// 定义一个名为 Point 的结构体，表示二维坐标
struct Point {
    int x; // x坐标
    int y; // y坐标
};
```

### 3. 定义结构体时的类型名简化 (`typedef`)

每次声明结构体变量时，都需要写 `struct Student`，可能会觉得有点冗余。C语言提供了 `typedef` 关键字来给类型起一个别名，简化写法。

```c
// 方式一：先定义结构体，再用typedef起别名
struct Person {
    char name[20];
    int age;
};
typedef struct Person Per; // 现在可以用 Per 代替 struct Person

// 方式二：在定义结构体时直接用typedef起别名 (常用方式)
typedef struct {
    float length;
    float width;
} Rectangle; // 现在可以直接用 Rectangle 代替 struct { … }
             // 注意：这里省略了结构体标签（匿名字段），因为它现在主要通过别名使用
```

## 07-3 结构体变量的声明与初始化：制造"数据包"实例

结构体定义只是创建了"模具"，要使用它，还需要根据模具创建具体的"产品"——**结构体变量**。

### 1. 声明结构体变量

* **语法**：`struct 结构体名 变量名;` 或 `别名 变量名;`
* **示例**：

    ```c
    struct Student s1;         // 声明一个 Student 类型的结构体变量 s1
    struct Point p1, p2;       // 声明两个 Point 类型的结构体变量 p1 和 p2

    // 如果使用了 typedef
    Rectangle rect1; // 声明一个 Rectangle 类型的结构体变量 rect1
    ```

### 2. 初始化结构体变量

声明变量时可以同时给它的成员赋初始值。

#### (1) 按顺序初始化

按照结构体成员的定义顺序提供初始值。

```c
struct Student s1 = {"Alice", 1001, 20, 95.5f};
struct Point p1 = {10, 20};
```

#### (2) 指定成员初始化 (C99标准引入)

使用 `.成员名 = 值` 的形式，可以不按顺序，也可以只初始化部分成员。未初始化的成员会自动置零（数值类型）或空字符（字符类型）。

```c
struct Student s2 = {.name = "Bob", .score = 88.0f}; // 其他成员 id, age 自动为0
struct Point p2 = {.y = 50, .x = 30}; // 不按顺序
```

#### (3) 声明后赋值

也可以先声明，再通过成员访问运算符 `.` 逐个赋值。

```c
struct Student s3;
strcpy(s3.name, "Charlie"); // 字符串赋值需要用strcpy函数
s3.id = 1003;
s3.age = 21;
s3.score = 78.0f;
```

## 07-4 访问结构体成员：打开"数据包"取数据

要访问结构体变量中的某个成员，需要使用特定的运算符。

### 1. 成员运算符 `.` (点运算符)

当直接使用**结构体变量**时，使用 `.` 运算符来访问其成员。

* **语法**：`结构体变量名.成员名`
* **示例**：

    ```c
    struct Student s1 = {"Alice", 1001, 20, 95.5f};

    printf("姓名: %s\n", s1.name);
    printf("学号: %d\n", s1.id);
    printf("年龄: %d\n", s1.age);
    printf("成绩: %f\n", s1.score);

    s1.age = 21; // 修改成员值
    printf("修改后的年龄: %d\n", s1.age);
    ```

### 2. 指针成员运算符 `->` (箭头运算符)

当使用**指向结构体的指针**时，使用 `->` 运算符来访问其成员。

* **语法**：`结构体指针名->成员名`
* `p->member` 等价于 `(*p).member`。
* **示例**：

    ```c
    struct Student s1 = {"Alice", 1001, 20, 95.5f};
    struct Student *ptr_s1; // 定义一个指向Student结构体的指针

    ptr_s1 = &s1; // 将s1的地址赋给指针ptr_s1

    printf("通过指针访问成员：\n");
    printf("姓名: %s\n", ptr_s1->name);
    printf("学号: %d\n", ptr_s1->id);

    ptr_s1->score = 98.0f; // 通过指针修改成员值
    printf("修改后的成绩: %f\n", s1.score); // 打印s1，值已被修改
    ```

## 07-5 结构体数组：一堆"数据包"

结构体数组就是数组的元素是结构体类型。这就像你有一个班级所有学生的文件夹，每个文件夹里都装着一个学生的完整信息。

### 1. 定义和声明

* **语法**：`struct 结构体名 数组名[数组长度];` 或 `别名 数组名[数组长度];`
* **示例**：

    ```c
    struct Student students[3]; // 声明一个包含3个Student结构体变量的数组
    // 或者用 typedef
    Student class_members[50]; // 声明一个包含50个Student结构体变量的数组
    ```

### 2. 初始化

可以像普通数组一样初始化，每个元素是一个结构体。

```c
struct Student classA[] = {
    {"Alice", 1001, 20, 95.5f},
    {"Bob", 1002, 21, 88.0f},
    {"Charlie", 1003, 22, 79.5f}
}; // 编译器自动推断数组长度为3
```

### 3. 访问结构体数组元素

先通过下标访问数组中的某个结构体，再通过 `.` 运算符访问该结构体的成员。

* **语法**：`数组名[下标].成员名`
* **示例**：

    ```c
    printf("第二个学生的姓名: %s\n", classA[1].name); // 访问Bob的姓名
    classA[0].score = 98.0f; // 修改Alice的成绩

    // 遍历结构体数组
    for (int i = 0; i < 3; i++) {
        printf("学生%d: 姓名=%s, 学号=%d, 成绩=%f\n",
               i + 1, classA[i].name, classA[i].id, classA[i].score);
    }
    ```

## 07-6 结构体指针：指向"数据包"的地址

前面我们已经接触过指向结构体的指针，这里再强调一下。结构体指针可以用来传递结构体，实现对结构体内容的修改，或者高效地遍历结构体数组。

### 1. 定义结构体指针

* **语法**：`struct 结构体名 *指针变量名;` 或 `别名 *指针变量名;`
* **示例**：

    ```c
    struct Student *studentPtr; // 定义一个指向Student结构体的指针
    ```

### 2. 初始化结构体指针

将某个结构体变量的地址赋给结构体指针。

* **示例**：

    ```c
    struct Student s = {"David", 1004, 23, 90.0f};
    studentPtr = &s; // 指针指向结构体s
    ```

### 3. 通过结构体指针访问成员

使用 `->` 运算符。

* **示例**：

    ```c
    printf("通过指针访问 David 的学号: %d\n", studentPtr->id);
    studentPtr->age = 24; // 修改David的年龄
    ```

### 4. 结构体指针在数组中的应用

可以配合循环遍历结构体数组。

```c
struct Student classA[] = {{"Alice", 1001, 20, 95.5f}, {"Bob", 1002, 21, 88.0f}};
struct Student *ptr = classA; // 指针指向数组的第一个元素 (classA[0])

printf("遍历结构体数组 (通过指针):\n");
for (int i = 0; i < 2; i++) {
    printf("姓名: %s, 成绩: %f\n", ptr->name, ptr->score);
    ptr++; // 指针移动到下一个结构体元素 (因为是指向Student的指针，会自动偏移sizeof(Student)字节)
}
```

## 07-7 结构体作为函数参数：传递"数据包"

将结构体作为参数传递给函数，有两种方式：**值传递**和**地址传递**。

### 1. 值传递 (Call by Value)

* **方式**：直接将结构体变量作为参数传递。
* **机制**：函数会接收到结构体的一个**完整副本**。
* **特点**：
    * 函数内部对结构体副本的修改，**不会影响**到原始结构体变量。
    * **效率较低**：如果结构体很大，复制整个结构体会消耗较多时间和内存。
* **适用场景**：函数只需要读取结构体内容，不需要修改它。

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    char name[20];
    int age;
} Person;

// 值传递：函数接收结构体的副本
void displayPerson(Person p) {
    printf("函数内 (值传递)：姓名: %s, 年龄: %d\n", p.name, p.age);
    strcpy(p.name, "Modified"); // 修改的是副本
    p.age = 99;                 // 修改的是副本
}

int main() {
    Person myPerson = {"Alice", 30};
    printf("主函数，调用前：姓名: %s, 年龄: %d\n", myPerson.name, myPerson.age); // Alice, 30

    displayPerson(myPerson); // 值传递

    printf("主函数，调用后：姓名: %s, 年龄: %d\n", myPerson.name, myPerson.age); // Alice, 30 (未改变)
    return 0;
}
```

### 2. 地址传递 (Call by Address)

* **方式**：将结构体变量的**地址**作为参数传递（即传递一个指向结构体的指针）。
* **机制**：函数接收一个指向原始结构体的指针。
* **特点**：
    * 函数内部通过指针**解引用**修改结构体成员，**会影响**到原始结构体变量。
    * **效率较高**：只需传递一个指针（通常4或8字节），而不是复制整个结构体。
    * **常用且推荐**。
* **适用场景**：函数需要修改结构体内容，或结构体较大时。

```c
#include <stdio.h>
#include <string.h>

typedef struct {
    char name[20];
    int age;
} Person;

// 地址传递：函数接收指向结构体的指针
void modifyPerson(Person *pPtr) {
    printf("函数内 (地址传递)，修改前：姓名: %s, 年龄: %d\n", pPtr->name, pPtr->age);
    strcpy(pPtr->name, "Bob"); // 修改的是原始结构体
    pPtr->age = 25;             // 修改的是原始结构体
    printf("函数内 (地址传递)，修改后：姓名: %s, 年龄: %d\n", pPtr->name, pPtr->age);
}

int main() {
    Person myPerson = {"Alice", 30};
    printf("主函数，调用前：姓名: %s, 年龄: %d\n", myPerson.name, myPerson.age); // Alice, 30

    modifyPerson(&myPerson); // 地址传递，传递myPerson的地址

    printf("主函数，调用后：姓名: %s, 年龄: %d\n", myPerson.name, myPerson.age); // Bob, 25 (已改变)
    return 0;
}
```

> [!TIP] `const` 关键字用于保护参数
> 如果你传递结构体指针仅仅是为了提高效率（避免复制大结构体），但又不想函数内部修改原始结构体，可以在参数前加上 `const` 关键字：
> ```c
> void displayPersonEfficiently(const Person *pPtr) {
>     printf("姓名: %s, 年龄: %d\n", pPtr->name, pPtr->age);
>     // pPtr->age = 10; // 编译错误！因为pPtr指向的Person是const的，不能修改
> }
> ```

## 07-8 结构体内存对齐 (Memory Alignment)

这是一个稍微深入但非常重要的概念。
* 为了提高内存访问效率和满足某些硬件要求，编译器在为结构体分配内存时，可能会在成员之间插入一些**填充字节 (Padding Bytes)**，使得每个成员都从一个特定的地址（其类型的对齐要求）开始存储。
* 这导致结构体的实际大小可能**大于**其所有成员大小的总和。
* **示例**：

    ```c
    struct Example1 {
        char c1; // 1字节
        int i;   // 4字节
        char c2; // 1字节
    };
    // 假设char对齐到1字节，int对齐到4字节
    // 内存布局可能如下：
    // c1 (1字节) | padding (3字节) | i (4字节) | c2 (1字节) | padding (3字节)
    // 实际大小通常是 1 + 3 + 4 + 1 + 3 = 12 字节
    // 而不是 1 + 4 + 1 = 6 字节

    struct Example2 {
        char c1; // 1字节
        char c2; // 1字节
        int i;   // 4字节
    };
    // 优化后的布局 (将小类型成员放在一起)：
    // c1 (1字节) | c2 (1字节) | padding (2字节) | i (4字节)
    // 实际大小通常是 1 + 1 + 2 + 4 = 8 字节
    ```

* **影响**：了解内存对齐有助于你估算结构体大小，以及在跨平台或与硬件交互时避免问题。通常，我们可以通过调整结构体成员的定义顺序来减少填充字节，从而节省内存。

## 07-9 联合体 (Union) 和 枚举 (Enum) 简介

虽然这次笔记的主题是结构体，但作为与结构体相关的复合数据类型，这里简单提一下联合体和枚举。

### 1. 联合体 (Union)

* **特点**：联合体的所有成员**共享同一块内存空间**。任何时候，联合体中只有一个成员是有效的（即你只能正确使用最后一次赋值的那个成员）。
* **内存大小**：联合体的大小等于其**最大成员**的大小。
* **用途**：在不同时刻需要存储不同类型但不会同时使用的信息时，可以节省内存。
* **语法**：

    ```c
    union Data {
        int i;
        float f;
        char str[20];
    };
    // 定义一个联合体变量d
    // d.i = 10;
    // d.f = 3.14f; // 此时d.i的值就被覆盖了
    ```

### 2. 枚举 (Enum)

* **特点**：用于定义一组**命名整数常量**的集合，提高代码的可读性。
* **用途**：替代 `int` 来表示有限的几种状态或选项，让代码更具语义化。
* **语法**：

    ```c
    enum Weekday {
        MONDAY,    // 默认为0
        TUESDAY,   // 默认为1
        WEDNESDAY, // 默认为2
        // …
        SUNDAY = 6 // 可以指定值
    };
    // enum Weekday today = MONDAY;
    ```

---
