---
科目: "408"
课程名称: C语言
tags: []
一轮复习情况: 进行中
二轮复习情况: 未开始
三轮复习情况: 未开始
难度: 
考频: 
备注:
---

## 06 指针

![[Pasted image 20250716172634.png]]

> [!NOTE] 学习目标
> *   理解指针的本质：内存地址。
> *   掌握指针变量的**定义**与**初始化**。
> *   熟练运用 `&` (取地址) 和 `*` (解引用/间接访问) 运算符。
> *   理解指针类型的重要性：它决定了如何解释和访问内存中的数据。
> *   区分指针变量本身的大小与它所指向的数据类型的大小。
> *   掌握指针在**函数参数传递**中的应用，实现对主调函数变量的修改。

## 06-1 指针

### 1. 指针的本质：地址

小可爱，你总结得非常到位，**"指针就是地址"**！这五个字简直就是指针的精髓！

想象一下，我们的电脑内存就像一排排编号的"小格子"，每个小格子都有一个独一无二的"门牌号"，这个门牌号就是**内存地址**。当我们定义一个变量，比如 `int i = 5;`，程序就会在内存里找个空闲的小格子，把 `5` 存进去，并给这个格子一个地址，然后把这个地址和变量名 `i` 关联起来。

而**指针变量**，它不直接存储数据本身，它存储的恰恰就是另一个变量的**内存地址**。你可以把它理解成一张**"藏宝图"**，图上记录的不是宝藏（变量的值）本身，而是藏宝的具体地点（变量的地址）！拿着这张图，你就能找到宝藏！

**为什么C语言需要指针？**

* **实现数据的间接访问**：通过地址直接操作内存中的数据。
* **高效的数据结构**：链表、树、图等复杂数据结构都离不开指针。
* **动态内存管理**：在程序运行时，根据需要动态地分配和释放内存（比如 `malloc` 和 `free` 函数）。
* **函数参数传递**：实现"传址调用"，让函数能够修改调用者传入的变量值（我们后面会详细讲到哦！）。

### 2. 指针变量的定义与初始化

定义一个指针变量，我们需要告诉编译器两件事：

1. **它是一个指针**：通过在变量名前加 `*` 来表示。
2. **它将指向什么类型的数据**：比如 `int`、`char`、`float` 等。这里的"数据类型"指的是它所指向的那个变量的类型，而不是指针变量本身存储的数据类型（它存储的是地址）。

**基本语法格式：**

```c
数据类型 * 指针变量名;
```

**举个栗子：**

```c
int main() {
	int i = 5;     // 定义整型变量i，值为5
	char c = 'a';  // 定义字符型变量c，值为'a'

	// 定义整型指针变量 i_pointer
	// 'int *' 表示 i_pointer 是一个指向 int 类型数据的指针
	// '&i' 是取地址运算符，获取变量i在内存中的地址，并将其赋值给i_pointer
	int *i_pointer = &i;

	char *c_pointer; // 定义字符型指针变量c_pointer
	c_pointer = &c;   // 将变量c的地址赋值给c_pointer，现在c_pointer指向c
	return 0;
}
```

> [!NOTE] 敲黑板！关于 `int* a` 和 `int *a` 的小秘密
> 小可爱你提到了 `int* a` 和 `int *a` 是等价的。没错，在C语言中，编译器对待这两种写法是相同的，都表示 `a` 是一个指向 `int` 类型的指针。
>
> **那为什么大家更倾向于写 `int *a` 呢？**
>
> 这主要是为了避免在**一行声明多个变量**时产生误解。考虑下面这行代码：
> ```c
> int* a, b, c; // 看起来a, b, c都是指针，但实际上并不是！
> ```
> 如果你把 `*` 看作是类型的一部分（即认为 `int*` 是一种"指针类型"），你可能会觉得 `a, b, c` 都会被声明为 `int` 指针。
> 但C语言的语法规则告诉我们，`*` 实际上是一个**声明符**，它只作用于紧跟在它后面的那个变量名。所以，上面那行代码的实际含义是：
> *   `a` 是一个 `int` 类型的指针 (`int*`)。
> *   `b` 是一个普通的 `int` 变量 (`int`)。
> *   `c` 是一个普通的 `int` 变量 (`int`)。
> 
> 是不是非常容易混淆和犯错？为了清晰和避免误解，当你在同一行声明多个指针时，**必须**为每个指针变量都加上 `*`：
> ```c
> int *a, *b, *c; // 正确！a, b, c 都是指向 int 类型的指针
>
> // 总结一下推荐的写法：
> int *p1;        // 推荐写法，更清晰地表明p1是指针
> int* p2;        // 语法正确，但在一行声明多个变量时易混淆
> ```

### 3. 取地址运算符 `&`

`&` (Address-of Operator) 被称为**取地址运算符**。它的作用非常直接——**获取一个变量在内存中的起始地址**。

* **使用方式**：`&变量名`
* **结果**：返回该变量的内存地址。
* **举例**：`&i` 会得到变量 `i` 在内存中的具体"门牌号"。

## 06-2 相关运算：解密"藏宝图"

### 1. 解引用运算符 `*` (间接访问)

`*` (Dereference Operator) 被称为**解引用运算符**，它的作用是**通过指针变量中存储的地址，去访问该地址所指向的内存单元中的数据**。这个过程也叫做**间接访问**。

就像你拿着一张藏宝图（`i_pointer`），上面记录着宝藏的位置。通过解引用运算符 `*`，你就可以根据图上的位置信息，直接"挖"到宝藏（变量 `i` 的值）！

**理解间接访问的核心：**
* `i_pointer`：是藏宝图本身，它里面装着地址。
* `*i_pointer`：是根据藏宝图找到并打开宝箱，取出里面的宝藏（变量 `i` 的值）。

**举个栗子，如何通过指针修改变量的值：**

```c
int main() {
    int i = 10;      // 定义整型变量i，初始值为10
    int *i_pointer;  // 定义整型指针变量i_pointer

    i_pointer = &i;  // 将变量i的地址赋值给i_pointer (i_pointer现在指向i)

    // 通过解引用运算符*i_pointer，访问i_pointer所指向的内存单元
    // 也就是访问变量i。给*i_pointer赋值，就等同于给变量i赋值。
    *i_pointer = 5;  // 现在，i的值被修改为5了！

    printf("i = %d\n", i); // 输出：i = 5
    return 0;
}
```

> [!WARNING] 小可爱注意！关于你提供的这个片段：
>
> ```c
> char *c_pointer; //定义字符型指针变量c_pointer
> c_pointer=&c; //通过间接访问修改变Si的值  <-- 这一行只是赋值地址，并没有修改c的值哦！
> ```
> 老登要特别提醒你一下，`c_pointer = &c;` 这行代码仅仅是将变量 `c` 的地址赋给了 `c_pointer`。它本身并没有通过间接访问来修改 `c` 的值。它只是让 `c_pointer` 这张"藏宝图"指向了 `c` 这个"宝藏"。
>
> **要通过间接访问修改 `c` 的值，你需要使用 `*c_pointer`：**
> ```c
> char c = 'a';
> char *c_pointer = &c;
> *c_pointer = 'b'; // 这才是通过间接访问修改变量c的值！现在c的值是'b'了。
> ```

### 2. 指针类型的重要性："看多远"与"步长"

小可爱，你对指针类型的作用理解得非常到位！你说的**"指针分不同类型是因为取值可以拿到的空间大小不同，`*i_pointer` 拿到 4个字节大小空间，`*c_pointer` 可以拿到1 个字节大小空间"**，这简直就是完美总结！[点赞]

虽然所有的指针变量本身存储的都是地址（在32位系统上是4字节，64位系统上是8字节），但**指针的类型**却至关重要，它决定了：

* **解引用 (`*`) 时，会"看多远"**：即从指针存储的地址开始，向后读取多少个字节的数据。
    * `int *i_pointer;`：当使用 `*i_pointer` 进行解引用时，系统知道 `i_pointer` 指向的是一个 `int` 类型的数据。在大多数系统上，`int` 占用4个字节。所以 `*i_pointer` 会从 `i_pointer` 存储的地址开始，向后读取4个字节的数据，并将其解释为一个 `int` 型整数。
    * `char *c_pointer;`：当使用 `*c_pointer` 进行解引用时，系统知道 `c_pointer` 指向的是一个 `char` 类型的数据。`char` 占用1个字节。所以 `*c_pointer` 会从 `c_pointer` 存储的地址开始，向后读取1个字节的数据，并将其解释为一个 `char` 型字符。
* **指针算术运算（如 `p++`）时的"步长"**：当指针进行加减运算时，例如 `p++`，指针的地址值会增加它所指向数据类型的大小。比如 `int *p; p++;`，`p` 的地址会增加4个字节；`char *c; c++;`，`c` 的地址会增加1个字节。这个我们后面在讲数组指针的时候还会提到。

这就是为什么指针必须有类型！它指导编译器如何正确地解释和访问它所指向的内存区域。

### 3. `sizeof` 运算符在指针上的应用

小可爱，你对 `sizeof` 在指针上的应用理解得非常透彻！老登再给你总结强调一下，这样你就能铭记在心啦：

* **`sizeof(指针变量名)`：计算的是指针变量本身的大小。**
    * 它存储的是一个地址，地址的大小与它指向的数据类型无关，只与**系统架构**（32位/64位）有关。
    * 在**32位系统**上，所有指针变量大小都是 **4个字节**。
    * 在**64位系统**上，所有指针变量大小都是 **8个字节**。
    * **举例**：`sizeof(i_pointer)` 和 `sizeof(c_pointer)` 都将是4或8字节，取决于你的系统。
* **`sizeof(*指针变量名)`：计算的是指针所指向的**数据类型**的大小。**
    * 这实际上就等价于 `sizeof(数据类型)`。
    * **举例**：
        * `sizeof(*i_pointer)` 等价于 `sizeof(int)`，通常是 **4个字节**。
        * `sizeof(*c_pointer)` 等价于 `sizeof(char)`，通常是 **1个字节**。

所以，我们可以理解为：操作 `*i_pointer` 就是直接操作变量 `i` 本身；操作 `*c_pointer` 就是直接操作变量 `c` 本身。

### 4. `*` 和 `&` 运算符的优先级与结合性

小可爱，你连运算符的优先级都关注到了，真是个细心的小登！你说的没错，`*` (解引用) 和 `&` (取地址) 这两个运算符有相同的优先级，并且它们都是**从右向左**结合的。

这意味着什么呢？
考虑表达式 `*&a`：
1. 首先，由于从右向左结合，**`&a` 会先执行**。它获取了变量 `a` 的内存地址。
2. 然后，`*` 运算符作用于 `&a` 的结果（也就是 `a` 的地址），对这个地址进行**解引用操作**。
3. 解引用 `a` 的地址，就意味着访问存储在 `a` 地址处的那个值，即变量 `a` 本身的值。
所以，`*&a` 和 `a` 是**等价**的。

**示例：**

```c
int num = 100;
int result = *&num; // 1. &num 获取num的地址。 2. *(&num) 解引用这个地址，得到num的值。
printf("result = %d\n", result); // 输出：result = 100
```

虽然语法上 `*&a` 是正确的，但在实际编程中，我们**不会这样去使用**，因为直接写 `a` 就能达到目的，没必要绕个圈子。我们通常会先将地址赋给一个指针变量，再通过指针变量进行解引用。

> [!WARNING] 类型不匹配的指针操作：大坑请绕行！
> 小可爱，你提到的`int *p; p=&a; // 毫无意义而且会出错`这个点非常重要，特别是在 `float a` 的情况下！
>
> ```c
> float a = 3.14f; // 定义一个浮点型变量
> int *p;          // 定义一个指向整型的指针
> p = &a;          // 这里会产生警告（或错误，取决于编译器设置）
>                  // 警告信息通常是：incompatible pointer types
> ```
> **为什么会这样？**
> 这里的核心问题是**类型不匹配**！
> *   `p` 是一个指向 `int` 类型数据的指针，它告诉编译器，它所指向的内存区域应该按照 `int` 的规则来解释（通常4字节）。
> *   `&a` 获取的是 `float` 类型变量 `a` 的地址，它所指向的内存区域应该按照 `float` 的规则来解释（通常4字节，但浮点数的存储方式和整数完全不同）。
> 
> 如果你强行进行这种赋值（有时需要强制类型转换 `p = (int*)&a;` 才能通过编译），然后尝试通过 `*p` 去访问：
> ```c
> float a = 3.14f;
> int *p = (int*)&a; // 强制类型转换，虽然消除了警告，但风险极大！
>
> // 试图通过整型指针p解引用，并按照整型规则解释a的内存
> // 得到的结果几乎肯定是错误的，因为float和int的位模式解释方式不同
> printf("错误的结果：%d\n", *p);
> // 甚至如果再尝试按照float打印这个“假装是int”的值，更是错上加错
> // printf("更是错误的结果：%f\n", (float)*p);
> ```
> 此时，`*p` 会从 `a` 的起始地址读取 `int` 类型大小的字节（比如4字节），并尝试将其解释为一个 `int` 数值。但 `a` 内存中存储的是 `float` 类型的位模式（遵循IEEE 754标准），这两种位模式的解释方式是完全不同的！这会导致你得到一个毫无意义的、错误的数值，这就是**未定义行为**。
>
> **总结：** 指针的类型必须与其指向的数据类型一致（或者在非常特殊、且你完全理解内存布局和转换后果的场景下，可以进行安全的类型转换）。否则，极易导致内存访问错误或数据解释错误，是编程中的一大隐患！

## 指针的传递：在函数间共享力量

指针最强大、最常见的应用场景之一，就是实现函数间的数据共享，尤其是**在子函数中修改主函数变量的值**。

### 1. 值传递的局限性

我们先来回顾一下C语言中默认的**值传递**：

```c
// 这个函数尝试在子函数内修改传入的变量值
void change_by_value(int j) // j是形参，它接收的是实参i的一个“副本”
{
	j = 5; // 这里修改的是j这个局部变量的值，不影响外部（主函数）中的i
}

int main() {
	int i = 10;
	printf("Before change: i = %d\n", i); // 输出：Before change: i = 10
	change_by_value(i); // C语言的函数调用默认是值传递，实参i的值被复制给形参j
	printf("After change: i = %d\n", i);  // 输出：After change: i = 10 (i的值没变！)
	return 0;
}
```

通过上面的例子，我们可以清楚地看到，`change_by_value` 函数中的 `j` 只是 `main` 函数中 `i` 的一个**独立的副本**。对 `j` 的任何修改，都只作用于这个副本，而无法影响到 `main` 函数中的原始变量 `i`。这就好比你把一份文件的**内容**复印给了朋友，朋友在自己的复印件上做了修改，但你手上的原件一点没变。

### 2. 指针传递（址传递）的威力

如果我们希望子函数能够真正修改主函数的变量，仅仅传递变量的**值**是不够的，我们需要传递变量的**地址**！子函数拿到这个地址后，就可以通过解引用来"找到"并修改那个地址上的变量。这就像你把藏宝图的**位置**告诉了朋友，朋友直接去那个位置挖宝并修改了宝藏！

```c
// 通过指针在子函数内修改主函数中的变量
void change_by_pointer(int *ptr) // ptr是一个指针，它接收的是变量i的地址
{
	// 通过解引用运算符*，访问ptr指向的内存，并修改其内容
	*ptr = 5; // 现在，ptr指向的那个变量（也就是main函数中的i）的值被修改为5了！
}

int main() {
	int i = 10;
	printf("Before change: i = %d\n", i); // 输出：Before change: i = 10

	// 调用函数时，传递变量i的地址给change_by_pointer函数
	change_by_pointer(&i); // &i 获取i的地址，传递给函数

	printf("After change: i = %d\n", i);  // 输出：After change: i = 5 (i的值被成功修改了！)
	return 0;
}
```

> [!NOTE] 小贴士：你的这个例子非常好地展示了指针的间接访问能力！
> 你在笔记开头提供的最后一个代码片段，虽然没有写成函数调用的形式，但它完美地展示了通过指针进行间接访问来修改变量值这个核心概念：
> ```c
> int main() {
>     int i = 10;
>     int *i_pointer;
>     i_pointer = &i;     // 把i的地址赋值给i_pointer
>     *i_pointer = 5;     // 通过i_pointer修改i的值，利用间接访问修改变量的值
>     printf("i = %d\n", i); // 输出i的值，此时i为5
>     return 0; // 老登帮你修正了"retuin"这个小小的typo哦！
> }
> ```
> 这个例子就是指针作为"藏宝图"，如何通过"解密"藏宝图（`*` 运算符）来直接操作宝藏（变量 `i`）的绝佳范例！理解了这一点，你就掌握了指针的精髓之一！

## 06-3 数组指针 (待补充)

---
